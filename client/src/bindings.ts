
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async fetchBattle(id: ClientBattleId) : Promise<BattleView> {
    return await TAURI_INVOKE("fetch_battle", { id });
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Represents the visual state of an ongoing dream battle
 */
export type BattleView = { 
/**
 * Unique identifier for this dream battle
 */
id: ClientBattleId; 
/**
 * Player who is operating the client
 */
user: PlayerView; 
/**
 * Opponent of user
 */
enemy: PlayerView; 
/**
 * Visual state of cards in the game
 */
cards: CardView[]; 
/**
 * Describes the status of the game, e.g. which phase & step the game is in
 */
statusDescription: string; 
/**
 * User interaction options
 */
controls: ControlView[] }
/**
 * Controls color for buttons
 */
export type ButtonKind = 
/**
 * Emphasized button, primary game action
 */
"primary" | 
/**
 * Deemphasized button, additional game actions
 */
"default"
/**
 * Button to perform some game action
 */
export type ButtonView = { label: string; kind: ButtonKind }
/**
 * Whether a card is face-down or face-up
 */
export type CardFacing = "faceDown" | "faceUp"
export type CardFrame = "character" | "event"
/**
 * Represents the visual state of a card or ability in a game
 */
export type CardView = { 
/**
 * Identifier for this card
 */
id: ClientCardId; 
/**
 * Position of this card in the UI
 */
position: ObjectPosition; 
/**
 * Card back image
 */
cardBack: Url; 
/**
 * If this card is revealed to the viewer, contains information on the
 * revealed face of the card.
 */
revealed: RevealedCardView | null; 
/**
 * True if this card is in a hidden zone but known to one or more opponents
 */
revealedToOpponents: boolean; 
/**
 * Face up/face down state for this card
 */
cardFacing: CardFacing; 
/**
 * Optionally, a position at which to create this card.
 * 
 * If this card does not already exist, it will be created at this position
 * before being animated to [Self::position].
 */
createPosition: ObjectPosition | null; 
/**
 * Optionally, a position at which to destroy this card.
 * 
 * If provided, the card will be animated to this position before being
 * destroyed.
 */
destroyPosition: ObjectPosition | null }
export type ClientBattleId = string
/**
 * Identifies a card in client code
 * 
 * Client-opaque serialized value.
 */
export type ClientCardId = { cardId: string } | { activatedAbilityId: string } | { triggeredAbilityId: string }
/**
 * User interaction options
 */
export type ControlView = { button: ButtonView }
export type DisplayImage = { 
/**
 * Image URL for this card
 */
image: Url; 
/**
 * X offset position of this image
 */
imageOffsetX: number | null; 
/**
 * Y offset position of this image
 */
imageOffsetY: number | null }
/**
 * Identifies a player in the context of the user interface.
 */
export type DisplayPlayer = 
/**
 * Player who is currently operating the client
 */
"user" | 
/**
 * Opponent of user, i.e. the AI enemy
 */
"enemy"
/**
 * A resource used to pay for cards & abilities.
 */
export type Energy = number
/**
 * Represents the position of some object in the UI
 */
export type ObjectPosition = { 
/**
 * Position category
 */
position: Position; 
/**
 * Sorting key, determines order within the position
 */
sortingKey: number; 
/**
 * Sub-key, used to break ties in sorting
 */
sortingSubKey: number }
/**
 * Represents the visual state of a player in a game
 */
export type PlayerView = { 
/**
 * Current score total
 */
score: Points; 
/**
 * Can this player currently take a game action?
 */
canAct: boolean }
/**
 * Victory points. Enable the player to win the game.
 */
export type Points = number
/**
 * Possible types of display positions
 */
export type Position = 
/**
 * Object position used in interface elements like the deck viewer which
 * don't rely on game positioning.
 */
"default" | 
/**
 * Object is not visible.
 */
"offscreen" | 
/**
 * Object is prominently revealed, being shown at a large size after
 * being played.
 */
"played" | 
/**
 * Object is on the stack
 */
"onStack" | 
/**
 * Object is in a player's hand
 */
{ inHand: DisplayPlayer } | 
/**
 * Object is in a player's deck
 */
{ inDeck: DisplayPlayer } | 
/**
 * Object is in a player's void
 */
{ inVoid: DisplayPlayer } | 
/**
 * Object is in this player's banished zone
 */
{ inBanished: DisplayPlayer } | 
/**
 * Object is on the battlefield
 */
{ onBattlefield: DisplayPlayer } | 
/**
 * Object is being displayed in a card browser, e.g. to select from a list
 * of cards while searching
 */
"browser" | 
/**
 * Object is being displayed in a list of cards available to select in a
 * card selector.
 */
"cardSelectionChoices" | 
/**
 * Object has just been revealed to this viewer
 */
"revealed" | 
/**
 * Object is in a temporary holding space for cards in hand while resolving
 * some other 'play card' ability.
 */
"handStorage"
export type RevealedCardStatus = "selected" | "canSelect" | "canPlay"
/**
 * Visual state of a revealed card
 */
export type RevealedCardView = { 
/**
 * Image URL for this card
 */
image: DisplayImage; 
/**
 * Name of this card
 */
name: string; 
/**
 * Cost of this card
 */
cost: Energy; 
/**
 * Spark value for this card
 */
spark: Spark | null; 
/**
 * Type or subtype of this card
 */
cardType: string; 
/**
 * Rules text to display for this face
 */
rulesText: string; 
/**
 * Visual status of this card
 */
status: RevealedCardStatus | null; 
/**
 * Frame to display for this card
 */
frame: CardFrame; 
/**
 * True if this card can be played during the opponent's turn
 */
isFast: boolean; 
/**
 * True if this card can be dragged by the player.
 * 
 * The set of valid drag targets is set on the GameView. All draggable
 * cards can be dragged to and reordered within any valid target.
 */
canDrag: boolean }
/**
 * Represents the 'power' of characters; the primary way in which players earn
 * victory points.
 */
export type Spark = number
/**
 * A URL
 */
export type Url = string

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
