// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Dreamcaller.Schema;
//
//    var schemaTypes = SchemaTypes.FromJson(jsonString);

namespace Dreamcaller.Schema
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class SchemaTypes
    {
        [JsonProperty("connectRequest", Required = Required.Always)]
        public ConnectRequest ConnectRequest { get; set; }

        [JsonProperty("connectResponse", Required = Required.Always)]
        public ConnectResponse ConnectResponse { get; set; }

        [JsonProperty("performActionRequest", Required = Required.Always)]
        public PerformActionRequest PerformActionRequest { get; set; }

        [JsonProperty("performActionResponse", Required = Required.Always)]
        public PerformActionResponse PerformActionResponse { get; set; }

        [JsonProperty("pollRequest", Required = Required.Always)]
        public PollRequest PollRequest { get; set; }

        [JsonProperty("pollResponse", Required = Required.Always)]
        public PollResponse PollResponse { get; set; }
    }

    public partial class ConnectRequest
    {
        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class Metadata
    {
        [JsonProperty("battleId")]
        public Guid? BattleId { get; set; }

        [JsonProperty("userId", Required = Required.Always)]
        public Guid UserId { get; set; }
    }

    public partial class ConnectResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    /// <summary>
    /// A list of [ParallelCommandGroup]s to execute sequentially.
    /// </summary>
    public partial class CommandSequence
    {
        [JsonProperty("groups", Required = Required.Always)]
        public List<ParallelCommandGroup> Groups { get; set; }
    }

    /// <summary>
    /// A set of [Command]s to execute simultaneously.
    /// </summary>
    public partial class ParallelCommandGroup
    {
        [JsonProperty("commands", Required = Required.Always)]
        public List<Command> Commands { get; set; }
    }

    /// <summary>
    /// Represents an animated update to the visual state of the game.
    /// </summary>
    public partial class Command
    {
        [JsonProperty("updateBattle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public UpdateBattleCommand UpdateBattle { get; set; }

        [JsonProperty("fireProjectile", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FireProjectileCommand FireProjectile { get; set; }

        [JsonProperty("dissolveCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DissolveCardCommand DissolveCard { get; set; }

        [JsonProperty("displayGameMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public GameMessageType? DisplayGameMessage { get; set; }

        [JsonProperty("displayEffect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEffectCommand DisplayEffect { get; set; }

        [JsonProperty("drawUserCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawUserCardsCommand DrawUserCards { get; set; }
    }

    public partial class DisplayEffectCommand
    {
        /// <summary>
        /// How long to wait before continuing with animations.
        /// </summary>
        [JsonProperty("duration", Required = Required.Always)]
        public Milliseconds Duration { get; set; }

        /// <summary>
        /// The effect to display.
        /// </summary>
        [JsonProperty("effect", Required = Required.Always)]
        public EffectAddress Effect { get; set; }

        /// <summary>
        /// Local scale to apply to this effect
        /// </summary>
        [JsonProperty("scale", Required = Required.Always)]
        public FlexVector3 Scale { get; set; }

        /// <summary>
        /// Sound to play along with effect
        /// </summary>
        [JsonProperty("sound")]
        public AudioClipAddress Sound { get; set; }

        /// <summary>
        /// The target to display the effect on.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public GameObjectId Target { get; set; }
    }

    /// <summary>
    /// How long to wait before continuing with animations.
    ///
    /// Time to display each card before moving it to hand.
    ///
    /// Should be less than stagger_interval for best results.
    ///
    /// Time to wait between drawing subsequent cards.
    /// </summary>
    public partial class Milliseconds
    {
        [JsonProperty("millisecondsValue", Required = Required.Always)]
        public long MillisecondsValue { get; set; }
    }

    /// <summary>
    /// The effect to display.
    /// </summary>
    public partial class EffectAddress
    {
        [JsonProperty("effect", Required = Required.Always)]
        public string Effect { get; set; }
    }

    /// <summary>
    /// Local scale to apply to this effect
    /// </summary>
    public partial class FlexVector3
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    public partial class AudioClipAddress
    {
        [JsonProperty("audioClip", Required = Required.Always)]
        public string AudioClip { get; set; }
    }

    /// <summary>
    /// The target to display the effect on.
    /// </summary>
    public partial class GameObjectId
    {
        [JsonProperty("cardId", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId CardId { get; set; }

        [JsonProperty("deck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Deck { get; set; }

        [JsonProperty("void", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Void { get; set; }

        [JsonProperty("avatar", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Avatar { get; set; }
    }

    /// <summary>
    /// Identifier for this card
    ///
    /// The card to dissolve.
    ///
    /// Once a card is dissolved, it will be invisible until a reverse dissolve is applied to it.
    /// </summary>
    public partial class CardId
    {
        [JsonProperty("idx", Required = Required.Always)]
        public long Idx { get; set; }

        [JsonProperty("version", Required = Required.Always)]
        public long Version { get; set; }
    }

    public partial class DissolveCardCommand
    {
        /// <summary>
        /// If true, dissolve will be played backwards to "create" the card.
        /// </summary>
        [JsonProperty("reverse", Required = Required.Always)]
        public bool Reverse { get; set; }

        /// <summary>
        /// The card to dissolve.
        ///
        /// Once a card is dissolved, it will be invisible until a reverse dissolve is applied to it.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public CardId Target { get; set; }
    }

    public partial class DrawUserCardsCommand
    {
        /// <summary>
        /// Cards to draw. Must already be present in user deck.
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardView> Cards { get; set; }

        /// <summary>
        /// Time to display each card before moving it to hand.
        ///
        /// Should be less than stagger_interval for best results.
        /// </summary>
        [JsonProperty("pauseDuration", Required = Required.Always)]
        public Milliseconds PauseDuration { get; set; }

        /// <summary>
        /// Time to wait between drawing subsequent cards.
        /// </summary>
        [JsonProperty("staggerInterval", Required = Required.Always)]
        public Milliseconds StaggerInterval { get; set; }
    }

    /// <summary>
    /// Represents the visual state of a card or ability in a game
    /// </summary>
    public partial class CardView
    {
        /// <summary>
        /// Card back image
        /// </summary>
        [JsonProperty("cardBack", Required = Required.Always)]
        public Url CardBack { get; set; }

        /// <summary>
        /// Face up/face down state for this card
        /// </summary>
        [JsonProperty("cardFacing", Required = Required.Always)]
        public CardFacing CardFacing { get; set; }

        /// <summary>
        /// Optionally, a position at which to create this card.
        ///
        /// If this card does not already exist, it will be created at this position before being
        /// animated to [Self::position].
        /// </summary>
        [JsonProperty("createPosition")]
        public ObjectPosition CreatePosition { get; set; }

        /// <summary>
        /// Optionally, a position at which to destroy this card.
        ///
        /// If provided, the card will be animated to this position before being destroyed.
        /// </summary>
        [JsonProperty("destroyPosition")]
        public ObjectPosition DestroyPosition { get; set; }

        /// <summary>
        /// Identifier for this card
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public CardId Id { get; set; }

        /// <summary>
        /// Position of this card in the UI
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public ObjectPosition Position { get; set; }

        /// <summary>
        /// If this card is revealed to the viewer, contains information on the revealed face of the
        /// card.
        /// </summary>
        [JsonProperty("revealed")]
        public RevealedCardView Revealed { get; set; }

        /// <summary>
        /// True if this card is in a hidden zone but known to one or more opponents
        /// </summary>
        [JsonProperty("revealedToOpponents", Required = Required.Always)]
        public bool RevealedToOpponents { get; set; }
    }

    /// <summary>
    /// Card back image
    ///
    /// A URL
    /// </summary>
    public partial class Url
    {
        [JsonProperty("urlValue", Required = Required.Always)]
        public string UrlValue { get; set; }
    }

    /// <summary>
    /// Represents the position of some object in the UI
    ///
    /// Position of this card in the UI
    /// </summary>
    public partial class ObjectPosition
    {
        /// <summary>
        /// Position category
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public Position Position { get; set; }

        /// <summary>
        /// Sorting key, determines order within the position
        /// </summary>
        [JsonProperty("sortingKey", Required = Required.Always)]
        public long SortingKey { get; set; }

        /// <summary>
        /// Sub-key, used to break ties in sorting
        /// </summary>
        [JsonProperty("sortingSubKey", Required = Required.Always)]
        public long SortingSubKey { get; set; }
    }

    /// <summary>
    /// The user is selecting targets for this card from among characters controlled by the
    /// indicated player.
    ///
    /// Object is in a player's hand
    ///
    /// Object is on top of a player's deck
    ///
    /// Object is shuffled into a player's deck
    ///
    /// Object is in a player's void
    ///
    /// Object is in this player's banished zone
    ///
    /// Object is on the battlefield
    /// </summary>
    public partial class PositionClass
    {
        [JsonProperty("selectingTargets", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? SelectingTargets { get; set; }

        [JsonProperty("inHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InHand { get; set; }

        [JsonProperty("onTopOfDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? OnTopOfDeck { get; set; }

        [JsonProperty("inDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InDeck { get; set; }

        [JsonProperty("inVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InVoid { get; set; }

        [JsonProperty("inBanished", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InBanished { get; set; }

        [JsonProperty("onBattlefield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? OnBattlefield { get; set; }
    }

    /// <summary>
    /// Visual state of a revealed card
    /// </summary>
    public partial class RevealedCardView
    {
        /// <summary>
        /// Actions available for this card
        /// </summary>
        [JsonProperty("actions", Required = Required.Always)]
        public CardActions Actions { get; set; }

        /// <summary>
        /// Type or subtype of this card
        /// </summary>
        [JsonProperty("cardType", Required = Required.Always)]
        public string CardType { get; set; }

        /// <summary>
        /// Cost of this card
        /// </summary>
        [JsonProperty("cost", Required = Required.Always)]
        public long Cost { get; set; }

        /// <summary>
        /// Special effects to display for this card
        /// </summary>
        [JsonProperty("effects", Required = Required.Always)]
        public CardEffects Effects { get; set; }

        /// <summary>
        /// Frame to display for this card
        /// </summary>
        [JsonProperty("frame", Required = Required.Always)]
        public CardFrame Frame { get; set; }

        /// <summary>
        /// Image for this card
        /// </summary>
        [JsonProperty("image", Required = Required.Always)]
        public DisplayImage Image { get; set; }

        /// <summary>
        /// True if this card can be played during the opponent's turn
        /// </summary>
        [JsonProperty("isFast", Required = Required.Always)]
        public bool IsFast { get; set; }

        /// <summary>
        /// Name of this card
        /// </summary>
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }

        /// <summary>
        /// Rules text to display for this car
        /// </summary>
        [JsonProperty("rulesText", Required = Required.Always)]
        public string RulesText { get; set; }

        /// <summary>
        /// Spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public long? Spark { get; set; }

        /// <summary>
        /// Visual status of this card
        /// </summary>
        [JsonProperty("status")]
        public RevealedCardStatus? Status { get; set; }

        /// <summary>
        /// Additional help text about this card, describing its abilities.
        /// </summary>
        [JsonProperty("supplementalCardInfo")]
        public FlexNode SupplementalCardInfo { get; set; }
    }

    /// <summary>
    /// Actions available for this card
    /// </summary>
    public partial class CardActions
    {
        /// <summary>
        /// True if this card can currently be played from hand.
        /// </summary>
        [JsonProperty("canPlay", Required = Required.Always)]
        public bool CanPlay { get; set; }

        /// <summary>
        /// Action to perform when this card is clicked.
        /// </summary>
        [JsonProperty("onClick")]
        public OnClickClass OnClick { get; set; }

        /// <summary>
        /// Sound to play when this card is played.
        /// </summary>
        [JsonProperty("onPlaySound")]
        public AudioClipAddress OnPlaySound { get; set; }
    }

    public partial class OnClickClass
    {
        [JsonProperty("debugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("battleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction BattleAction { get; set; }
    }

    /// <summary>
    /// An action that can be performed in a battle
    ///
    /// Set a card as a target of the card currently being played.
    /// </summary>
    public partial class BattleAction
    {
        [JsonProperty("playCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId PlayCard { get; set; }

        [JsonProperty("selectTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId SelectTarget { get; set; }
    }

    /// <summary>
    /// Special effects to display for this card
    /// </summary>
    public partial class CardEffects
    {
        /// <summary>
        /// Projectile to display as a trail behind this card.
        /// </summary>
        [JsonProperty("cardTrail")]
        public ProjectileAddress CardTrail { get; set; }
    }

    public partial class ProjectileAddress
    {
        [JsonProperty("projectile", Required = Required.Always)]
        public string Projectile { get; set; }
    }

    /// <summary>
    /// Image for this card
    /// </summary>
    public partial class DisplayImage
    {
        /// <summary>
        /// Image texture address for this card
        /// </summary>
        [JsonProperty("address", Required = Required.Always)]
        public SpriteAddress Address { get; set; }
    }

    /// <summary>
    /// Image texture address for this card
    /// </summary>
    public partial class SpriteAddress
    {
        [JsonProperty("sprite", Required = Required.Always)]
        public string Sprite { get; set; }
    }

    public partial class DraggableNode
    {
        [JsonProperty("customDragIndicator")]
        public FlexNode CustomDragIndicator { get; set; }

        [JsonProperty("dropTargetIdentifiers", Required = Required.Always)]
        public List<string> DropTargetIdentifiers { get; set; }

        [JsonProperty("hideIndicatorChildren", Required = Required.Always)]
        public List<string> HideIndicatorChildren { get; set; }

        [JsonProperty("horizontalDragStartDistance")]
        public long? HorizontalDragStartDistance { get; set; }

        [JsonProperty("onDragDetected")]
        public OnClickClass OnDragDetected { get; set; }

        [JsonProperty("onDrop")]
        public OnClickClass OnDrop { get; set; }

        [JsonProperty("overTargetIndicator")]
        public FlexNode OverTargetIndicator { get; set; }

        [JsonProperty("removeOriginal")]
        public bool? RemoveOriginal { get; set; }
    }

    public partial class NodeType
    {
        [JsonProperty("text", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Text Text { get; set; }

        [JsonProperty("scrollViewNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ScrollViewNode ScrollViewNode { get; set; }

        [JsonProperty("draggableNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DraggableNode DraggableNode { get; set; }

        [JsonProperty("textFieldNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TextFieldNode TextFieldNode { get; set; }

        [JsonProperty("sliderNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SliderNode SliderNode { get; set; }
    }

    public partial class FlexNode
    {
        [JsonProperty("children", Required = Required.Always)]
        public List<FlexNode> Children { get; set; }

        [JsonProperty("eventHandlers")]
        public EventHandlers EventHandlers { get; set; }

        [JsonProperty("hoverStyle")]
        public FlexStyle HoverStyle { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nodeType")]
        public NodeType NodeType { get; set; }

        [JsonProperty("onAttachStyle")]
        public FlexStyle OnAttachStyle { get; set; }

        [JsonProperty("pressedStyle")]
        public FlexStyle PressedStyle { get; set; }

        [JsonProperty("style")]
        public FlexStyle Style { get; set; }
    }

    public partial class ScrollViewNode
    {
        [JsonProperty("elasticity")]
        public double? Elasticity { get; set; }

        [JsonProperty("horizontalPageSize")]
        public double? HorizontalPageSize { get; set; }

        [JsonProperty("horizontalScrollBar")]
        public ScrollBar HorizontalScrollBar { get; set; }

        [JsonProperty("horizontalScrollBarVisibility")]
        public ScrollBarVisibility? HorizontalScrollBarVisibility { get; set; }

        [JsonProperty("mouseWheelScrollSize")]
        public double? MouseWheelScrollSize { get; set; }

        [JsonProperty("scrollDecelerationRate")]
        public double? ScrollDecelerationRate { get; set; }

        [JsonProperty("touchScrollBehavior")]
        public TouchScrollBehavior? TouchScrollBehavior { get; set; }

        [JsonProperty("verticalPageSize")]
        public double? VerticalPageSize { get; set; }

        [JsonProperty("verticalScrollBar")]
        public ScrollBar VerticalScrollBar { get; set; }

        [JsonProperty("verticalScrollBarVisibility")]
        public ScrollBarVisibility? VerticalScrollBarVisibility { get; set; }
    }

    public partial class ScrollBar
    {
        [JsonProperty("style")]
        public FlexStyle Style { get; set; }
    }

    public partial class FlexStyle
    {
        [JsonProperty("alignContent")]
        public FlexAlign? AlignContent { get; set; }

        [JsonProperty("alignItems")]
        public FlexAlign? AlignItems { get; set; }

        [JsonProperty("alignSelf")]
        public FlexAlign? AlignSelf { get; set; }

        [JsonProperty("backgroundColor")]
        public DisplayColor BackgroundColor { get; set; }

        [JsonProperty("backgroundImage")]
        public SpriteAddress BackgroundImage { get; set; }

        [JsonProperty("backgroundImageTintColor")]
        public DisplayColor BackgroundImageTintColor { get; set; }

        [JsonProperty("borderColor")]
        public BorderColor BorderColor { get; set; }

        [JsonProperty("borderRadius")]
        public BorderRadius BorderRadius { get; set; }

        [JsonProperty("borderWidth")]
        public BorderWidth BorderWidth { get; set; }

        [JsonProperty("color")]
        public DisplayColor Color { get; set; }

        [JsonProperty("display")]
        public FlexDisplayStyle? Display { get; set; }

        [JsonProperty("flexBasis")]
        public Dimension FlexBasis { get; set; }

        [JsonProperty("flexDirection")]
        public FlexDirection? FlexDirection { get; set; }

        [JsonProperty("flexGrow")]
        public double? FlexGrow { get; set; }

        [JsonProperty("flexShrink")]
        public double? FlexShrink { get; set; }

        [JsonProperty("font")]
        public FontAddress Font { get; set; }

        [JsonProperty("fontSize")]
        public Dimension FontSize { get; set; }

        [JsonProperty("fontStyle")]
        public FontStyle? FontStyle { get; set; }

        [JsonProperty("height")]
        public Dimension Height { get; set; }

        [JsonProperty("imageSlice")]
        public ImageSlice ImageSlice { get; set; }

        [JsonProperty("inset")]
        public FlexInsets Inset { get; set; }

        [JsonProperty("justifyContent")]
        public FlexJustify? JustifyContent { get; set; }

        [JsonProperty("letterSpacing")]
        public Dimension LetterSpacing { get; set; }

        [JsonProperty("margin")]
        public DimensionGroup Margin { get; set; }

        [JsonProperty("maxHeight")]
        public Dimension MaxHeight { get; set; }

        [JsonProperty("maxWidth")]
        public Dimension MaxWidth { get; set; }

        [JsonProperty("minHeight")]
        public Dimension MinHeight { get; set; }

        [JsonProperty("minWidth")]
        public Dimension MinWidth { get; set; }

        [JsonProperty("opacity")]
        public double? Opacity { get; set; }

        [JsonProperty("overflow")]
        public FlexVisibility? Overflow { get; set; }

        [JsonProperty("overflowClipBox")]
        public OverflowClipBox? OverflowClipBox { get; set; }

        [JsonProperty("padding")]
        public DimensionGroup Padding { get; set; }

        [JsonProperty("paragraphSpacing")]
        public Dimension ParagraphSpacing { get; set; }

        [JsonProperty("pickingMode")]
        public FlexPickingMode? PickingMode { get; set; }

        [JsonProperty("position")]
        public FlexPosition? Position { get; set; }

        [JsonProperty("rotate")]
        public FlexRotate Rotate { get; set; }

        [JsonProperty("scale")]
        public FlexScale Scale { get; set; }

        [JsonProperty("textAlign")]
        public TextAlign? TextAlign { get; set; }

        [JsonProperty("textOutlineColor")]
        public DisplayColor TextOutlineColor { get; set; }

        [JsonProperty("textOutlineWidth")]
        public double? TextOutlineWidth { get; set; }

        [JsonProperty("textOverflow")]
        public TextOverflow? TextOverflow { get; set; }

        [JsonProperty("textOverflowPosition")]
        public TextOverflowPosition? TextOverflowPosition { get; set; }

        [JsonProperty("textShadow")]
        public TextShadow TextShadow { get; set; }

        [JsonProperty("transformOrigin")]
        public FlexTranslate TransformOrigin { get; set; }

        [JsonProperty("transitionDelays", Required = Required.Always)]
        public List<Milliseconds> TransitionDelays { get; set; }

        [JsonProperty("transitionDurations", Required = Required.Always)]
        public List<Milliseconds> TransitionDurations { get; set; }

        [JsonProperty("transitionEasingModes", Required = Required.Always)]
        public List<EasingMode> TransitionEasingModes { get; set; }

        [JsonProperty("transitionProperties", Required = Required.Always)]
        public List<string> TransitionProperties { get; set; }

        [JsonProperty("translate")]
        public FlexTranslate Translate { get; set; }

        [JsonProperty("visibility")]
        public FlexVisibility? Visibility { get; set; }

        [JsonProperty("whiteSpace")]
        public WhiteSpace? WhiteSpace { get; set; }

        [JsonProperty("width")]
        public Dimension Width { get; set; }

        [JsonProperty("wordSpacing")]
        public Dimension WordSpacing { get; set; }

        [JsonProperty("wrap")]
        public FlexWrap? Wrap { get; set; }
    }

    /// <summary>
    /// Represents a color with the given RGBA values represented as floats in the 0-1 range.
    /// </summary>
    public partial class DisplayColor
    {
        [JsonProperty("alpha", Required = Required.Always)]
        public double Alpha { get; set; }

        [JsonProperty("blue", Required = Required.Always)]
        public double Blue { get; set; }

        [JsonProperty("green", Required = Required.Always)]
        public double Green { get; set; }

        [JsonProperty("red", Required = Required.Always)]
        public double Red { get; set; }
    }

    public partial class BorderColor
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public DisplayColor Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public DisplayColor Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public DisplayColor Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public DisplayColor Top { get; set; }
    }

    public partial class BorderRadius
    {
        [JsonProperty("bottomLeft", Required = Required.Always)]
        public Dimension BottomLeft { get; set; }

        [JsonProperty("bottomRight", Required = Required.Always)]
        public Dimension BottomRight { get; set; }

        [JsonProperty("topLeft", Required = Required.Always)]
        public Dimension TopLeft { get; set; }

        [JsonProperty("topRight", Required = Required.Always)]
        public Dimension TopRight { get; set; }
    }

    public partial class Dimension
    {
        [JsonProperty("unit", Required = Required.Always)]
        public DimensionUnit Unit { get; set; }

        [JsonProperty("value", Required = Required.Always)]
        public double Value { get; set; }
    }

    public partial class BorderWidth
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public double Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public double Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public double Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public double Top { get; set; }
    }

    public partial class FontAddress
    {
        [JsonProperty("font", Required = Required.Always)]
        public string Font { get; set; }
    }

    public partial class ImageSlice
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public long Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public long Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public long Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public long Top { get; set; }
    }

    public partial class FlexInsets
    {
        [JsonProperty("bottom")]
        public Dimension Bottom { get; set; }

        [JsonProperty("left")]
        public Dimension Left { get; set; }

        [JsonProperty("right")]
        public Dimension Right { get; set; }

        [JsonProperty("top")]
        public Dimension Top { get; set; }
    }

    public partial class DimensionGroup
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public Dimension Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public Dimension Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public Dimension Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public Dimension Top { get; set; }
    }

    public partial class FlexRotate
    {
        [JsonProperty("degrees", Required = Required.Always)]
        public double Degrees { get; set; }
    }

    public partial class FlexScale
    {
        [JsonProperty("amount", Required = Required.Always)]
        public FlexVector3 Amount { get; set; }
    }

    public partial class TextShadow
    {
        [JsonProperty("blurRadius", Required = Required.Always)]
        public double BlurRadius { get; set; }

        [JsonProperty("color", Required = Required.Always)]
        public DisplayColor Color { get; set; }

        [JsonProperty("offset", Required = Required.Always)]
        public FlexVector2 Offset { get; set; }
    }

    public partial class FlexVector2
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }
    }

    public partial class FlexTranslate
    {
        [JsonProperty("x", Required = Required.Always)]
        public Dimension X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public Dimension Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    public partial class SliderNode
    {
        [JsonProperty("direction")]
        public SliderDirection? Direction { get; set; }

        [JsonProperty("dragContainerStyle")]
        public FlexStyle DragContainerStyle { get; set; }

        [JsonProperty("draggerBorderStyle")]
        public FlexStyle DraggerBorderStyle { get; set; }

        [JsonProperty("draggerStyle")]
        public FlexStyle DraggerStyle { get; set; }

        [JsonProperty("highValue")]
        public double? HighValue { get; set; }

        [JsonProperty("initialValue")]
        public double? InitialValue { get; set; }

        [JsonProperty("inverted")]
        public bool? Inverted { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("labelStyle")]
        public FlexStyle LabelStyle { get; set; }

        [JsonProperty("lowValue")]
        public double? LowValue { get; set; }

        [JsonProperty("pageSize")]
        public double? PageSize { get; set; }

        [JsonProperty("preferenceKey")]
        public string PreferenceKey { get; set; }

        [JsonProperty("showInputField")]
        public bool? ShowInputField { get; set; }

        [JsonProperty("trackerStyle")]
        public FlexStyle TrackerStyle { get; set; }
    }

    public partial class Text
    {
        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    public partial class TextFieldNode
    {
        [JsonProperty("doubleClickSelectsWord")]
        public bool? DoubleClickSelectsWord { get; set; }

        [JsonProperty("globalIdentifier")]
        public string GlobalIdentifier { get; set; }

        [JsonProperty("initialText")]
        public string InitialText { get; set; }

        [JsonProperty("isPasswordField")]
        public bool? IsPasswordField { get; set; }

        [JsonProperty("isReadOnly")]
        public bool? IsReadOnly { get; set; }

        [JsonProperty("maskCharacter")]
        public string MaskCharacter { get; set; }

        [JsonProperty("maxLength")]
        public long? MaxLength { get; set; }

        [JsonProperty("multiline")]
        public bool? Multiline { get; set; }

        [JsonProperty("tripleClickSelectsLine")]
        public bool? TripleClickSelectsLine { get; set; }
    }

    public partial class EventHandlers
    {
        [JsonProperty("onClick")]
        public OnClickClass OnClick { get; set; }

        [JsonProperty("onFieldChanged")]
        public OnClickClass OnFieldChanged { get; set; }

        [JsonProperty("onLongPress")]
        public OnClickClass OnLongPress { get; set; }

        [JsonProperty("onMouseDown")]
        public OnClickClass OnMouseDown { get; set; }

        [JsonProperty("onMouseEnter")]
        public OnClickClass OnMouseEnter { get; set; }

        [JsonProperty("onMouseLeave")]
        public OnClickClass OnMouseLeave { get; set; }

        [JsonProperty("onMouseUp")]
        public OnClickClass OnMouseUp { get; set; }
    }

    public partial class FireProjectileCommand
    {
        [JsonProperty("additionalHit")]
        public EffectAddress AdditionalHit { get; set; }

        [JsonProperty("additionalHitDelay")]
        public Milliseconds AdditionalHitDelay { get; set; }

        [JsonProperty("fireSound")]
        public AudioClipAddress FireSound { get; set; }

        [JsonProperty("hideOnHit", Required = Required.Always)]
        public bool HideOnHit { get; set; }

        [JsonProperty("impactSound")]
        public AudioClipAddress ImpactSound { get; set; }

        [JsonProperty("jumpToPosition")]
        public ObjectPosition JumpToPosition { get; set; }

        [JsonProperty("projectile", Required = Required.Always)]
        public ProjectileAddress Projectile { get; set; }

        [JsonProperty("sourceId", Required = Required.Always)]
        public GameObjectId SourceId { get; set; }

        [JsonProperty("targetId", Required = Required.Always)]
        public GameObjectId TargetId { get; set; }

        [JsonProperty("travelDuration")]
        public Milliseconds TravelDuration { get; set; }

        [JsonProperty("waitDuration")]
        public Milliseconds WaitDuration { get; set; }
    }

    public partial class UpdateBattleCommand
    {
        /// <summary>
        /// The battle to update.
        /// </summary>
        [JsonProperty("battle", Required = Required.Always)]
        public BattleView Battle { get; set; }

        /// <summary>
        /// Sound to play when the battle is updated.
        /// </summary>
        [JsonProperty("updateSound")]
        public AudioClipAddress UpdateSound { get; set; }
    }

    /// <summary>
    /// The battle to update.
    ///
    /// Represents the visual state of an ongoing dream battle
    /// </summary>
    public partial class BattleView
    {
        /// <summary>
        /// Visual state of cards in the game
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardView> Cards { get; set; }

        /// <summary>
        /// Opponent of user
        /// </summary>
        [JsonProperty("enemy", Required = Required.Always)]
        public PlayerView Enemy { get; set; }

        /// <summary>
        /// Unique identifier for this dream battle
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public Guid Id { get; set; }

        /// <summary>
        /// UI to display to the player.
        /// </summary>
        [JsonProperty("interface", Required = Required.Always)]
        public InterfaceView Interface { get; set; }

        /// <summary>
        /// Describes the status of the game, e.g. which phase & step the game is in
        /// </summary>
        [JsonProperty("statusDescription", Required = Required.Always)]
        public string StatusDescription { get; set; }

        /// <summary>
        /// Player who is operating the client
        /// </summary>
        [JsonProperty("user", Required = Required.Always)]
        public PlayerView User { get; set; }
    }

    /// <summary>
    /// Opponent of user
    ///
    /// Represents the visual state of a player in a game
    ///
    /// Player who is operating the client
    /// </summary>
    public partial class PlayerView
    {
        /// <summary>
        /// Can this player currently take a game action?
        /// </summary>
        [JsonProperty("canAct", Required = Required.Always)]
        public bool CanAct { get; set; }

        /// <summary>
        /// Current score total
        /// </summary>
        [JsonProperty("score", Required = Required.Always)]
        public long Score { get; set; }
    }

    /// <summary>
    /// UI to display to the player.
    ///
    /// User interaction options
    /// </summary>
    public partial class InterfaceView
    {
        /// <summary>
        /// Label for the primary action button, if one should be shown.
        /// </summary>
        [JsonProperty("primaryActionButton")]
        public string PrimaryActionButton { get; set; }

        /// <summary>
        /// Content to display on top of all other game UI.
        /// </summary>
        [JsonProperty("screenOverlay")]
        public FlexNode ScreenOverlay { get; set; }
    }

    public partial class PerformActionRequest
    {
        [JsonProperty("action", Required = Required.Always)]
        public UserAction Action { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    /// <summary>
    /// All possible user interface actions
    /// </summary>
    public partial class UserAction
    {
        [JsonProperty("debugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("battleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction BattleAction { get; set; }
    }

    public partial class PerformActionResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollRequest
    {
        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    /// <summary>
    /// Identifies a player in the context of the user interface.
    ///
    /// Player who is currently operating the client
    ///
    /// Opponent of user, i.e. the AI enemy
    /// </summary>
    public enum DisplayPlayer { Enemy, User };

    public enum GameMessageType { Defeat, EnemyTurn, Victory, YourTurn };

    /// <summary>
    /// Face up/face down state for this card
    ///
    /// Whether a card is face-down or face-up
    /// </summary>
    public enum CardFacing { FaceDown, FaceUp };

    /// <summary>
    /// Object position used in interface elements like the deck viewer which don't rely on game
    /// positioning.
    ///
    /// Object is not visible.
    ///
    /// Object is prominently revealed, being shown at a large size after being played.
    ///
    /// Object is on the stack
    ///
    /// Position for cards to be shown to the user immediately after they're drawn.
    ///
    /// Object is being displayed in a card browser, e.g. to select from a list of cards while
    /// searching
    ///
    /// Object is being displayed in a list of cards available to select in a card selector.
    ///
    /// Object is in a temporary holding space for cards in hand while resolving some other 'play
    /// card' ability.
    /// </summary>
    public enum PositionEnum { Browser, CardSelectionChoices, Default, Drawn, HandStorage, Offscreen, OnStack, Played };

    /// <summary>
    /// Private actions for developer use
    /// </summary>
    public enum DebugAction { DrawCard };

    /// <summary>
    /// Frame to display for this card
    /// </summary>
    public enum CardFrame { Character, Event };

    public enum RevealedCardStatus { CanPlay, CanSelectNegative, CanSelectPositive, Selected };

    public enum FlexAlign { Auto, Center, FlexEnd, FlexStart, Stretch };

    public enum DimensionUnit { Percentage, Pixels, SafeAreaBottom, SafeAreaLeft, SafeAreaRight, SafeAreaTop, ViewportHeight, ViewportWidth };

    public enum FlexDisplayStyle { Flex, None };

    public enum FlexDirection { Column, ColumnReverse, Row, RowReverse };

    public enum FontStyle { Bold, BoldAndItalic, Italic, Normal };

    public enum FlexJustify { Center, FlexEnd, FlexStart, SpaceAround, SpaceBetween };

    public enum FlexVisibility { Hidden, Visible };

    public enum OverflowClipBox { ContentBox, PaddingBox };

    public enum FlexPickingMode { Ignore, Position };

    public enum FlexPosition { Absolute, Relative };

    public enum TextAlign { LowerCenter, LowerLeft, LowerRight, MiddleCenter, MiddleLeft, MiddleRight, UpperCenter, UpperLeft, UpperRight };

    public enum TextOverflow { Clip, Ellipsis };

    public enum TextOverflowPosition { End, Middle, Start };

    public enum EasingMode { Ease, EaseIn, EaseInBack, EaseInBounce, EaseInCirc, EaseInCubic, EaseInElastic, EaseInOut, EaseInOutBack, EaseInOutBounce, EaseInOutCirc, EaseInOutCubic, EaseInOutElastic, EaseInOutSine, EaseInSine, EaseOut, EaseOutBack, EaseOutBounce, EaseOutCirc, EaseOutCubic, EaseOutElastic, EaseOutSine, Linear };

    public enum WhiteSpace { NoWrap, Normal };

    public enum FlexWrap { NoWrap, Wrap, WrapReverse };

    public enum ScrollBarVisibility { AlwaysVisible, Auto, Hidden };

    public enum TouchScrollBehavior { Clamped, Elastic, Unrestricted };

    public enum SliderDirection { Horizontal, Vertical };

    /// <summary>
    /// Position category
    ///
    /// Possible types of display positions
    /// </summary>
    public partial struct Position
    {
        public PositionEnum? Enum;
        public PositionClass PositionClass;

        public static implicit operator Position(PositionEnum Enum) => new Position { Enum = Enum };
        public static implicit operator Position(PositionClass PositionClass) => new Position { PositionClass = PositionClass };
    }

    public partial class SchemaTypes
    {
        public static SchemaTypes FromJson(string json) => JsonConvert.DeserializeObject<SchemaTypes>(json, Dreamcaller.Schema.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SchemaTypes self) => JsonConvert.SerializeObject(self, Dreamcaller.Schema.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DisplayPlayerConverter.Singleton,
                GameMessageTypeConverter.Singleton,
                CardFacingConverter.Singleton,
                PositionConverter.Singleton,
                PositionEnumConverter.Singleton,
                DebugActionConverter.Singleton,
                CardFrameConverter.Singleton,
                RevealedCardStatusConverter.Singleton,
                FlexAlignConverter.Singleton,
                DimensionUnitConverter.Singleton,
                FlexDisplayStyleConverter.Singleton,
                FlexDirectionConverter.Singleton,
                FontStyleConverter.Singleton,
                FlexJustifyConverter.Singleton,
                FlexVisibilityConverter.Singleton,
                OverflowClipBoxConverter.Singleton,
                FlexPickingModeConverter.Singleton,
                FlexPositionConverter.Singleton,
                TextAlignConverter.Singleton,
                TextOverflowConverter.Singleton,
                TextOverflowPositionConverter.Singleton,
                EasingModeConverter.Singleton,
                WhiteSpaceConverter.Singleton,
                FlexWrapConverter.Singleton,
                ScrollBarVisibilityConverter.Singleton,
                TouchScrollBehaviorConverter.Singleton,
                SliderDirectionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DisplayPlayerConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayPlayer) || t == typeof(DisplayPlayer?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "enemy":
                    return DisplayPlayer.Enemy;
                case "user":
                    return DisplayPlayer.User;
            }
            throw new Exception("Cannot unmarshal type DisplayPlayer");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayPlayer)untypedValue;
            switch (value)
            {
                case DisplayPlayer.Enemy:
                    serializer.Serialize(writer, "enemy");
                    return;
                case DisplayPlayer.User:
                    serializer.Serialize(writer, "user");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayPlayer");
        }

        public static readonly DisplayPlayerConverter Singleton = new DisplayPlayerConverter();
    }

    internal class GameMessageTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameMessageType) || t == typeof(GameMessageType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "defeat":
                    return GameMessageType.Defeat;
                case "enemyTurn":
                    return GameMessageType.EnemyTurn;
                case "victory":
                    return GameMessageType.Victory;
                case "yourTurn":
                    return GameMessageType.YourTurn;
            }
            throw new Exception("Cannot unmarshal type GameMessageType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GameMessageType)untypedValue;
            switch (value)
            {
                case GameMessageType.Defeat:
                    serializer.Serialize(writer, "defeat");
                    return;
                case GameMessageType.EnemyTurn:
                    serializer.Serialize(writer, "enemyTurn");
                    return;
                case GameMessageType.Victory:
                    serializer.Serialize(writer, "victory");
                    return;
                case GameMessageType.YourTurn:
                    serializer.Serialize(writer, "yourTurn");
                    return;
            }
            throw new Exception("Cannot marshal type GameMessageType");
        }

        public static readonly GameMessageTypeConverter Singleton = new GameMessageTypeConverter();
    }

    internal class CardFacingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardFacing) || t == typeof(CardFacing?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "faceDown":
                    return CardFacing.FaceDown;
                case "faceUp":
                    return CardFacing.FaceUp;
            }
            throw new Exception("Cannot unmarshal type CardFacing");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardFacing)untypedValue;
            switch (value)
            {
                case CardFacing.FaceDown:
                    serializer.Serialize(writer, "faceDown");
                    return;
                case CardFacing.FaceUp:
                    serializer.Serialize(writer, "faceUp");
                    return;
            }
            throw new Exception("Cannot marshal type CardFacing");
        }

        public static readonly CardFacingConverter Singleton = new CardFacingConverter();
    }

    internal class PositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Position) || t == typeof(Position?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "browser":
                            return new Position { Enum = PositionEnum.Browser };
                        case "cardSelectionChoices":
                            return new Position { Enum = PositionEnum.CardSelectionChoices };
                        case "default":
                            return new Position { Enum = PositionEnum.Default };
                        case "drawn":
                            return new Position { Enum = PositionEnum.Drawn };
                        case "handStorage":
                            return new Position { Enum = PositionEnum.HandStorage };
                        case "offscreen":
                            return new Position { Enum = PositionEnum.Offscreen };
                        case "onStack":
                            return new Position { Enum = PositionEnum.OnStack };
                        case "played":
                            return new Position { Enum = PositionEnum.Played };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PositionClass>(reader);
                    return new Position { PositionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Position");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Position)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PositionEnum.Browser:
                        serializer.Serialize(writer, "browser");
                        return;
                    case PositionEnum.CardSelectionChoices:
                        serializer.Serialize(writer, "cardSelectionChoices");
                        return;
                    case PositionEnum.Default:
                        serializer.Serialize(writer, "default");
                        return;
                    case PositionEnum.Drawn:
                        serializer.Serialize(writer, "drawn");
                        return;
                    case PositionEnum.HandStorage:
                        serializer.Serialize(writer, "handStorage");
                        return;
                    case PositionEnum.Offscreen:
                        serializer.Serialize(writer, "offscreen");
                        return;
                    case PositionEnum.OnStack:
                        serializer.Serialize(writer, "onStack");
                        return;
                    case PositionEnum.Played:
                        serializer.Serialize(writer, "played");
                        return;
                }
            }
            if (value.PositionClass != null)
            {
                serializer.Serialize(writer, value.PositionClass);
                return;
            }
            throw new Exception("Cannot marshal type Position");
        }

        public static readonly PositionConverter Singleton = new PositionConverter();
    }

    internal class PositionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PositionEnum) || t == typeof(PositionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "browser":
                    return PositionEnum.Browser;
                case "cardSelectionChoices":
                    return PositionEnum.CardSelectionChoices;
                case "default":
                    return PositionEnum.Default;
                case "drawn":
                    return PositionEnum.Drawn;
                case "handStorage":
                    return PositionEnum.HandStorage;
                case "offscreen":
                    return PositionEnum.Offscreen;
                case "onStack":
                    return PositionEnum.OnStack;
                case "played":
                    return PositionEnum.Played;
            }
            throw new Exception("Cannot unmarshal type PositionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PositionEnum)untypedValue;
            switch (value)
            {
                case PositionEnum.Browser:
                    serializer.Serialize(writer, "browser");
                    return;
                case PositionEnum.CardSelectionChoices:
                    serializer.Serialize(writer, "cardSelectionChoices");
                    return;
                case PositionEnum.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case PositionEnum.Drawn:
                    serializer.Serialize(writer, "drawn");
                    return;
                case PositionEnum.HandStorage:
                    serializer.Serialize(writer, "handStorage");
                    return;
                case PositionEnum.Offscreen:
                    serializer.Serialize(writer, "offscreen");
                    return;
                case PositionEnum.OnStack:
                    serializer.Serialize(writer, "onStack");
                    return;
                case PositionEnum.Played:
                    serializer.Serialize(writer, "played");
                    return;
            }
            throw new Exception("Cannot marshal type PositionEnum");
        }

        public static readonly PositionEnumConverter Singleton = new PositionEnumConverter();
    }

    internal class DebugActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugAction) || t == typeof(DebugAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "drawCard")
            {
                return DebugAction.DrawCard;
            }
            throw new Exception("Cannot unmarshal type DebugAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DebugAction)untypedValue;
            if (value == DebugAction.DrawCard)
            {
                serializer.Serialize(writer, "drawCard");
                return;
            }
            throw new Exception("Cannot marshal type DebugAction");
        }

        public static readonly DebugActionConverter Singleton = new DebugActionConverter();
    }

    internal class CardFrameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardFrame) || t == typeof(CardFrame?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "character":
                    return CardFrame.Character;
                case "event":
                    return CardFrame.Event;
            }
            throw new Exception("Cannot unmarshal type CardFrame");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardFrame)untypedValue;
            switch (value)
            {
                case CardFrame.Character:
                    serializer.Serialize(writer, "character");
                    return;
                case CardFrame.Event:
                    serializer.Serialize(writer, "event");
                    return;
            }
            throw new Exception("Cannot marshal type CardFrame");
        }

        public static readonly CardFrameConverter Singleton = new CardFrameConverter();
    }

    internal class RevealedCardStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RevealedCardStatus) || t == typeof(RevealedCardStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "canPlay":
                    return RevealedCardStatus.CanPlay;
                case "canSelectNegative":
                    return RevealedCardStatus.CanSelectNegative;
                case "canSelectPositive":
                    return RevealedCardStatus.CanSelectPositive;
                case "selected":
                    return RevealedCardStatus.Selected;
            }
            throw new Exception("Cannot unmarshal type RevealedCardStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RevealedCardStatus)untypedValue;
            switch (value)
            {
                case RevealedCardStatus.CanPlay:
                    serializer.Serialize(writer, "canPlay");
                    return;
                case RevealedCardStatus.CanSelectNegative:
                    serializer.Serialize(writer, "canSelectNegative");
                    return;
                case RevealedCardStatus.CanSelectPositive:
                    serializer.Serialize(writer, "canSelectPositive");
                    return;
                case RevealedCardStatus.Selected:
                    serializer.Serialize(writer, "selected");
                    return;
            }
            throw new Exception("Cannot marshal type RevealedCardStatus");
        }

        public static readonly RevealedCardStatusConverter Singleton = new RevealedCardStatusConverter();
    }

    internal class FlexAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexAlign) || t == typeof(FlexAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "auto":
                    return FlexAlign.Auto;
                case "center":
                    return FlexAlign.Center;
                case "flexEnd":
                    return FlexAlign.FlexEnd;
                case "flexStart":
                    return FlexAlign.FlexStart;
                case "stretch":
                    return FlexAlign.Stretch;
            }
            throw new Exception("Cannot unmarshal type FlexAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexAlign)untypedValue;
            switch (value)
            {
                case FlexAlign.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case FlexAlign.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case FlexAlign.FlexEnd:
                    serializer.Serialize(writer, "flexEnd");
                    return;
                case FlexAlign.FlexStart:
                    serializer.Serialize(writer, "flexStart");
                    return;
                case FlexAlign.Stretch:
                    serializer.Serialize(writer, "stretch");
                    return;
            }
            throw new Exception("Cannot marshal type FlexAlign");
        }

        public static readonly FlexAlignConverter Singleton = new FlexAlignConverter();
    }

    internal class DimensionUnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DimensionUnit) || t == typeof(DimensionUnit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "percentage":
                    return DimensionUnit.Percentage;
                case "pixels":
                    return DimensionUnit.Pixels;
                case "safeAreaBottom":
                    return DimensionUnit.SafeAreaBottom;
                case "safeAreaLeft":
                    return DimensionUnit.SafeAreaLeft;
                case "safeAreaRight":
                    return DimensionUnit.SafeAreaRight;
                case "safeAreaTop":
                    return DimensionUnit.SafeAreaTop;
                case "viewportHeight":
                    return DimensionUnit.ViewportHeight;
                case "viewportWidth":
                    return DimensionUnit.ViewportWidth;
            }
            throw new Exception("Cannot unmarshal type DimensionUnit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DimensionUnit)untypedValue;
            switch (value)
            {
                case DimensionUnit.Percentage:
                    serializer.Serialize(writer, "percentage");
                    return;
                case DimensionUnit.Pixels:
                    serializer.Serialize(writer, "pixels");
                    return;
                case DimensionUnit.SafeAreaBottom:
                    serializer.Serialize(writer, "safeAreaBottom");
                    return;
                case DimensionUnit.SafeAreaLeft:
                    serializer.Serialize(writer, "safeAreaLeft");
                    return;
                case DimensionUnit.SafeAreaRight:
                    serializer.Serialize(writer, "safeAreaRight");
                    return;
                case DimensionUnit.SafeAreaTop:
                    serializer.Serialize(writer, "safeAreaTop");
                    return;
                case DimensionUnit.ViewportHeight:
                    serializer.Serialize(writer, "viewportHeight");
                    return;
                case DimensionUnit.ViewportWidth:
                    serializer.Serialize(writer, "viewportWidth");
                    return;
            }
            throw new Exception("Cannot marshal type DimensionUnit");
        }

        public static readonly DimensionUnitConverter Singleton = new DimensionUnitConverter();
    }

    internal class FlexDisplayStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDisplayStyle) || t == typeof(FlexDisplayStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "flex":
                    return FlexDisplayStyle.Flex;
                case "none":
                    return FlexDisplayStyle.None;
            }
            throw new Exception("Cannot unmarshal type FlexDisplayStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDisplayStyle)untypedValue;
            switch (value)
            {
                case FlexDisplayStyle.Flex:
                    serializer.Serialize(writer, "flex");
                    return;
                case FlexDisplayStyle.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDisplayStyle");
        }

        public static readonly FlexDisplayStyleConverter Singleton = new FlexDisplayStyleConverter();
    }

    internal class FlexDirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDirection) || t == typeof(FlexDirection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "column":
                    return FlexDirection.Column;
                case "columnReverse":
                    return FlexDirection.ColumnReverse;
                case "row":
                    return FlexDirection.Row;
                case "rowReverse":
                    return FlexDirection.RowReverse;
            }
            throw new Exception("Cannot unmarshal type FlexDirection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDirection)untypedValue;
            switch (value)
            {
                case FlexDirection.Column:
                    serializer.Serialize(writer, "column");
                    return;
                case FlexDirection.ColumnReverse:
                    serializer.Serialize(writer, "columnReverse");
                    return;
                case FlexDirection.Row:
                    serializer.Serialize(writer, "row");
                    return;
                case FlexDirection.RowReverse:
                    serializer.Serialize(writer, "rowReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDirection");
        }

        public static readonly FlexDirectionConverter Singleton = new FlexDirectionConverter();
    }

    internal class FontStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontStyle) || t == typeof(FontStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bold":
                    return FontStyle.Bold;
                case "boldAndItalic":
                    return FontStyle.BoldAndItalic;
                case "italic":
                    return FontStyle.Italic;
                case "normal":
                    return FontStyle.Normal;
            }
            throw new Exception("Cannot unmarshal type FontStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontStyle)untypedValue;
            switch (value)
            {
                case FontStyle.Bold:
                    serializer.Serialize(writer, "bold");
                    return;
                case FontStyle.BoldAndItalic:
                    serializer.Serialize(writer, "boldAndItalic");
                    return;
                case FontStyle.Italic:
                    serializer.Serialize(writer, "italic");
                    return;
                case FontStyle.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontStyle");
        }

        public static readonly FontStyleConverter Singleton = new FontStyleConverter();
    }

    internal class FlexJustifyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexJustify) || t == typeof(FlexJustify?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return FlexJustify.Center;
                case "flexEnd":
                    return FlexJustify.FlexEnd;
                case "flexStart":
                    return FlexJustify.FlexStart;
                case "spaceAround":
                    return FlexJustify.SpaceAround;
                case "spaceBetween":
                    return FlexJustify.SpaceBetween;
            }
            throw new Exception("Cannot unmarshal type FlexJustify");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexJustify)untypedValue;
            switch (value)
            {
                case FlexJustify.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case FlexJustify.FlexEnd:
                    serializer.Serialize(writer, "flexEnd");
                    return;
                case FlexJustify.FlexStart:
                    serializer.Serialize(writer, "flexStart");
                    return;
                case FlexJustify.SpaceAround:
                    serializer.Serialize(writer, "spaceAround");
                    return;
                case FlexJustify.SpaceBetween:
                    serializer.Serialize(writer, "spaceBetween");
                    return;
            }
            throw new Exception("Cannot marshal type FlexJustify");
        }

        public static readonly FlexJustifyConverter Singleton = new FlexJustifyConverter();
    }

    internal class FlexVisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexVisibility) || t == typeof(FlexVisibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hidden":
                    return FlexVisibility.Hidden;
                case "visible":
                    return FlexVisibility.Visible;
            }
            throw new Exception("Cannot unmarshal type FlexVisibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexVisibility)untypedValue;
            switch (value)
            {
                case FlexVisibility.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
                case FlexVisibility.Visible:
                    serializer.Serialize(writer, "visible");
                    return;
            }
            throw new Exception("Cannot marshal type FlexVisibility");
        }

        public static readonly FlexVisibilityConverter Singleton = new FlexVisibilityConverter();
    }

    internal class OverflowClipBoxConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OverflowClipBox) || t == typeof(OverflowClipBox?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "contentBox":
                    return OverflowClipBox.ContentBox;
                case "paddingBox":
                    return OverflowClipBox.PaddingBox;
            }
            throw new Exception("Cannot unmarshal type OverflowClipBox");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OverflowClipBox)untypedValue;
            switch (value)
            {
                case OverflowClipBox.ContentBox:
                    serializer.Serialize(writer, "contentBox");
                    return;
                case OverflowClipBox.PaddingBox:
                    serializer.Serialize(writer, "paddingBox");
                    return;
            }
            throw new Exception("Cannot marshal type OverflowClipBox");
        }

        public static readonly OverflowClipBoxConverter Singleton = new OverflowClipBoxConverter();
    }

    internal class FlexPickingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexPickingMode) || t == typeof(FlexPickingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ignore":
                    return FlexPickingMode.Ignore;
                case "position":
                    return FlexPickingMode.Position;
            }
            throw new Exception("Cannot unmarshal type FlexPickingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexPickingMode)untypedValue;
            switch (value)
            {
                case FlexPickingMode.Ignore:
                    serializer.Serialize(writer, "ignore");
                    return;
                case FlexPickingMode.Position:
                    serializer.Serialize(writer, "position");
                    return;
            }
            throw new Exception("Cannot marshal type FlexPickingMode");
        }

        public static readonly FlexPickingModeConverter Singleton = new FlexPickingModeConverter();
    }

    internal class FlexPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexPosition) || t == typeof(FlexPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "absolute":
                    return FlexPosition.Absolute;
                case "relative":
                    return FlexPosition.Relative;
            }
            throw new Exception("Cannot unmarshal type FlexPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexPosition)untypedValue;
            switch (value)
            {
                case FlexPosition.Absolute:
                    serializer.Serialize(writer, "absolute");
                    return;
                case FlexPosition.Relative:
                    serializer.Serialize(writer, "relative");
                    return;
            }
            throw new Exception("Cannot marshal type FlexPosition");
        }

        public static readonly FlexPositionConverter Singleton = new FlexPositionConverter();
    }

    internal class TextAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextAlign) || t == typeof(TextAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "lowerCenter":
                    return TextAlign.LowerCenter;
                case "lowerLeft":
                    return TextAlign.LowerLeft;
                case "lowerRight":
                    return TextAlign.LowerRight;
                case "middleCenter":
                    return TextAlign.MiddleCenter;
                case "middleLeft":
                    return TextAlign.MiddleLeft;
                case "middleRight":
                    return TextAlign.MiddleRight;
                case "upperCenter":
                    return TextAlign.UpperCenter;
                case "upperLeft":
                    return TextAlign.UpperLeft;
                case "upperRight":
                    return TextAlign.UpperRight;
            }
            throw new Exception("Cannot unmarshal type TextAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextAlign)untypedValue;
            switch (value)
            {
                case TextAlign.LowerCenter:
                    serializer.Serialize(writer, "lowerCenter");
                    return;
                case TextAlign.LowerLeft:
                    serializer.Serialize(writer, "lowerLeft");
                    return;
                case TextAlign.LowerRight:
                    serializer.Serialize(writer, "lowerRight");
                    return;
                case TextAlign.MiddleCenter:
                    serializer.Serialize(writer, "middleCenter");
                    return;
                case TextAlign.MiddleLeft:
                    serializer.Serialize(writer, "middleLeft");
                    return;
                case TextAlign.MiddleRight:
                    serializer.Serialize(writer, "middleRight");
                    return;
                case TextAlign.UpperCenter:
                    serializer.Serialize(writer, "upperCenter");
                    return;
                case TextAlign.UpperLeft:
                    serializer.Serialize(writer, "upperLeft");
                    return;
                case TextAlign.UpperRight:
                    serializer.Serialize(writer, "upperRight");
                    return;
            }
            throw new Exception("Cannot marshal type TextAlign");
        }

        public static readonly TextAlignConverter Singleton = new TextAlignConverter();
    }

    internal class TextOverflowConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflow) || t == typeof(TextOverflow?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "clip":
                    return TextOverflow.Clip;
                case "ellipsis":
                    return TextOverflow.Ellipsis;
            }
            throw new Exception("Cannot unmarshal type TextOverflow");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflow)untypedValue;
            switch (value)
            {
                case TextOverflow.Clip:
                    serializer.Serialize(writer, "clip");
                    return;
                case TextOverflow.Ellipsis:
                    serializer.Serialize(writer, "ellipsis");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflow");
        }

        public static readonly TextOverflowConverter Singleton = new TextOverflowConverter();
    }

    internal class TextOverflowPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflowPosition) || t == typeof(TextOverflowPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "end":
                    return TextOverflowPosition.End;
                case "middle":
                    return TextOverflowPosition.Middle;
                case "start":
                    return TextOverflowPosition.Start;
            }
            throw new Exception("Cannot unmarshal type TextOverflowPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflowPosition)untypedValue;
            switch (value)
            {
                case TextOverflowPosition.End:
                    serializer.Serialize(writer, "end");
                    return;
                case TextOverflowPosition.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case TextOverflowPosition.Start:
                    serializer.Serialize(writer, "start");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflowPosition");
        }

        public static readonly TextOverflowPositionConverter Singleton = new TextOverflowPositionConverter();
    }

    internal class EasingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EasingMode) || t == typeof(EasingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ease":
                    return EasingMode.Ease;
                case "easeIn":
                    return EasingMode.EaseIn;
                case "easeInBack":
                    return EasingMode.EaseInBack;
                case "easeInBounce":
                    return EasingMode.EaseInBounce;
                case "easeInCirc":
                    return EasingMode.EaseInCirc;
                case "easeInCubic":
                    return EasingMode.EaseInCubic;
                case "easeInElastic":
                    return EasingMode.EaseInElastic;
                case "easeInOut":
                    return EasingMode.EaseInOut;
                case "easeInOutBack":
                    return EasingMode.EaseInOutBack;
                case "easeInOutBounce":
                    return EasingMode.EaseInOutBounce;
                case "easeInOutCirc":
                    return EasingMode.EaseInOutCirc;
                case "easeInOutCubic":
                    return EasingMode.EaseInOutCubic;
                case "easeInOutElastic":
                    return EasingMode.EaseInOutElastic;
                case "easeInOutSine":
                    return EasingMode.EaseInOutSine;
                case "easeInSine":
                    return EasingMode.EaseInSine;
                case "easeOut":
                    return EasingMode.EaseOut;
                case "easeOutBack":
                    return EasingMode.EaseOutBack;
                case "easeOutBounce":
                    return EasingMode.EaseOutBounce;
                case "easeOutCirc":
                    return EasingMode.EaseOutCirc;
                case "easeOutCubic":
                    return EasingMode.EaseOutCubic;
                case "easeOutElastic":
                    return EasingMode.EaseOutElastic;
                case "easeOutSine":
                    return EasingMode.EaseOutSine;
                case "linear":
                    return EasingMode.Linear;
            }
            throw new Exception("Cannot unmarshal type EasingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EasingMode)untypedValue;
            switch (value)
            {
                case EasingMode.Ease:
                    serializer.Serialize(writer, "ease");
                    return;
                case EasingMode.EaseIn:
                    serializer.Serialize(writer, "easeIn");
                    return;
                case EasingMode.EaseInBack:
                    serializer.Serialize(writer, "easeInBack");
                    return;
                case EasingMode.EaseInBounce:
                    serializer.Serialize(writer, "easeInBounce");
                    return;
                case EasingMode.EaseInCirc:
                    serializer.Serialize(writer, "easeInCirc");
                    return;
                case EasingMode.EaseInCubic:
                    serializer.Serialize(writer, "easeInCubic");
                    return;
                case EasingMode.EaseInElastic:
                    serializer.Serialize(writer, "easeInElastic");
                    return;
                case EasingMode.EaseInOut:
                    serializer.Serialize(writer, "easeInOut");
                    return;
                case EasingMode.EaseInOutBack:
                    serializer.Serialize(writer, "easeInOutBack");
                    return;
                case EasingMode.EaseInOutBounce:
                    serializer.Serialize(writer, "easeInOutBounce");
                    return;
                case EasingMode.EaseInOutCirc:
                    serializer.Serialize(writer, "easeInOutCirc");
                    return;
                case EasingMode.EaseInOutCubic:
                    serializer.Serialize(writer, "easeInOutCubic");
                    return;
                case EasingMode.EaseInOutElastic:
                    serializer.Serialize(writer, "easeInOutElastic");
                    return;
                case EasingMode.EaseInOutSine:
                    serializer.Serialize(writer, "easeInOutSine");
                    return;
                case EasingMode.EaseInSine:
                    serializer.Serialize(writer, "easeInSine");
                    return;
                case EasingMode.EaseOut:
                    serializer.Serialize(writer, "easeOut");
                    return;
                case EasingMode.EaseOutBack:
                    serializer.Serialize(writer, "easeOutBack");
                    return;
                case EasingMode.EaseOutBounce:
                    serializer.Serialize(writer, "easeOutBounce");
                    return;
                case EasingMode.EaseOutCirc:
                    serializer.Serialize(writer, "easeOutCirc");
                    return;
                case EasingMode.EaseOutCubic:
                    serializer.Serialize(writer, "easeOutCubic");
                    return;
                case EasingMode.EaseOutElastic:
                    serializer.Serialize(writer, "easeOutElastic");
                    return;
                case EasingMode.EaseOutSine:
                    serializer.Serialize(writer, "easeOutSine");
                    return;
                case EasingMode.Linear:
                    serializer.Serialize(writer, "linear");
                    return;
            }
            throw new Exception("Cannot marshal type EasingMode");
        }

        public static readonly EasingModeConverter Singleton = new EasingModeConverter();
    }

    internal class WhiteSpaceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WhiteSpace) || t == typeof(WhiteSpace?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "noWrap":
                    return WhiteSpace.NoWrap;
                case "normal":
                    return WhiteSpace.Normal;
            }
            throw new Exception("Cannot unmarshal type WhiteSpace");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WhiteSpace)untypedValue;
            switch (value)
            {
                case WhiteSpace.NoWrap:
                    serializer.Serialize(writer, "noWrap");
                    return;
                case WhiteSpace.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type WhiteSpace");
        }

        public static readonly WhiteSpaceConverter Singleton = new WhiteSpaceConverter();
    }

    internal class FlexWrapConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexWrap) || t == typeof(FlexWrap?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "noWrap":
                    return FlexWrap.NoWrap;
                case "wrap":
                    return FlexWrap.Wrap;
                case "wrapReverse":
                    return FlexWrap.WrapReverse;
            }
            throw new Exception("Cannot unmarshal type FlexWrap");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexWrap)untypedValue;
            switch (value)
            {
                case FlexWrap.NoWrap:
                    serializer.Serialize(writer, "noWrap");
                    return;
                case FlexWrap.Wrap:
                    serializer.Serialize(writer, "wrap");
                    return;
                case FlexWrap.WrapReverse:
                    serializer.Serialize(writer, "wrapReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexWrap");
        }

        public static readonly FlexWrapConverter Singleton = new FlexWrapConverter();
    }

    internal class ScrollBarVisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScrollBarVisibility) || t == typeof(ScrollBarVisibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alwaysVisible":
                    return ScrollBarVisibility.AlwaysVisible;
                case "auto":
                    return ScrollBarVisibility.Auto;
                case "hidden":
                    return ScrollBarVisibility.Hidden;
            }
            throw new Exception("Cannot unmarshal type ScrollBarVisibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScrollBarVisibility)untypedValue;
            switch (value)
            {
                case ScrollBarVisibility.AlwaysVisible:
                    serializer.Serialize(writer, "alwaysVisible");
                    return;
                case ScrollBarVisibility.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case ScrollBarVisibility.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
            }
            throw new Exception("Cannot marshal type ScrollBarVisibility");
        }

        public static readonly ScrollBarVisibilityConverter Singleton = new ScrollBarVisibilityConverter();
    }

    internal class TouchScrollBehaviorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TouchScrollBehavior) || t == typeof(TouchScrollBehavior?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "clamped":
                    return TouchScrollBehavior.Clamped;
                case "elastic":
                    return TouchScrollBehavior.Elastic;
                case "unrestricted":
                    return TouchScrollBehavior.Unrestricted;
            }
            throw new Exception("Cannot unmarshal type TouchScrollBehavior");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TouchScrollBehavior)untypedValue;
            switch (value)
            {
                case TouchScrollBehavior.Clamped:
                    serializer.Serialize(writer, "clamped");
                    return;
                case TouchScrollBehavior.Elastic:
                    serializer.Serialize(writer, "elastic");
                    return;
                case TouchScrollBehavior.Unrestricted:
                    serializer.Serialize(writer, "unrestricted");
                    return;
            }
            throw new Exception("Cannot marshal type TouchScrollBehavior");
        }

        public static readonly TouchScrollBehaviorConverter Singleton = new TouchScrollBehaviorConverter();
    }

    internal class SliderDirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SliderDirection) || t == typeof(SliderDirection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "horizontal":
                    return SliderDirection.Horizontal;
                case "vertical":
                    return SliderDirection.Vertical;
            }
            throw new Exception("Cannot unmarshal type SliderDirection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SliderDirection)untypedValue;
            switch (value)
            {
                case SliderDirection.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case SliderDirection.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type SliderDirection");
        }

        public static readonly SliderDirectionConverter Singleton = new SliderDirectionConverter();
    }
}
