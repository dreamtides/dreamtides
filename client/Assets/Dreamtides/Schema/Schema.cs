// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Dreamtides.Schema;
//
//    var schemaTypes = SchemaTypes.FromJson(jsonString);

namespace Dreamtides.Schema
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class SchemaTypes
    {
        [JsonProperty("connectRequest", Required = Required.Always)]
        public ConnectRequest ConnectRequest { get; set; }

        [JsonProperty("connectResponse", Required = Required.Always)]
        public ConnectResponse ConnectResponse { get; set; }

        [JsonProperty("performActionRequest", Required = Required.Always)]
        public PerformActionRequest PerformActionRequest { get; set; }

        [JsonProperty("performActionResponse", Required = Required.Always)]
        public PerformActionResponse PerformActionResponse { get; set; }

        [JsonProperty("pollRequest", Required = Required.Always)]
        public PollRequest PollRequest { get; set; }

        [JsonProperty("pollResponse", Required = Required.Always)]
        public PollResponse PollResponse { get; set; }
    }

    public partial class ConnectRequest
    {
        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        [JsonProperty("testScenario")]
        public string TestScenario { get; set; }
    }

    public partial class Metadata
    {
        [JsonProperty("battleId")]
        public Guid? BattleId { get; set; }

        [JsonProperty("userId", Required = Required.Always)]
        public Guid UserId { get; set; }
    }

    public partial class ConnectResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    /// <summary>
    /// A list of [ParallelCommandGroup]s to execute sequentially.
    /// </summary>
    public partial class CommandSequence
    {
        [JsonProperty("groups", Required = Required.Always)]
        public List<ParallelCommandGroup> Groups { get; set; }
    }

    /// <summary>
    /// A set of [Command]s to execute simultaneously.
    /// </summary>
    public partial class ParallelCommandGroup
    {
        [JsonProperty("commands", Required = Required.Always)]
        public List<Command> Commands { get; set; }
    }

    /// <summary>
    /// Represents an animated update to the visual state of the game.
    /// </summary>
    public partial class Command
    {
        [JsonProperty("updateBattle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public UpdateBattleCommand UpdateBattle { get; set; }

        [JsonProperty("wait", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Milliseconds Wait { get; set; }

        [JsonProperty("fireProjectile", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FireProjectileCommand FireProjectile { get; set; }

        [JsonProperty("dissolveCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DissolveCardCommand DissolveCard { get; set; }

        [JsonProperty("displayGameMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public GameMessageType? DisplayGameMessage { get; set; }

        [JsonProperty("displayEffect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEffectCommand DisplayEffect { get; set; }

        [JsonProperty("drawUserCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawUserCardsCommand DrawUserCards { get; set; }

        [JsonProperty("displayJudgment", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayJudgmentCommand DisplayJudgment { get; set; }

        [JsonProperty("displayDreamwellActivation", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayDreamwellActivationCommand DisplayDreamwellActivation { get; set; }

        [JsonProperty("displayArrows", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayArrowsCommand DisplayArrows { get; set; }

        [JsonProperty("displayEnemyMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEnemyMessageCommand DisplayEnemyMessage { get; set; }

        [JsonProperty("toggleThinkingIndicator", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ToggleThinkingIndicatorCommand ToggleThinkingIndicator { get; set; }
    }

    public partial class DisplayArrowsCommand
    {
        [JsonProperty("arrows", Required = Required.Always)]
        public List<DisplayArrow> Arrows { get; set; }
    }

    public partial class DisplayArrow
    {
        [JsonProperty("color", Required = Required.Always)]
        public ArrowStyle Color { get; set; }

        [JsonProperty("source", Required = Required.Always)]
        public GameObjectId Source { get; set; }

        [JsonProperty("target", Required = Required.Always)]
        public GameObjectId Target { get; set; }
    }

    /// <summary>
    /// The target to display the effect on.
    /// </summary>
    public partial class GameObjectId
    {
        [JsonProperty("cardId", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId CardId { get; set; }

        [JsonProperty("deck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Deck { get; set; }

        [JsonProperty("void", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Void { get; set; }

        [JsonProperty("avatar", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Avatar { get; set; }
    }

    /// <summary>
    /// Identifier for this card
    ///
    /// The card to dissolve.
    ///
    /// Once a card is dissolved, it will be invisible until a reverse dissolve is applied to
    /// it.
    ///
    /// The card to display an activation for. This card will be moved from its current position
    /// (assumed to be the 'Dreamwell' position) to the DreamwellActivation position, and an
    /// update to the player's produced energy value will be displayed.
    ///
    /// If there are triggered events as a result of this activation, the card should be kept in
    /// the DreamwellActivation position for the next update. Otherwise it's typical to return
    /// the card to the Dreamwell position.
    /// </summary>
    public partial class CardId
    {
        [JsonProperty("idx", Required = Required.Always)]
        public long Idx { get; set; }

        [JsonProperty("version", Required = Required.Always)]
        public long Version { get; set; }
    }

    public partial class DisplayDreamwellActivationCommand
    {
        /// <summary>
        /// The card to display an activation for. This card will be moved from its current position
        /// (assumed to be the 'Dreamwell' position) to the DreamwellActivation position, and an
        /// update to the player's produced energy value will be displayed.
        ///
        /// If there are triggered events as a result of this activation, the card should be kept in
        /// the DreamwellActivation position for the next update. Otherwise it's typical to return
        /// the card to the Dreamwell position.
        /// </summary>
        [JsonProperty("cardId", Required = Required.Always)]
        public CardId CardId { get; set; }

        /// <summary>
        /// New energy available to this player, if it has changed.
        /// </summary>
        [JsonProperty("newEnergy")]
        public long? NewEnergy { get; set; }

        /// <summary>
        /// New energy produced by this player at the start of the turn, if it has changed.
        /// </summary>
        [JsonProperty("newProducedEnergy")]
        public long? NewProducedEnergy { get; set; }

        /// <summary>
        /// The player to display the dreamwell activation for.
        /// </summary>
        [JsonProperty("player", Required = Required.Always)]
        public DisplayPlayer Player { get; set; }
    }

    public partial class DisplayEffectCommand
    {
        /// <summary>
        /// How long to wait before continuing with animations.
        /// </summary>
        [JsonProperty("duration", Required = Required.Always)]
        public Milliseconds Duration { get; set; }

        /// <summary>
        /// The effect to display.
        /// </summary>
        [JsonProperty("effect", Required = Required.Always)]
        public EffectAddress Effect { get; set; }

        /// <summary>
        /// Local scale to apply to this effect
        /// </summary>
        [JsonProperty("scale", Required = Required.Always)]
        public FlexVector3 Scale { get; set; }

        /// <summary>
        /// Sound to play along with effect
        /// </summary>
        [JsonProperty("sound")]
        public AudioClipAddress Sound { get; set; }

        /// <summary>
        /// The target to display the effect on.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public GameObjectId Target { get; set; }
    }

    /// <summary>
    /// How long to wait before continuing with animations.
    ///
    /// Time to display each card before moving it to hand.
    ///
    /// Should be less than stagger_interval for best results.
    ///
    /// Time to wait between drawing subsequent cards.
    /// </summary>
    public partial class Milliseconds
    {
        [JsonProperty("millisecondsValue", Required = Required.Always)]
        public long MillisecondsValue { get; set; }
    }

    /// <summary>
    /// The effect to display.
    /// </summary>
    public partial class EffectAddress
    {
        [JsonProperty("effect", Required = Required.Always)]
        public string Effect { get; set; }
    }

    /// <summary>
    /// Local scale to apply to this effect
    /// </summary>
    public partial class FlexVector3
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    public partial class AudioClipAddress
    {
        [JsonProperty("audioClip", Required = Required.Always)]
        public string AudioClip { get; set; }
    }

    public partial class DisplayEnemyMessageCommand
    {
        [JsonProperty("message", Required = Required.Always)]
        public string Message { get; set; }

        [JsonProperty("showDuration", Required = Required.Always)]
        public Milliseconds ShowDuration { get; set; }
    }

    public partial class DisplayJudgmentCommand
    {
        /// <summary>
        /// The new score for the player, if it has changed.
        /// </summary>
        [JsonProperty("newScore")]
        public long? NewScore { get; set; }

        /// <summary>
        /// The player to display the judgment animation for.
        /// </summary>
        [JsonProperty("player", Required = Required.Always)]
        public DisplayPlayer Player { get; set; }
    }

    public partial class DissolveCardCommand
    {
        /// <summary>
        /// The color to use for the dissolve effect.
        /// </summary>
        [JsonProperty("color", Required = Required.Always)]
        public DisplayColor Color { get; set; }

        /// <summary>
        /// The speed multiplier of the dissolve effect. Defaults to 1.
        /// </summary>
        [JsonProperty("dissolveSpeed")]
        public double? DissolveSpeed { get; set; }

        /// <summary>
        /// The material to use for the dissolve effect.
        /// </summary>
        [JsonProperty("material", Required = Required.Always)]
        public MaterialAddress Material { get; set; }

        /// <summary>
        /// If true, dissolve will be played backwards to "create" the card.
        /// </summary>
        [JsonProperty("reverse", Required = Required.Always)]
        public bool Reverse { get; set; }

        /// <summary>
        /// The card to dissolve.
        ///
        /// Once a card is dissolved, it will be invisible until a reverse dissolve is applied to it.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public CardId Target { get; set; }
    }

    /// <summary>
    /// Represents a color with the given RGBA values represented as floats in the 0-1 range.
    ///
    /// The color to use for the dissolve effect.
    /// </summary>
    public partial class DisplayColor
    {
        [JsonProperty("alpha", Required = Required.Always)]
        public double Alpha { get; set; }

        [JsonProperty("blue", Required = Required.Always)]
        public double Blue { get; set; }

        [JsonProperty("green", Required = Required.Always)]
        public double Green { get; set; }

        [JsonProperty("red", Required = Required.Always)]
        public double Red { get; set; }
    }

    /// <summary>
    /// The material to use for the dissolve effect.
    /// </summary>
    public partial class MaterialAddress
    {
        [JsonProperty("material", Required = Required.Always)]
        public string Material { get; set; }
    }

    public partial class DrawUserCardsCommand
    {
        /// <summary>
        /// Cards to draw. Must already be present in user deck.
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardView> Cards { get; set; }

        /// <summary>
        /// Time to display each card before moving it to hand.
        ///
        /// Should be less than stagger_interval for best results.
        /// </summary>
        [JsonProperty("pauseDuration", Required = Required.Always)]
        public Milliseconds PauseDuration { get; set; }

        /// <summary>
        /// Time to wait between drawing subsequent cards.
        /// </summary>
        [JsonProperty("staggerInterval", Required = Required.Always)]
        public Milliseconds StaggerInterval { get; set; }
    }

    /// <summary>
    /// Represents the visual state of a card or ability in a game
    /// </summary>
    public partial class CardView
    {
        /// <summary>
        /// Face up/face down state for this card
        /// </summary>
        [JsonProperty("cardFacing", Required = Required.Always)]
        public CardFacing CardFacing { get; set; }

        /// <summary>
        /// Optionally, a position at which to create this card.
        ///
        /// If this card does not already exist, it will be created at this position before being
        /// animated to [Self::position].
        /// </summary>
        [JsonProperty("createPosition")]
        public ObjectPosition CreatePosition { get; set; }

        /// <summary>
        /// Optionally, a position at which to destroy this card.
        ///
        /// If provided, the card will be animated to this position before being destroyed.
        /// </summary>
        [JsonProperty("destroyPosition")]
        public ObjectPosition DestroyPosition { get; set; }

        /// <summary>
        /// Identifier for this card
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public CardId Id { get; set; }

        /// <summary>
        /// Position of this card in the UI
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public ObjectPosition Position { get; set; }

        /// <summary>
        /// Represents the general category of card being displayed.
        /// </summary>
        [JsonProperty("prefab", Required = Required.Always)]
        public CardPrefab Prefab { get; set; }

        /// <summary>
        /// If this card is revealed to the viewer, contains information on the revealed face of the
        /// card.
        /// </summary>
        [JsonProperty("revealed")]
        public RevealedCardView Revealed { get; set; }

        /// <summary>
        /// True if this card is in a hidden zone but known to one or more opponents
        /// </summary>
        [JsonProperty("revealedToOpponents", Required = Required.Always)]
        public bool RevealedToOpponents { get; set; }
    }

    /// <summary>
    /// Represents the position of some object in the UI
    ///
    /// Position of this card in the UI
    /// </summary>
    public partial class ObjectPosition
    {
        /// <summary>
        /// Position category
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public Position Position { get; set; }

        /// <summary>
        /// Sorting key, determines order within the position
        /// </summary>
        [JsonProperty("sortingKey", Required = Required.Always)]
        public long SortingKey { get; set; }

        /// <summary>
        /// Sub-key, used to break ties in sorting
        /// </summary>
        [JsonProperty("sortingSubKey", Required = Required.Always)]
        public long SortingSubKey { get; set; }
    }

    /// <summary>
    /// Object is on the stack, typically used by cards which were just played.
    ///
    /// There are four types of stacks. By default, cards display at a large display size,
    /// blocking the view of the battlefield. However, if any cards are present on the stack
    /// which target a character on the battlefield, the cards are displayed at a smaller size in
    /// order to enable viewing & selecting targets appropriately, based on the set of cards
    /// which are current or eligible targets.
    ///
    /// Object is in a player's hand
    ///
    /// Object is on top of a player's deck
    ///
    /// Object is shuffled into a player's deck
    ///
    /// Object is in a player's void
    ///
    /// Object is in this player's banished zone
    ///
    /// Object is on the battlefield
    ///
    /// Object is in a player's status zone
    ///
    /// Object is being displayed in a selector to determine the order of cards, e.g. when
    /// resolving the "forsee" effect.
    ///
    /// Object is in the dreamwell for a player (usually off-screen).
    ///
    /// Object is hidden within a card
    /// </summary>
    public partial class PositionClass
    {
        [JsonProperty("onStack", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public StackType? OnStack { get; set; }

        [JsonProperty("inHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InHand { get; set; }

        [JsonProperty("onTopOfDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? OnTopOfDeck { get; set; }

        [JsonProperty("inDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InDeck { get; set; }

        [JsonProperty("inVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InVoid { get; set; }

        [JsonProperty("inBanished", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InBanished { get; set; }

        [JsonProperty("onBattlefield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? OnBattlefield { get; set; }

        [JsonProperty("inPlayerStatus", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InPlayerStatus { get; set; }

        [JsonProperty("cardOrderSelector", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardOrderSelectionTarget? CardOrderSelector { get; set; }

        [JsonProperty("inDreamwell", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InDreamwell { get; set; }

        [JsonProperty("hiddenWithinCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId HiddenWithinCard { get; set; }
    }

    /// <summary>
    /// Visual state of a revealed card
    /// </summary>
    public partial class RevealedCardView
    {
        /// <summary>
        /// Actions available for this card
        /// </summary>
        [JsonProperty("actions", Required = Required.Always)]
        public CardActions Actions { get; set; }

        /// <summary>
        /// Type or subtype of this card
        /// </summary>
        [JsonProperty("cardType", Required = Required.Always)]
        public string CardType { get; set; }

        /// <summary>
        /// Cost of this card
        /// </summary>
        [JsonProperty("cost")]
        public long? Cost { get; set; }

        /// <summary>
        /// Special effects to display for this card
        /// </summary>
        [JsonProperty("effects", Required = Required.Always)]
        public CardEffects Effects { get; set; }

        /// <summary>
        /// Image for this card
        /// </summary>
        [JsonProperty("image", Required = Required.Always)]
        public DisplayImage Image { get; set; }

        /// <summary>
        /// True if this card can be played during the opponent's turn
        /// </summary>
        [JsonProperty("isFast", Required = Required.Always)]
        public bool IsFast { get; set; }

        /// <summary>
        /// Name of this card
        /// </summary>
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }

        /// <summary>
        /// Outline color of this card
        /// </summary>
        [JsonProperty("outlineColor")]
        public DisplayColor OutlineColor { get; set; }

        /// <summary>
        /// Energy produced by this card
        /// </summary>
        [JsonProperty("produced")]
        public long? Produced { get; set; }

        /// <summary>
        /// Rules text to display for this car
        /// </summary>
        [JsonProperty("rulesText", Required = Required.Always)]
        public string RulesText { get; set; }

        /// <summary>
        /// Spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public long? Spark { get; set; }

        /// <summary>
        /// Additional help text about this card, describing its abilities.
        /// </summary>
        [JsonProperty("supplementalCardInfo")]
        public FlexNode SupplementalCardInfo { get; set; }
    }

    /// <summary>
    /// Actions available for this card
    /// </summary>
    public partial class CardActions
    {
        /// <summary>
        /// True if this card can currently be played from hand.
        /// </summary>
        [JsonProperty("canPlay", Required = Required.Always)]
        public bool CanPlay { get; set; }

        /// <summary>
        /// True if this card can currently be dragged within a Card Order Selector.
        /// </summary>
        [JsonProperty("canSelectOrder", Required = Required.Always)]
        public bool CanSelectOrder { get; set; }

        /// <summary>
        /// Action to perform when this card is clicked.
        /// </summary>
        [JsonProperty("onClick")]
        public ActionClass OnClick { get; set; }

        /// <summary>
        /// Sound to play when this card is played.
        /// </summary>
        [JsonProperty("onPlaySound")]
        public AudioClipAddress OnPlaySound { get; set; }

        /// <summary>
        /// Preview of the battle state after this card is played.
        /// </summary>
        [JsonProperty("playEffectPreview")]
        public BattlePreviewView PlayEffectPreview { get; set; }
    }

    public partial class ActionClass
    {
        [JsonProperty("debugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("battleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? BattleAction { get; set; }
    }

    /// <summary>
    /// Play a card in the user's hand.
    ///
    /// Select a character as a target
    ///
    /// Select a card on the stack as a target
    ///
    /// Select a choice at a given index position in response to a prompt.
    ///
    /// Pick an amount of energy to pay as an additional cost to play a card.
    ///
    /// Sets the selected amount of energy to pay as an additional cost to play a card.
    ///
    /// Sets the position of a card in a card order selector.
    ///
    /// Show cards in a zone
    /// </summary>
    public partial class BattleActionClass
    {
        [JsonProperty("playCardFromHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId PlayCardFromHand { get; set; }

        [JsonProperty("selectCharacterTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId SelectCharacterTarget { get; set; }

        [JsonProperty("selectStackCardTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardId SelectStackCardTarget { get; set; }

        [JsonProperty("selectPromptChoice", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectPromptChoice { get; set; }

        [JsonProperty("selectEnergyAdditionalCost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectEnergyAdditionalCost { get; set; }

        [JsonProperty("setSelectedEnergyAdditionalCost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SetSelectedEnergyAdditionalCost { get; set; }

        [JsonProperty("selectCardOrder", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SelectCardOrder SelectCardOrder { get; set; }

        [JsonProperty("browseCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardBrowserType? BrowseCards { get; set; }
    }

    public partial class SelectCardOrder
    {
        [JsonProperty("cardId", Required = Required.Always)]
        public CardId CardId { get; set; }

        [JsonProperty("position", Required = Required.Always)]
        public long Position { get; set; }

        [JsonProperty("target", Required = Required.Always)]
        public CardOrderSelectionTarget Target { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a battle, shown e.g. in response to a card being
    /// selected to be played.
    /// </summary>
    public partial class BattlePreviewView
    {
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardPreviewView> Cards { get; set; }

        [JsonProperty("enemy", Required = Required.Always)]
        public PlayerPreviewView Enemy { get; set; }

        [JsonProperty("previewMessage")]
        public FlexNode PreviewMessage { get; set; }

        [JsonProperty("user", Required = Required.Always)]
        public PlayerPreviewView User { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a card.
    /// </summary>
    public partial class CardPreviewView
    {
        /// <summary>
        /// Icon to display over this card on the battlefield
        /// </summary>
        [JsonProperty("battlefieldIcon")]
        public string BattlefieldIcon { get; set; }

        /// <summary>
        /// Color of the battlefield icon
        /// </summary>
        [JsonProperty("battlefieldIconColor")]
        public DisplayColor BattlefieldIconColor { get; set; }

        [JsonProperty("cardId", Required = Required.Always)]
        public CardId CardId { get; set; }

        /// <summary>
        /// New cost value for this card
        /// </summary>
        [JsonProperty("cost")]
        public long? Cost { get; set; }

        /// <summary>
        /// New spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public long? Spark { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a player
    /// </summary>
    public partial class PlayerPreviewView
    {
        /// <summary>
        /// New energy available to this player
        /// </summary>
        [JsonProperty("energy")]
        public long? Energy { get; set; }

        /// <summary>
        /// New energy produced total
        /// </summary>
        [JsonProperty("producedEnergy")]
        public long? ProducedEnergy { get; set; }

        /// <summary>
        /// New score total
        /// </summary>
        [JsonProperty("score")]
        public long? Score { get; set; }

        /// <summary>
        /// New total spark for this player
        /// </summary>
        [JsonProperty("totalSpark")]
        public long? TotalSpark { get; set; }
    }

    public partial class DraggableNode
    {
        [JsonProperty("customDragIndicator")]
        public FlexNode CustomDragIndicator { get; set; }

        [JsonProperty("dropTargetIdentifiers", Required = Required.Always)]
        public List<string> DropTargetIdentifiers { get; set; }

        [JsonProperty("hideIndicatorChildren", Required = Required.Always)]
        public List<string> HideIndicatorChildren { get; set; }

        [JsonProperty("horizontalDragStartDistance")]
        public long? HorizontalDragStartDistance { get; set; }

        [JsonProperty("onDragDetected")]
        public ActionClass OnDragDetected { get; set; }

        [JsonProperty("onDrop")]
        public ActionClass OnDrop { get; set; }

        [JsonProperty("overTargetIndicator")]
        public FlexNode OverTargetIndicator { get; set; }

        [JsonProperty("removeOriginal")]
        public bool? RemoveOriginal { get; set; }
    }

    public partial class NodeType
    {
        [JsonProperty("text", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Text Text { get; set; }

        [JsonProperty("scrollViewNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ScrollViewNode ScrollViewNode { get; set; }

        [JsonProperty("draggableNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DraggableNode DraggableNode { get; set; }

        [JsonProperty("textFieldNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TextFieldNode TextFieldNode { get; set; }

        [JsonProperty("sliderNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SliderNode SliderNode { get; set; }
    }

    public partial class FlexNode
    {
        [JsonProperty("children", Required = Required.Always)]
        public List<FlexNode> Children { get; set; }

        [JsonProperty("eventHandlers")]
        public EventHandlers EventHandlers { get; set; }

        [JsonProperty("hoverStyle")]
        public FlexStyle HoverStyle { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nodeType")]
        public NodeType NodeType { get; set; }

        [JsonProperty("onAttachStyle")]
        public FlexStyle OnAttachStyle { get; set; }

        [JsonProperty("pressedStyle")]
        public FlexStyle PressedStyle { get; set; }

        [JsonProperty("style")]
        public FlexStyle Style { get; set; }
    }

    public partial class ScrollViewNode
    {
        [JsonProperty("elasticity")]
        public double? Elasticity { get; set; }

        [JsonProperty("horizontalPageSize")]
        public double? HorizontalPageSize { get; set; }

        [JsonProperty("horizontalScrollBar")]
        public ScrollBar HorizontalScrollBar { get; set; }

        [JsonProperty("horizontalScrollBarVisibility")]
        public ScrollBarVisibility? HorizontalScrollBarVisibility { get; set; }

        [JsonProperty("mouseWheelScrollSize")]
        public double? MouseWheelScrollSize { get; set; }

        [JsonProperty("scrollDecelerationRate")]
        public double? ScrollDecelerationRate { get; set; }

        [JsonProperty("touchScrollBehavior")]
        public TouchScrollBehavior? TouchScrollBehavior { get; set; }

        [JsonProperty("verticalPageSize")]
        public double? VerticalPageSize { get; set; }

        [JsonProperty("verticalScrollBar")]
        public ScrollBar VerticalScrollBar { get; set; }

        [JsonProperty("verticalScrollBarVisibility")]
        public ScrollBarVisibility? VerticalScrollBarVisibility { get; set; }
    }

    public partial class ScrollBar
    {
        [JsonProperty("style")]
        public FlexStyle Style { get; set; }
    }

    public partial class FlexStyle
    {
        [JsonProperty("alignContent")]
        public FlexAlign? AlignContent { get; set; }

        [JsonProperty("alignItems")]
        public FlexAlign? AlignItems { get; set; }

        [JsonProperty("alignSelf")]
        public FlexAlign? AlignSelf { get; set; }

        [JsonProperty("backgroundColor")]
        public DisplayColor BackgroundColor { get; set; }

        [JsonProperty("backgroundImage")]
        public SpriteAddress BackgroundImage { get; set; }

        [JsonProperty("backgroundImageTintColor")]
        public DisplayColor BackgroundImageTintColor { get; set; }

        [JsonProperty("borderColor")]
        public BorderColor BorderColor { get; set; }

        [JsonProperty("borderRadius")]
        public BorderRadius BorderRadius { get; set; }

        [JsonProperty("borderWidth")]
        public BorderWidth BorderWidth { get; set; }

        [JsonProperty("color")]
        public DisplayColor Color { get; set; }

        [JsonProperty("display")]
        public FlexDisplayStyle? Display { get; set; }

        [JsonProperty("flexBasis")]
        public Dimension FlexBasis { get; set; }

        [JsonProperty("flexDirection")]
        public FlexDirection? FlexDirection { get; set; }

        [JsonProperty("flexGrow")]
        public double? FlexGrow { get; set; }

        [JsonProperty("flexShrink")]
        public double? FlexShrink { get; set; }

        [JsonProperty("font")]
        public FontAddress Font { get; set; }

        [JsonProperty("fontSize")]
        public Dimension FontSize { get; set; }

        [JsonProperty("fontStyle")]
        public FontStyle? FontStyle { get; set; }

        [JsonProperty("height")]
        public Dimension Height { get; set; }

        [JsonProperty("imageSlice")]
        public ImageSlice ImageSlice { get; set; }

        [JsonProperty("inset")]
        public FlexInsets Inset { get; set; }

        [JsonProperty("justifyContent")]
        public FlexJustify? JustifyContent { get; set; }

        [JsonProperty("letterSpacing")]
        public Dimension LetterSpacing { get; set; }

        [JsonProperty("margin")]
        public DimensionGroup Margin { get; set; }

        [JsonProperty("maxHeight")]
        public Dimension MaxHeight { get; set; }

        [JsonProperty("maxWidth")]
        public Dimension MaxWidth { get; set; }

        [JsonProperty("minHeight")]
        public Dimension MinHeight { get; set; }

        [JsonProperty("minWidth")]
        public Dimension MinWidth { get; set; }

        [JsonProperty("opacity")]
        public double? Opacity { get; set; }

        [JsonProperty("overflow")]
        public FlexVisibility? Overflow { get; set; }

        [JsonProperty("overflowClipBox")]
        public OverflowClipBox? OverflowClipBox { get; set; }

        [JsonProperty("padding")]
        public DimensionGroup Padding { get; set; }

        [JsonProperty("paragraphSpacing")]
        public Dimension ParagraphSpacing { get; set; }

        [JsonProperty("pickingMode")]
        public FlexPickingMode? PickingMode { get; set; }

        [JsonProperty("position")]
        public FlexPosition? Position { get; set; }

        [JsonProperty("rotate")]
        public FlexRotate Rotate { get; set; }

        [JsonProperty("scale")]
        public FlexScale Scale { get; set; }

        [JsonProperty("textAlign")]
        public TextAlign? TextAlign { get; set; }

        [JsonProperty("textOutlineColor")]
        public DisplayColor TextOutlineColor { get; set; }

        [JsonProperty("textOutlineWidth")]
        public double? TextOutlineWidth { get; set; }

        [JsonProperty("textOverflow")]
        public TextOverflow? TextOverflow { get; set; }

        [JsonProperty("textOverflowPosition")]
        public TextOverflowPosition? TextOverflowPosition { get; set; }

        [JsonProperty("textShadow")]
        public TextShadow TextShadow { get; set; }

        [JsonProperty("transformOrigin")]
        public FlexTranslate TransformOrigin { get; set; }

        [JsonProperty("transitionDelays", Required = Required.Always)]
        public List<Milliseconds> TransitionDelays { get; set; }

        [JsonProperty("transitionDurations", Required = Required.Always)]
        public List<Milliseconds> TransitionDurations { get; set; }

        [JsonProperty("transitionEasingModes", Required = Required.Always)]
        public List<EasingMode> TransitionEasingModes { get; set; }

        [JsonProperty("transitionProperties", Required = Required.Always)]
        public List<string> TransitionProperties { get; set; }

        [JsonProperty("translate")]
        public FlexTranslate Translate { get; set; }

        [JsonProperty("visibility")]
        public FlexVisibility? Visibility { get; set; }

        [JsonProperty("whiteSpace")]
        public WhiteSpace? WhiteSpace { get; set; }

        [JsonProperty("width")]
        public Dimension Width { get; set; }

        [JsonProperty("wordSpacing")]
        public Dimension WordSpacing { get; set; }

        [JsonProperty("wrap")]
        public FlexWrap? Wrap { get; set; }
    }

    /// <summary>
    /// Image texture address for this card
    /// </summary>
    public partial class SpriteAddress
    {
        [JsonProperty("sprite", Required = Required.Always)]
        public string Sprite { get; set; }
    }

    public partial class BorderColor
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public DisplayColor Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public DisplayColor Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public DisplayColor Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public DisplayColor Top { get; set; }
    }

    public partial class BorderRadius
    {
        [JsonProperty("bottomLeft", Required = Required.Always)]
        public Dimension BottomLeft { get; set; }

        [JsonProperty("bottomRight", Required = Required.Always)]
        public Dimension BottomRight { get; set; }

        [JsonProperty("topLeft", Required = Required.Always)]
        public Dimension TopLeft { get; set; }

        [JsonProperty("topRight", Required = Required.Always)]
        public Dimension TopRight { get; set; }
    }

    public partial class Dimension
    {
        [JsonProperty("unit", Required = Required.Always)]
        public DimensionUnit Unit { get; set; }

        [JsonProperty("value", Required = Required.Always)]
        public double Value { get; set; }
    }

    public partial class BorderWidth
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public double Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public double Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public double Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public double Top { get; set; }
    }

    public partial class FontAddress
    {
        [JsonProperty("font", Required = Required.Always)]
        public string Font { get; set; }
    }

    public partial class ImageSlice
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public long Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public long Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public long Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public long Top { get; set; }
    }

    public partial class FlexInsets
    {
        [JsonProperty("bottom")]
        public Dimension Bottom { get; set; }

        [JsonProperty("left")]
        public Dimension Left { get; set; }

        [JsonProperty("right")]
        public Dimension Right { get; set; }

        [JsonProperty("top")]
        public Dimension Top { get; set; }
    }

    public partial class DimensionGroup
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public Dimension Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public Dimension Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public Dimension Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public Dimension Top { get; set; }
    }

    public partial class FlexRotate
    {
        [JsonProperty("degrees", Required = Required.Always)]
        public double Degrees { get; set; }
    }

    public partial class FlexScale
    {
        [JsonProperty("amount", Required = Required.Always)]
        public FlexVector3 Amount { get; set; }
    }

    public partial class TextShadow
    {
        [JsonProperty("blurRadius", Required = Required.Always)]
        public double BlurRadius { get; set; }

        [JsonProperty("color", Required = Required.Always)]
        public DisplayColor Color { get; set; }

        [JsonProperty("offset", Required = Required.Always)]
        public FlexVector2 Offset { get; set; }
    }

    public partial class FlexVector2
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }
    }

    public partial class FlexTranslate
    {
        [JsonProperty("x", Required = Required.Always)]
        public Dimension X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public Dimension Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    public partial class SliderNode
    {
        [JsonProperty("direction")]
        public SliderDirection? Direction { get; set; }

        [JsonProperty("dragContainerStyle")]
        public FlexStyle DragContainerStyle { get; set; }

        [JsonProperty("draggerBorderStyle")]
        public FlexStyle DraggerBorderStyle { get; set; }

        [JsonProperty("draggerStyle")]
        public FlexStyle DraggerStyle { get; set; }

        [JsonProperty("highValue")]
        public double? HighValue { get; set; }

        [JsonProperty("initialValue")]
        public double? InitialValue { get; set; }

        [JsonProperty("inverted")]
        public bool? Inverted { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("labelStyle")]
        public FlexStyle LabelStyle { get; set; }

        [JsonProperty("lowValue")]
        public double? LowValue { get; set; }

        [JsonProperty("pageSize")]
        public double? PageSize { get; set; }

        [JsonProperty("preferenceKey")]
        public string PreferenceKey { get; set; }

        [JsonProperty("showInputField")]
        public bool? ShowInputField { get; set; }

        [JsonProperty("trackerStyle")]
        public FlexStyle TrackerStyle { get; set; }
    }

    public partial class Text
    {
        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    public partial class TextFieldNode
    {
        [JsonProperty("doubleClickSelectsWord")]
        public bool? DoubleClickSelectsWord { get; set; }

        [JsonProperty("globalIdentifier")]
        public string GlobalIdentifier { get; set; }

        [JsonProperty("initialText")]
        public string InitialText { get; set; }

        [JsonProperty("isPasswordField")]
        public bool? IsPasswordField { get; set; }

        [JsonProperty("isReadOnly")]
        public bool? IsReadOnly { get; set; }

        [JsonProperty("maskCharacter")]
        public string MaskCharacter { get; set; }

        [JsonProperty("maxLength")]
        public long? MaxLength { get; set; }

        [JsonProperty("multiline")]
        public bool? Multiline { get; set; }

        [JsonProperty("tripleClickSelectsLine")]
        public bool? TripleClickSelectsLine { get; set; }
    }

    public partial class EventHandlers
    {
        [JsonProperty("onClick")]
        public ActionClass OnClick { get; set; }

        [JsonProperty("onFieldChanged")]
        public ActionClass OnFieldChanged { get; set; }

        [JsonProperty("onLongPress")]
        public ActionClass OnLongPress { get; set; }

        [JsonProperty("onMouseDown")]
        public ActionClass OnMouseDown { get; set; }

        [JsonProperty("onMouseEnter")]
        public ActionClass OnMouseEnter { get; set; }

        [JsonProperty("onMouseLeave")]
        public ActionClass OnMouseLeave { get; set; }

        [JsonProperty("onMouseUp")]
        public ActionClass OnMouseUp { get; set; }
    }

    /// <summary>
    /// Special effects to display for this card
    /// </summary>
    public partial class CardEffects
    {
        /// <summary>
        /// Projectile to display as a trail behind this card.
        /// </summary>
        [JsonProperty("cardTrail")]
        public ProjectileAddress CardTrail { get; set; }
    }

    public partial class ProjectileAddress
    {
        [JsonProperty("projectile", Required = Required.Always)]
        public string Projectile { get; set; }
    }

    /// <summary>
    /// Image for this card
    /// </summary>
    public partial class DisplayImage
    {
        /// <summary>
        /// Image texture address for this card
        /// </summary>
        [JsonProperty("address", Required = Required.Always)]
        public SpriteAddress Address { get; set; }
    }

    public partial class FireProjectileCommand
    {
        [JsonProperty("additionalHit")]
        public EffectAddress AdditionalHit { get; set; }

        [JsonProperty("additionalHitDelay")]
        public Milliseconds AdditionalHitDelay { get; set; }

        [JsonProperty("fireSound")]
        public AudioClipAddress FireSound { get; set; }

        [JsonProperty("hideOnHit", Required = Required.Always)]
        public bool HideOnHit { get; set; }

        [JsonProperty("impactSound")]
        public AudioClipAddress ImpactSound { get; set; }

        [JsonProperty("jumpToPosition")]
        public ObjectPosition JumpToPosition { get; set; }

        [JsonProperty("projectile", Required = Required.Always)]
        public ProjectileAddress Projectile { get; set; }

        [JsonProperty("sourceId", Required = Required.Always)]
        public GameObjectId SourceId { get; set; }

        [JsonProperty("targetId", Required = Required.Always)]
        public GameObjectId TargetId { get; set; }

        [JsonProperty("travelDuration")]
        public Milliseconds TravelDuration { get; set; }

        [JsonProperty("waitDuration")]
        public Milliseconds WaitDuration { get; set; }
    }

    public partial class ToggleThinkingIndicatorCommand
    {
        [JsonProperty("show", Required = Required.Always)]
        public bool Show { get; set; }
    }

    public partial class UpdateBattleCommand
    {
        /// <summary>
        /// The battle to update.
        /// </summary>
        [JsonProperty("battle", Required = Required.Always)]
        public BattleView Battle { get; set; }

        /// <summary>
        /// Sound to play when the battle is updated.
        /// </summary>
        [JsonProperty("updateSound")]
        public AudioClipAddress UpdateSound { get; set; }
    }

    /// <summary>
    /// The battle to update.
    ///
    /// Represents the visual state of an ongoing dream battle
    /// </summary>
    public partial class BattleView
    {
        /// <summary>
        /// Visual state of cards in the game
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardView> Cards { get; set; }

        /// <summary>
        /// Opponent of user
        /// </summary>
        [JsonProperty("enemy", Required = Required.Always)]
        public PlayerView Enemy { get; set; }

        /// <summary>
        /// Unique identifier for this dream battle
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public Guid Id { get; set; }

        /// <summary>
        /// UI to display to the player.
        /// </summary>
        [JsonProperty("interface", Required = Required.Always)]
        public InterfaceView Interface { get; set; }

        /// <summary>
        /// Player who is operating the client
        /// </summary>
        [JsonProperty("user", Required = Required.Always)]
        public PlayerView User { get; set; }
    }

    /// <summary>
    /// Opponent of user
    ///
    /// Represents the visual state of a player in a game
    ///
    /// Player who is operating the client
    /// </summary>
    public partial class PlayerView
    {
        /// <summary>
        /// Can this player currently take a game action?
        /// </summary>
        [JsonProperty("canAct", Required = Required.Always)]
        public bool CanAct { get; set; }

        /// <summary>
        /// Energy available to this player
        /// </summary>
        [JsonProperty("energy", Required = Required.Always)]
        public long Energy { get; set; }

        /// <summary>
        /// Energy produced by this player at the start of the current turn
        /// </summary>
        [JsonProperty("producedEnergy", Required = Required.Always)]
        public long ProducedEnergy { get; set; }

        /// <summary>
        /// Current score total
        /// </summary>
        [JsonProperty("score", Required = Required.Always)]
        public long Score { get; set; }

        /// <summary>
        /// Total spark for this player
        /// </summary>
        [JsonProperty("totalSpark", Required = Required.Always)]
        public long TotalSpark { get; set; }
    }

    /// <summary>
    /// UI to display to the player.
    ///
    /// User interaction options
    /// </summary>
    public partial class InterfaceView
    {
        /// <summary>
        /// Button most often used for toggling the visibility of card browsers.
        /// </summary>
        [JsonProperty("bottomRightButton")]
        public ButtonView BottomRightButton { get; set; }

        /// <summary>
        /// Options for display of the card order selector
        /// </summary>
        [JsonProperty("cardOrderSelector")]
        public CardOrderSelectorView CardOrderSelector { get; set; }

        /// <summary>
        /// Button to decrement the number shown in a number prompt.
        /// </summary>
        [JsonProperty("decrementButton")]
        public ActionButtonView DecrementButton { get; set; }

        /// <summary>
        /// Button to increment the number shown in a number prompt.
        /// </summary>
        [JsonProperty("incrementButton")]
        public ActionButtonView IncrementButton { get; set; }

        /// <summary>
        /// Primary action button, used for confirming selections and ending the turn. None indicates
        /// no button should be shown.
        /// </summary>
        [JsonProperty("primaryActionButton")]
        public ActionButtonView PrimaryActionButton { get; set; }

        /// <summary>
        /// Content to display on top of all other game UI.
        /// </summary>
        [JsonProperty("screenOverlay")]
        public FlexNode ScreenOverlay { get; set; }

        /// <summary>
        /// Secondary action button, used for alternative choice options.
        /// </summary>
        [JsonProperty("secondaryActionButton")]
        public ActionButtonView SecondaryActionButton { get; set; }
    }

    /// <summary>
    /// Button to perform some game action
    /// </summary>
    public partial class ButtonView
    {
        [JsonProperty("action", Required = Required.Always)]
        public GameAction Action { get; set; }

        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    /// <summary>
    /// All possible user interface actions
    /// </summary>
    public partial class GameAction
    {
        [JsonProperty("debugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("battleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? BattleAction { get; set; }
    }

    public partial class CardOrderSelectorView
    {
        /// <summary>
        /// Include the user's deck as a card drop target
        /// </summary>
        [JsonProperty("includeDeck", Required = Required.Always)]
        public bool IncludeDeck { get; set; }

        /// <summary>
        /// Include the user's void as a card drop target
        /// </summary>
        [JsonProperty("includeVoid", Required = Required.Always)]
        public bool IncludeVoid { get; set; }
    }

    public partial class ActionButtonView
    {
        /// <summary>
        /// Action to perform when the button is clicked. If None is provided, the button will appear
        /// disabled.
        /// </summary>
        [JsonProperty("action")]
        public ActionClass Action { get; set; }

        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }

        /// <summary>
        /// If provided, when the button is not visible, the button will wait for this duration after
        /// the last "update" before appearing. If this is None the button will display immediately.
        /// </summary>
        [JsonProperty("showOnIdleDuration")]
        public Milliseconds ShowOnIdleDuration { get; set; }
    }

    public partial class PerformActionRequest
    {
        [JsonProperty("action", Required = Required.Always)]
        public GameAction Action { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        [JsonProperty("testScenario")]
        public string TestScenario { get; set; }
    }

    public partial class PerformActionResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollRequest
    {
        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollResponse
    {
        [JsonProperty("commands")]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public enum ArrowStyle { Blue, Green, Red };

    /// <summary>
    /// Represents a player within the context of the display layer.
    ///
    /// The "viewer" is always the player operating the game client, this may correspond to
    /// either of the actual players in the game.
    ///
    /// The player to display the judgment animation for.
    ///
    /// The player to display the dreamwell activation for.
    /// </summary>
    public enum DisplayPlayer { Enemy, User };

    public enum GameMessageType { Defeat, EnemyTurn, Victory, YourTurn };

    /// <summary>
    /// Face up/face down state for this card
    ///
    /// Whether a card is face-down or face-up
    /// </summary>
    public enum CardFacing { FaceDown, FaceUp };

    /// <summary>
    /// Object position used in interface elements like the deck viewer which don't rely on game
    /// positioning.
    ///
    /// Object is not visible.
    ///
    /// Position for cards to be shown to the user immediately after they're drawn.
    ///
    /// Object is being displayed in a card browser, e.g. to select from a list of cards while
    /// searching
    ///
    /// Object is in a temporary holding space for cards in hand while resolving some other 'play
    /// card' ability.
    ///
    /// Object is in a position to display itself as part of a dreamwell activation.
    ///
    /// Object describes a game modifier or ongoing game effect
    ///
    /// Object is in the on-screen storage area, used to hold objects at a small size when
    /// they're not being focused on, e.g. when the user hides a card browser to get a better
    /// view of the battlefield.
    /// </summary>
    public enum PositionEnum { Browser, Default, Drawn, DreamwellActivation, GameModifier, HandStorage, Offscreen, OnScreenStorage };

    public enum CardOrderSelectionTarget { Deck, Void };

    public enum StackType { Default, TargetingBothBattlefields, TargetingEnemyBattlefield, TargetingUserBattlefield };

    /// <summary>
    /// Represents the general category of card being displayed.
    /// </summary>
    public enum CardPrefab { Character, Dreamsign, Dreamwell, Enemy, Event, Token };

    /// <summary>
    /// Pass on taking actions in response to a card being played by the opponent, thus causing
    /// the stack to be resolved.
    ///
    /// End your turn
    ///
    /// Start your next turn after the opponent takes the `EndTurn` action.
    ///
    /// Close the card browser
    ///
    /// Toggle the visibility of the card order selector
    ///
    /// Confirm the selected cards to mulligan
    /// </summary>
    public enum BattleActionEnum { CloseCardBrowser, EndTurn, ResolveStack, StartNextTurn, SubmitMulligan, ToggleOrderSelectorVisibility };

    public enum CardBrowserType { EnemyDeck, EnemyStatus, EnemyVoid, UserDeck, UserStatus, UserVoid };

    /// <summary>
    /// Private actions for developer use
    /// </summary>
    public enum DebugAction { ApplyTestScenarioAction, DrawCard, PerformSomeAction, TriggerEnemyJudgment, TriggerUserJudgment };

    public enum FlexAlign { Auto, Center, FlexEnd, FlexStart, Stretch };

    public enum DimensionUnit { Percentage, Pixels, SafeAreaBottom, SafeAreaLeft, SafeAreaRight, SafeAreaTop, ViewportHeight, ViewportWidth };

    public enum FlexDisplayStyle { Flex, None };

    public enum FlexDirection { Column, ColumnReverse, Row, RowReverse };

    public enum FontStyle { Bold, BoldAndItalic, Italic, Normal };

    public enum FlexJustify { Center, FlexEnd, FlexStart, SpaceAround, SpaceBetween };

    public enum FlexVisibility { Hidden, Visible };

    public enum OverflowClipBox { ContentBox, PaddingBox };

    public enum FlexPickingMode { Ignore, Position };

    public enum FlexPosition { Absolute, Relative };

    public enum TextAlign { LowerCenter, LowerLeft, LowerRight, MiddleCenter, MiddleLeft, MiddleRight, UpperCenter, UpperLeft, UpperRight };

    public enum TextOverflow { Clip, Ellipsis };

    public enum TextOverflowPosition { End, Middle, Start };

    public enum EasingMode { Ease, EaseIn, EaseInBack, EaseInBounce, EaseInCirc, EaseInCubic, EaseInElastic, EaseInOut, EaseInOutBack, EaseInOutBounce, EaseInOutCirc, EaseInOutCubic, EaseInOutElastic, EaseInOutSine, EaseInSine, EaseOut, EaseOutBack, EaseOutBounce, EaseOutCirc, EaseOutCubic, EaseOutElastic, EaseOutSine, Linear };

    public enum WhiteSpace { NoWrap, Normal };

    public enum FlexWrap { NoWrap, Wrap, WrapReverse };

    public enum ScrollBarVisibility { AlwaysVisible, Auto, Hidden };

    public enum TouchScrollBehavior { Clamped, Elastic, Unrestricted };

    public enum SliderDirection { Horizontal, Vertical };

    /// <summary>
    /// Position category
    ///
    /// Possible types of display positions
    /// </summary>
    public partial struct Position
    {
        public PositionEnum? Enum;
        public PositionClass PositionClass;

        public static implicit operator Position(PositionEnum Enum) => new Position { Enum = Enum };
        public static implicit operator Position(PositionClass PositionClass) => new Position { PositionClass = PositionClass };
    }

    /// <summary>
    /// An action that can be performed in a battle
    /// </summary>
    public partial struct BattleAction
    {
        public BattleActionClass BattleActionClass;
        public BattleActionEnum? Enum;

        public static implicit operator BattleAction(BattleActionClass BattleActionClass) => new BattleAction { BattleActionClass = BattleActionClass };
        public static implicit operator BattleAction(BattleActionEnum Enum) => new BattleAction { Enum = Enum };
    }

    public partial class SchemaTypes
    {
        public static SchemaTypes FromJson(string json) => JsonConvert.DeserializeObject<SchemaTypes>(json, Dreamtides.Schema.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SchemaTypes self) => JsonConvert.SerializeObject(self, Dreamtides.Schema.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ArrowStyleConverter.Singleton,
                DisplayPlayerConverter.Singleton,
                GameMessageTypeConverter.Singleton,
                CardFacingConverter.Singleton,
                PositionConverter.Singleton,
                CardOrderSelectionTargetConverter.Singleton,
                StackTypeConverter.Singleton,
                PositionEnumConverter.Singleton,
                CardPrefabConverter.Singleton,
                BattleActionConverter.Singleton,
                CardBrowserTypeConverter.Singleton,
                BattleActionEnumConverter.Singleton,
                DebugActionConverter.Singleton,
                FlexAlignConverter.Singleton,
                DimensionUnitConverter.Singleton,
                FlexDisplayStyleConverter.Singleton,
                FlexDirectionConverter.Singleton,
                FontStyleConverter.Singleton,
                FlexJustifyConverter.Singleton,
                FlexVisibilityConverter.Singleton,
                OverflowClipBoxConverter.Singleton,
                FlexPickingModeConverter.Singleton,
                FlexPositionConverter.Singleton,
                TextAlignConverter.Singleton,
                TextOverflowConverter.Singleton,
                TextOverflowPositionConverter.Singleton,
                EasingModeConverter.Singleton,
                WhiteSpaceConverter.Singleton,
                FlexWrapConverter.Singleton,
                ScrollBarVisibilityConverter.Singleton,
                TouchScrollBehaviorConverter.Singleton,
                SliderDirectionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ArrowStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ArrowStyle) || t == typeof(ArrowStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "blue":
                    return ArrowStyle.Blue;
                case "green":
                    return ArrowStyle.Green;
                case "red":
                    return ArrowStyle.Red;
            }
            throw new Exception("Cannot unmarshal type ArrowStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ArrowStyle)untypedValue;
            switch (value)
            {
                case ArrowStyle.Blue:
                    serializer.Serialize(writer, "blue");
                    return;
                case ArrowStyle.Green:
                    serializer.Serialize(writer, "green");
                    return;
                case ArrowStyle.Red:
                    serializer.Serialize(writer, "red");
                    return;
            }
            throw new Exception("Cannot marshal type ArrowStyle");
        }

        public static readonly ArrowStyleConverter Singleton = new ArrowStyleConverter();
    }

    internal class DisplayPlayerConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayPlayer) || t == typeof(DisplayPlayer?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Enemy":
                    return DisplayPlayer.Enemy;
                case "User":
                    return DisplayPlayer.User;
            }
            throw new Exception("Cannot unmarshal type DisplayPlayer");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayPlayer)untypedValue;
            switch (value)
            {
                case DisplayPlayer.Enemy:
                    serializer.Serialize(writer, "Enemy");
                    return;
                case DisplayPlayer.User:
                    serializer.Serialize(writer, "User");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayPlayer");
        }

        public static readonly DisplayPlayerConverter Singleton = new DisplayPlayerConverter();
    }

    internal class GameMessageTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameMessageType) || t == typeof(GameMessageType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "defeat":
                    return GameMessageType.Defeat;
                case "enemyTurn":
                    return GameMessageType.EnemyTurn;
                case "victory":
                    return GameMessageType.Victory;
                case "yourTurn":
                    return GameMessageType.YourTurn;
            }
            throw new Exception("Cannot unmarshal type GameMessageType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GameMessageType)untypedValue;
            switch (value)
            {
                case GameMessageType.Defeat:
                    serializer.Serialize(writer, "defeat");
                    return;
                case GameMessageType.EnemyTurn:
                    serializer.Serialize(writer, "enemyTurn");
                    return;
                case GameMessageType.Victory:
                    serializer.Serialize(writer, "victory");
                    return;
                case GameMessageType.YourTurn:
                    serializer.Serialize(writer, "yourTurn");
                    return;
            }
            throw new Exception("Cannot marshal type GameMessageType");
        }

        public static readonly GameMessageTypeConverter Singleton = new GameMessageTypeConverter();
    }

    internal class CardFacingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardFacing) || t == typeof(CardFacing?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "faceDown":
                    return CardFacing.FaceDown;
                case "faceUp":
                    return CardFacing.FaceUp;
            }
            throw new Exception("Cannot unmarshal type CardFacing");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardFacing)untypedValue;
            switch (value)
            {
                case CardFacing.FaceDown:
                    serializer.Serialize(writer, "faceDown");
                    return;
                case CardFacing.FaceUp:
                    serializer.Serialize(writer, "faceUp");
                    return;
            }
            throw new Exception("Cannot marshal type CardFacing");
        }

        public static readonly CardFacingConverter Singleton = new CardFacingConverter();
    }

    internal class PositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Position) || t == typeof(Position?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "browser":
                            return new Position { Enum = PositionEnum.Browser };
                        case "default":
                            return new Position { Enum = PositionEnum.Default };
                        case "drawn":
                            return new Position { Enum = PositionEnum.Drawn };
                        case "dreamwellActivation":
                            return new Position { Enum = PositionEnum.DreamwellActivation };
                        case "gameModifier":
                            return new Position { Enum = PositionEnum.GameModifier };
                        case "handStorage":
                            return new Position { Enum = PositionEnum.HandStorage };
                        case "offscreen":
                            return new Position { Enum = PositionEnum.Offscreen };
                        case "onScreenStorage":
                            return new Position { Enum = PositionEnum.OnScreenStorage };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PositionClass>(reader);
                    return new Position { PositionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Position");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Position)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PositionEnum.Browser:
                        serializer.Serialize(writer, "browser");
                        return;
                    case PositionEnum.Default:
                        serializer.Serialize(writer, "default");
                        return;
                    case PositionEnum.Drawn:
                        serializer.Serialize(writer, "drawn");
                        return;
                    case PositionEnum.DreamwellActivation:
                        serializer.Serialize(writer, "dreamwellActivation");
                        return;
                    case PositionEnum.GameModifier:
                        serializer.Serialize(writer, "gameModifier");
                        return;
                    case PositionEnum.HandStorage:
                        serializer.Serialize(writer, "handStorage");
                        return;
                    case PositionEnum.Offscreen:
                        serializer.Serialize(writer, "offscreen");
                        return;
                    case PositionEnum.OnScreenStorage:
                        serializer.Serialize(writer, "onScreenStorage");
                        return;
                }
            }
            if (value.PositionClass != null)
            {
                serializer.Serialize(writer, value.PositionClass);
                return;
            }
            throw new Exception("Cannot marshal type Position");
        }

        public static readonly PositionConverter Singleton = new PositionConverter();
    }

    internal class CardOrderSelectionTargetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardOrderSelectionTarget) || t == typeof(CardOrderSelectionTarget?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "deck":
                    return CardOrderSelectionTarget.Deck;
                case "void":
                    return CardOrderSelectionTarget.Void;
            }
            throw new Exception("Cannot unmarshal type CardOrderSelectionTarget");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardOrderSelectionTarget)untypedValue;
            switch (value)
            {
                case CardOrderSelectionTarget.Deck:
                    serializer.Serialize(writer, "deck");
                    return;
                case CardOrderSelectionTarget.Void:
                    serializer.Serialize(writer, "void");
                    return;
            }
            throw new Exception("Cannot marshal type CardOrderSelectionTarget");
        }

        public static readonly CardOrderSelectionTargetConverter Singleton = new CardOrderSelectionTargetConverter();
    }

    internal class StackTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StackType) || t == typeof(StackType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "default":
                    return StackType.Default;
                case "targetingBothBattlefields":
                    return StackType.TargetingBothBattlefields;
                case "targetingEnemyBattlefield":
                    return StackType.TargetingEnemyBattlefield;
                case "targetingUserBattlefield":
                    return StackType.TargetingUserBattlefield;
            }
            throw new Exception("Cannot unmarshal type StackType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StackType)untypedValue;
            switch (value)
            {
                case StackType.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case StackType.TargetingBothBattlefields:
                    serializer.Serialize(writer, "targetingBothBattlefields");
                    return;
                case StackType.TargetingEnemyBattlefield:
                    serializer.Serialize(writer, "targetingEnemyBattlefield");
                    return;
                case StackType.TargetingUserBattlefield:
                    serializer.Serialize(writer, "targetingUserBattlefield");
                    return;
            }
            throw new Exception("Cannot marshal type StackType");
        }

        public static readonly StackTypeConverter Singleton = new StackTypeConverter();
    }

    internal class PositionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PositionEnum) || t == typeof(PositionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "browser":
                    return PositionEnum.Browser;
                case "default":
                    return PositionEnum.Default;
                case "drawn":
                    return PositionEnum.Drawn;
                case "dreamwellActivation":
                    return PositionEnum.DreamwellActivation;
                case "gameModifier":
                    return PositionEnum.GameModifier;
                case "handStorage":
                    return PositionEnum.HandStorage;
                case "offscreen":
                    return PositionEnum.Offscreen;
                case "onScreenStorage":
                    return PositionEnum.OnScreenStorage;
            }
            throw new Exception("Cannot unmarshal type PositionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PositionEnum)untypedValue;
            switch (value)
            {
                case PositionEnum.Browser:
                    serializer.Serialize(writer, "browser");
                    return;
                case PositionEnum.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case PositionEnum.Drawn:
                    serializer.Serialize(writer, "drawn");
                    return;
                case PositionEnum.DreamwellActivation:
                    serializer.Serialize(writer, "dreamwellActivation");
                    return;
                case PositionEnum.GameModifier:
                    serializer.Serialize(writer, "gameModifier");
                    return;
                case PositionEnum.HandStorage:
                    serializer.Serialize(writer, "handStorage");
                    return;
                case PositionEnum.Offscreen:
                    serializer.Serialize(writer, "offscreen");
                    return;
                case PositionEnum.OnScreenStorage:
                    serializer.Serialize(writer, "onScreenStorage");
                    return;
            }
            throw new Exception("Cannot marshal type PositionEnum");
        }

        public static readonly PositionEnumConverter Singleton = new PositionEnumConverter();
    }

    internal class CardPrefabConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardPrefab) || t == typeof(CardPrefab?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "character":
                    return CardPrefab.Character;
                case "dreamsign":
                    return CardPrefab.Dreamsign;
                case "dreamwell":
                    return CardPrefab.Dreamwell;
                case "enemy":
                    return CardPrefab.Enemy;
                case "event":
                    return CardPrefab.Event;
                case "token":
                    return CardPrefab.Token;
            }
            throw new Exception("Cannot unmarshal type CardPrefab");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardPrefab)untypedValue;
            switch (value)
            {
                case CardPrefab.Character:
                    serializer.Serialize(writer, "character");
                    return;
                case CardPrefab.Dreamsign:
                    serializer.Serialize(writer, "dreamsign");
                    return;
                case CardPrefab.Dreamwell:
                    serializer.Serialize(writer, "dreamwell");
                    return;
                case CardPrefab.Enemy:
                    serializer.Serialize(writer, "enemy");
                    return;
                case CardPrefab.Event:
                    serializer.Serialize(writer, "event");
                    return;
                case CardPrefab.Token:
                    serializer.Serialize(writer, "token");
                    return;
            }
            throw new Exception("Cannot marshal type CardPrefab");
        }

        public static readonly CardPrefabConverter Singleton = new CardPrefabConverter();
    }

    internal class BattleActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleAction) || t == typeof(BattleAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "closeCardBrowser":
                            return new BattleAction { Enum = BattleActionEnum.CloseCardBrowser };
                        case "endTurn":
                            return new BattleAction { Enum = BattleActionEnum.EndTurn };
                        case "resolveStack":
                            return new BattleAction { Enum = BattleActionEnum.ResolveStack };
                        case "startNextTurn":
                            return new BattleAction { Enum = BattleActionEnum.StartNextTurn };
                        case "submitMulligan":
                            return new BattleAction { Enum = BattleActionEnum.SubmitMulligan };
                        case "toggleOrderSelectorVisibility":
                            return new BattleAction { Enum = BattleActionEnum.ToggleOrderSelectorVisibility };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BattleActionClass>(reader);
                    return new BattleAction { BattleActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type BattleAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BattleAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BattleActionEnum.CloseCardBrowser:
                        serializer.Serialize(writer, "closeCardBrowser");
                        return;
                    case BattleActionEnum.EndTurn:
                        serializer.Serialize(writer, "endTurn");
                        return;
                    case BattleActionEnum.ResolveStack:
                        serializer.Serialize(writer, "resolveStack");
                        return;
                    case BattleActionEnum.StartNextTurn:
                        serializer.Serialize(writer, "startNextTurn");
                        return;
                    case BattleActionEnum.SubmitMulligan:
                        serializer.Serialize(writer, "submitMulligan");
                        return;
                    case BattleActionEnum.ToggleOrderSelectorVisibility:
                        serializer.Serialize(writer, "toggleOrderSelectorVisibility");
                        return;
                }
            }
            if (value.BattleActionClass != null)
            {
                serializer.Serialize(writer, value.BattleActionClass);
                return;
            }
            throw new Exception("Cannot marshal type BattleAction");
        }

        public static readonly BattleActionConverter Singleton = new BattleActionConverter();
    }

    internal class CardBrowserTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardBrowserType) || t == typeof(CardBrowserType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "enemyDeck":
                    return CardBrowserType.EnemyDeck;
                case "enemyStatus":
                    return CardBrowserType.EnemyStatus;
                case "enemyVoid":
                    return CardBrowserType.EnemyVoid;
                case "userDeck":
                    return CardBrowserType.UserDeck;
                case "userStatus":
                    return CardBrowserType.UserStatus;
                case "userVoid":
                    return CardBrowserType.UserVoid;
            }
            throw new Exception("Cannot unmarshal type CardBrowserType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardBrowserType)untypedValue;
            switch (value)
            {
                case CardBrowserType.EnemyDeck:
                    serializer.Serialize(writer, "enemyDeck");
                    return;
                case CardBrowserType.EnemyStatus:
                    serializer.Serialize(writer, "enemyStatus");
                    return;
                case CardBrowserType.EnemyVoid:
                    serializer.Serialize(writer, "enemyVoid");
                    return;
                case CardBrowserType.UserDeck:
                    serializer.Serialize(writer, "userDeck");
                    return;
                case CardBrowserType.UserStatus:
                    serializer.Serialize(writer, "userStatus");
                    return;
                case CardBrowserType.UserVoid:
                    serializer.Serialize(writer, "userVoid");
                    return;
            }
            throw new Exception("Cannot marshal type CardBrowserType");
        }

        public static readonly CardBrowserTypeConverter Singleton = new CardBrowserTypeConverter();
    }

    internal class BattleActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleActionEnum) || t == typeof(BattleActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "closeCardBrowser":
                    return BattleActionEnum.CloseCardBrowser;
                case "endTurn":
                    return BattleActionEnum.EndTurn;
                case "resolveStack":
                    return BattleActionEnum.ResolveStack;
                case "startNextTurn":
                    return BattleActionEnum.StartNextTurn;
                case "submitMulligan":
                    return BattleActionEnum.SubmitMulligan;
                case "toggleOrderSelectorVisibility":
                    return BattleActionEnum.ToggleOrderSelectorVisibility;
            }
            throw new Exception("Cannot unmarshal type BattleActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattleActionEnum)untypedValue;
            switch (value)
            {
                case BattleActionEnum.CloseCardBrowser:
                    serializer.Serialize(writer, "closeCardBrowser");
                    return;
                case BattleActionEnum.EndTurn:
                    serializer.Serialize(writer, "endTurn");
                    return;
                case BattleActionEnum.ResolveStack:
                    serializer.Serialize(writer, "resolveStack");
                    return;
                case BattleActionEnum.StartNextTurn:
                    serializer.Serialize(writer, "startNextTurn");
                    return;
                case BattleActionEnum.SubmitMulligan:
                    serializer.Serialize(writer, "submitMulligan");
                    return;
                case BattleActionEnum.ToggleOrderSelectorVisibility:
                    serializer.Serialize(writer, "toggleOrderSelectorVisibility");
                    return;
            }
            throw new Exception("Cannot marshal type BattleActionEnum");
        }

        public static readonly BattleActionEnumConverter Singleton = new BattleActionEnumConverter();
    }

    internal class DebugActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugAction) || t == typeof(DebugAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "applyTestScenarioAction":
                    return DebugAction.ApplyTestScenarioAction;
                case "drawCard":
                    return DebugAction.DrawCard;
                case "performSomeAction":
                    return DebugAction.PerformSomeAction;
                case "triggerEnemyJudgment":
                    return DebugAction.TriggerEnemyJudgment;
                case "triggerUserJudgment":
                    return DebugAction.TriggerUserJudgment;
            }
            throw new Exception("Cannot unmarshal type DebugAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DebugAction)untypedValue;
            switch (value)
            {
                case DebugAction.ApplyTestScenarioAction:
                    serializer.Serialize(writer, "applyTestScenarioAction");
                    return;
                case DebugAction.DrawCard:
                    serializer.Serialize(writer, "drawCard");
                    return;
                case DebugAction.PerformSomeAction:
                    serializer.Serialize(writer, "performSomeAction");
                    return;
                case DebugAction.TriggerEnemyJudgment:
                    serializer.Serialize(writer, "triggerEnemyJudgment");
                    return;
                case DebugAction.TriggerUserJudgment:
                    serializer.Serialize(writer, "triggerUserJudgment");
                    return;
            }
            throw new Exception("Cannot marshal type DebugAction");
        }

        public static readonly DebugActionConverter Singleton = new DebugActionConverter();
    }

    internal class FlexAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexAlign) || t == typeof(FlexAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "auto":
                    return FlexAlign.Auto;
                case "center":
                    return FlexAlign.Center;
                case "flexEnd":
                    return FlexAlign.FlexEnd;
                case "flexStart":
                    return FlexAlign.FlexStart;
                case "stretch":
                    return FlexAlign.Stretch;
            }
            throw new Exception("Cannot unmarshal type FlexAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexAlign)untypedValue;
            switch (value)
            {
                case FlexAlign.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case FlexAlign.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case FlexAlign.FlexEnd:
                    serializer.Serialize(writer, "flexEnd");
                    return;
                case FlexAlign.FlexStart:
                    serializer.Serialize(writer, "flexStart");
                    return;
                case FlexAlign.Stretch:
                    serializer.Serialize(writer, "stretch");
                    return;
            }
            throw new Exception("Cannot marshal type FlexAlign");
        }

        public static readonly FlexAlignConverter Singleton = new FlexAlignConverter();
    }

    internal class DimensionUnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DimensionUnit) || t == typeof(DimensionUnit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "percentage":
                    return DimensionUnit.Percentage;
                case "pixels":
                    return DimensionUnit.Pixels;
                case "safeAreaBottom":
                    return DimensionUnit.SafeAreaBottom;
                case "safeAreaLeft":
                    return DimensionUnit.SafeAreaLeft;
                case "safeAreaRight":
                    return DimensionUnit.SafeAreaRight;
                case "safeAreaTop":
                    return DimensionUnit.SafeAreaTop;
                case "viewportHeight":
                    return DimensionUnit.ViewportHeight;
                case "viewportWidth":
                    return DimensionUnit.ViewportWidth;
            }
            throw new Exception("Cannot unmarshal type DimensionUnit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DimensionUnit)untypedValue;
            switch (value)
            {
                case DimensionUnit.Percentage:
                    serializer.Serialize(writer, "percentage");
                    return;
                case DimensionUnit.Pixels:
                    serializer.Serialize(writer, "pixels");
                    return;
                case DimensionUnit.SafeAreaBottom:
                    serializer.Serialize(writer, "safeAreaBottom");
                    return;
                case DimensionUnit.SafeAreaLeft:
                    serializer.Serialize(writer, "safeAreaLeft");
                    return;
                case DimensionUnit.SafeAreaRight:
                    serializer.Serialize(writer, "safeAreaRight");
                    return;
                case DimensionUnit.SafeAreaTop:
                    serializer.Serialize(writer, "safeAreaTop");
                    return;
                case DimensionUnit.ViewportHeight:
                    serializer.Serialize(writer, "viewportHeight");
                    return;
                case DimensionUnit.ViewportWidth:
                    serializer.Serialize(writer, "viewportWidth");
                    return;
            }
            throw new Exception("Cannot marshal type DimensionUnit");
        }

        public static readonly DimensionUnitConverter Singleton = new DimensionUnitConverter();
    }

    internal class FlexDisplayStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDisplayStyle) || t == typeof(FlexDisplayStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "flex":
                    return FlexDisplayStyle.Flex;
                case "none":
                    return FlexDisplayStyle.None;
            }
            throw new Exception("Cannot unmarshal type FlexDisplayStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDisplayStyle)untypedValue;
            switch (value)
            {
                case FlexDisplayStyle.Flex:
                    serializer.Serialize(writer, "flex");
                    return;
                case FlexDisplayStyle.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDisplayStyle");
        }

        public static readonly FlexDisplayStyleConverter Singleton = new FlexDisplayStyleConverter();
    }

    internal class FlexDirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDirection) || t == typeof(FlexDirection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "column":
                    return FlexDirection.Column;
                case "columnReverse":
                    return FlexDirection.ColumnReverse;
                case "row":
                    return FlexDirection.Row;
                case "rowReverse":
                    return FlexDirection.RowReverse;
            }
            throw new Exception("Cannot unmarshal type FlexDirection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDirection)untypedValue;
            switch (value)
            {
                case FlexDirection.Column:
                    serializer.Serialize(writer, "column");
                    return;
                case FlexDirection.ColumnReverse:
                    serializer.Serialize(writer, "columnReverse");
                    return;
                case FlexDirection.Row:
                    serializer.Serialize(writer, "row");
                    return;
                case FlexDirection.RowReverse:
                    serializer.Serialize(writer, "rowReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDirection");
        }

        public static readonly FlexDirectionConverter Singleton = new FlexDirectionConverter();
    }

    internal class FontStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontStyle) || t == typeof(FontStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bold":
                    return FontStyle.Bold;
                case "boldAndItalic":
                    return FontStyle.BoldAndItalic;
                case "italic":
                    return FontStyle.Italic;
                case "normal":
                    return FontStyle.Normal;
            }
            throw new Exception("Cannot unmarshal type FontStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontStyle)untypedValue;
            switch (value)
            {
                case FontStyle.Bold:
                    serializer.Serialize(writer, "bold");
                    return;
                case FontStyle.BoldAndItalic:
                    serializer.Serialize(writer, "boldAndItalic");
                    return;
                case FontStyle.Italic:
                    serializer.Serialize(writer, "italic");
                    return;
                case FontStyle.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontStyle");
        }

        public static readonly FontStyleConverter Singleton = new FontStyleConverter();
    }

    internal class FlexJustifyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexJustify) || t == typeof(FlexJustify?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return FlexJustify.Center;
                case "flexEnd":
                    return FlexJustify.FlexEnd;
                case "flexStart":
                    return FlexJustify.FlexStart;
                case "spaceAround":
                    return FlexJustify.SpaceAround;
                case "spaceBetween":
                    return FlexJustify.SpaceBetween;
            }
            throw new Exception("Cannot unmarshal type FlexJustify");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexJustify)untypedValue;
            switch (value)
            {
                case FlexJustify.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case FlexJustify.FlexEnd:
                    serializer.Serialize(writer, "flexEnd");
                    return;
                case FlexJustify.FlexStart:
                    serializer.Serialize(writer, "flexStart");
                    return;
                case FlexJustify.SpaceAround:
                    serializer.Serialize(writer, "spaceAround");
                    return;
                case FlexJustify.SpaceBetween:
                    serializer.Serialize(writer, "spaceBetween");
                    return;
            }
            throw new Exception("Cannot marshal type FlexJustify");
        }

        public static readonly FlexJustifyConverter Singleton = new FlexJustifyConverter();
    }

    internal class FlexVisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexVisibility) || t == typeof(FlexVisibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hidden":
                    return FlexVisibility.Hidden;
                case "visible":
                    return FlexVisibility.Visible;
            }
            throw new Exception("Cannot unmarshal type FlexVisibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexVisibility)untypedValue;
            switch (value)
            {
                case FlexVisibility.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
                case FlexVisibility.Visible:
                    serializer.Serialize(writer, "visible");
                    return;
            }
            throw new Exception("Cannot marshal type FlexVisibility");
        }

        public static readonly FlexVisibilityConverter Singleton = new FlexVisibilityConverter();
    }

    internal class OverflowClipBoxConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OverflowClipBox) || t == typeof(OverflowClipBox?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "contentBox":
                    return OverflowClipBox.ContentBox;
                case "paddingBox":
                    return OverflowClipBox.PaddingBox;
            }
            throw new Exception("Cannot unmarshal type OverflowClipBox");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OverflowClipBox)untypedValue;
            switch (value)
            {
                case OverflowClipBox.ContentBox:
                    serializer.Serialize(writer, "contentBox");
                    return;
                case OverflowClipBox.PaddingBox:
                    serializer.Serialize(writer, "paddingBox");
                    return;
            }
            throw new Exception("Cannot marshal type OverflowClipBox");
        }

        public static readonly OverflowClipBoxConverter Singleton = new OverflowClipBoxConverter();
    }

    internal class FlexPickingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexPickingMode) || t == typeof(FlexPickingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ignore":
                    return FlexPickingMode.Ignore;
                case "position":
                    return FlexPickingMode.Position;
            }
            throw new Exception("Cannot unmarshal type FlexPickingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexPickingMode)untypedValue;
            switch (value)
            {
                case FlexPickingMode.Ignore:
                    serializer.Serialize(writer, "ignore");
                    return;
                case FlexPickingMode.Position:
                    serializer.Serialize(writer, "position");
                    return;
            }
            throw new Exception("Cannot marshal type FlexPickingMode");
        }

        public static readonly FlexPickingModeConverter Singleton = new FlexPickingModeConverter();
    }

    internal class FlexPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexPosition) || t == typeof(FlexPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "absolute":
                    return FlexPosition.Absolute;
                case "relative":
                    return FlexPosition.Relative;
            }
            throw new Exception("Cannot unmarshal type FlexPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexPosition)untypedValue;
            switch (value)
            {
                case FlexPosition.Absolute:
                    serializer.Serialize(writer, "absolute");
                    return;
                case FlexPosition.Relative:
                    serializer.Serialize(writer, "relative");
                    return;
            }
            throw new Exception("Cannot marshal type FlexPosition");
        }

        public static readonly FlexPositionConverter Singleton = new FlexPositionConverter();
    }

    internal class TextAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextAlign) || t == typeof(TextAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "lowerCenter":
                    return TextAlign.LowerCenter;
                case "lowerLeft":
                    return TextAlign.LowerLeft;
                case "lowerRight":
                    return TextAlign.LowerRight;
                case "middleCenter":
                    return TextAlign.MiddleCenter;
                case "middleLeft":
                    return TextAlign.MiddleLeft;
                case "middleRight":
                    return TextAlign.MiddleRight;
                case "upperCenter":
                    return TextAlign.UpperCenter;
                case "upperLeft":
                    return TextAlign.UpperLeft;
                case "upperRight":
                    return TextAlign.UpperRight;
            }
            throw new Exception("Cannot unmarshal type TextAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextAlign)untypedValue;
            switch (value)
            {
                case TextAlign.LowerCenter:
                    serializer.Serialize(writer, "lowerCenter");
                    return;
                case TextAlign.LowerLeft:
                    serializer.Serialize(writer, "lowerLeft");
                    return;
                case TextAlign.LowerRight:
                    serializer.Serialize(writer, "lowerRight");
                    return;
                case TextAlign.MiddleCenter:
                    serializer.Serialize(writer, "middleCenter");
                    return;
                case TextAlign.MiddleLeft:
                    serializer.Serialize(writer, "middleLeft");
                    return;
                case TextAlign.MiddleRight:
                    serializer.Serialize(writer, "middleRight");
                    return;
                case TextAlign.UpperCenter:
                    serializer.Serialize(writer, "upperCenter");
                    return;
                case TextAlign.UpperLeft:
                    serializer.Serialize(writer, "upperLeft");
                    return;
                case TextAlign.UpperRight:
                    serializer.Serialize(writer, "upperRight");
                    return;
            }
            throw new Exception("Cannot marshal type TextAlign");
        }

        public static readonly TextAlignConverter Singleton = new TextAlignConverter();
    }

    internal class TextOverflowConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflow) || t == typeof(TextOverflow?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "clip":
                    return TextOverflow.Clip;
                case "ellipsis":
                    return TextOverflow.Ellipsis;
            }
            throw new Exception("Cannot unmarshal type TextOverflow");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflow)untypedValue;
            switch (value)
            {
                case TextOverflow.Clip:
                    serializer.Serialize(writer, "clip");
                    return;
                case TextOverflow.Ellipsis:
                    serializer.Serialize(writer, "ellipsis");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflow");
        }

        public static readonly TextOverflowConverter Singleton = new TextOverflowConverter();
    }

    internal class TextOverflowPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflowPosition) || t == typeof(TextOverflowPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "end":
                    return TextOverflowPosition.End;
                case "middle":
                    return TextOverflowPosition.Middle;
                case "start":
                    return TextOverflowPosition.Start;
            }
            throw new Exception("Cannot unmarshal type TextOverflowPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflowPosition)untypedValue;
            switch (value)
            {
                case TextOverflowPosition.End:
                    serializer.Serialize(writer, "end");
                    return;
                case TextOverflowPosition.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case TextOverflowPosition.Start:
                    serializer.Serialize(writer, "start");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflowPosition");
        }

        public static readonly TextOverflowPositionConverter Singleton = new TextOverflowPositionConverter();
    }

    internal class EasingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EasingMode) || t == typeof(EasingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ease":
                    return EasingMode.Ease;
                case "easeIn":
                    return EasingMode.EaseIn;
                case "easeInBack":
                    return EasingMode.EaseInBack;
                case "easeInBounce":
                    return EasingMode.EaseInBounce;
                case "easeInCirc":
                    return EasingMode.EaseInCirc;
                case "easeInCubic":
                    return EasingMode.EaseInCubic;
                case "easeInElastic":
                    return EasingMode.EaseInElastic;
                case "easeInOut":
                    return EasingMode.EaseInOut;
                case "easeInOutBack":
                    return EasingMode.EaseInOutBack;
                case "easeInOutBounce":
                    return EasingMode.EaseInOutBounce;
                case "easeInOutCirc":
                    return EasingMode.EaseInOutCirc;
                case "easeInOutCubic":
                    return EasingMode.EaseInOutCubic;
                case "easeInOutElastic":
                    return EasingMode.EaseInOutElastic;
                case "easeInOutSine":
                    return EasingMode.EaseInOutSine;
                case "easeInSine":
                    return EasingMode.EaseInSine;
                case "easeOut":
                    return EasingMode.EaseOut;
                case "easeOutBack":
                    return EasingMode.EaseOutBack;
                case "easeOutBounce":
                    return EasingMode.EaseOutBounce;
                case "easeOutCirc":
                    return EasingMode.EaseOutCirc;
                case "easeOutCubic":
                    return EasingMode.EaseOutCubic;
                case "easeOutElastic":
                    return EasingMode.EaseOutElastic;
                case "easeOutSine":
                    return EasingMode.EaseOutSine;
                case "linear":
                    return EasingMode.Linear;
            }
            throw new Exception("Cannot unmarshal type EasingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EasingMode)untypedValue;
            switch (value)
            {
                case EasingMode.Ease:
                    serializer.Serialize(writer, "ease");
                    return;
                case EasingMode.EaseIn:
                    serializer.Serialize(writer, "easeIn");
                    return;
                case EasingMode.EaseInBack:
                    serializer.Serialize(writer, "easeInBack");
                    return;
                case EasingMode.EaseInBounce:
                    serializer.Serialize(writer, "easeInBounce");
                    return;
                case EasingMode.EaseInCirc:
                    serializer.Serialize(writer, "easeInCirc");
                    return;
                case EasingMode.EaseInCubic:
                    serializer.Serialize(writer, "easeInCubic");
                    return;
                case EasingMode.EaseInElastic:
                    serializer.Serialize(writer, "easeInElastic");
                    return;
                case EasingMode.EaseInOut:
                    serializer.Serialize(writer, "easeInOut");
                    return;
                case EasingMode.EaseInOutBack:
                    serializer.Serialize(writer, "easeInOutBack");
                    return;
                case EasingMode.EaseInOutBounce:
                    serializer.Serialize(writer, "easeInOutBounce");
                    return;
                case EasingMode.EaseInOutCirc:
                    serializer.Serialize(writer, "easeInOutCirc");
                    return;
                case EasingMode.EaseInOutCubic:
                    serializer.Serialize(writer, "easeInOutCubic");
                    return;
                case EasingMode.EaseInOutElastic:
                    serializer.Serialize(writer, "easeInOutElastic");
                    return;
                case EasingMode.EaseInOutSine:
                    serializer.Serialize(writer, "easeInOutSine");
                    return;
                case EasingMode.EaseInSine:
                    serializer.Serialize(writer, "easeInSine");
                    return;
                case EasingMode.EaseOut:
                    serializer.Serialize(writer, "easeOut");
                    return;
                case EasingMode.EaseOutBack:
                    serializer.Serialize(writer, "easeOutBack");
                    return;
                case EasingMode.EaseOutBounce:
                    serializer.Serialize(writer, "easeOutBounce");
                    return;
                case EasingMode.EaseOutCirc:
                    serializer.Serialize(writer, "easeOutCirc");
                    return;
                case EasingMode.EaseOutCubic:
                    serializer.Serialize(writer, "easeOutCubic");
                    return;
                case EasingMode.EaseOutElastic:
                    serializer.Serialize(writer, "easeOutElastic");
                    return;
                case EasingMode.EaseOutSine:
                    serializer.Serialize(writer, "easeOutSine");
                    return;
                case EasingMode.Linear:
                    serializer.Serialize(writer, "linear");
                    return;
            }
            throw new Exception("Cannot marshal type EasingMode");
        }

        public static readonly EasingModeConverter Singleton = new EasingModeConverter();
    }

    internal class WhiteSpaceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WhiteSpace) || t == typeof(WhiteSpace?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "noWrap":
                    return WhiteSpace.NoWrap;
                case "normal":
                    return WhiteSpace.Normal;
            }
            throw new Exception("Cannot unmarshal type WhiteSpace");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WhiteSpace)untypedValue;
            switch (value)
            {
                case WhiteSpace.NoWrap:
                    serializer.Serialize(writer, "noWrap");
                    return;
                case WhiteSpace.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type WhiteSpace");
        }

        public static readonly WhiteSpaceConverter Singleton = new WhiteSpaceConverter();
    }

    internal class FlexWrapConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexWrap) || t == typeof(FlexWrap?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "noWrap":
                    return FlexWrap.NoWrap;
                case "wrap":
                    return FlexWrap.Wrap;
                case "wrapReverse":
                    return FlexWrap.WrapReverse;
            }
            throw new Exception("Cannot unmarshal type FlexWrap");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexWrap)untypedValue;
            switch (value)
            {
                case FlexWrap.NoWrap:
                    serializer.Serialize(writer, "noWrap");
                    return;
                case FlexWrap.Wrap:
                    serializer.Serialize(writer, "wrap");
                    return;
                case FlexWrap.WrapReverse:
                    serializer.Serialize(writer, "wrapReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexWrap");
        }

        public static readonly FlexWrapConverter Singleton = new FlexWrapConverter();
    }

    internal class ScrollBarVisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScrollBarVisibility) || t == typeof(ScrollBarVisibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alwaysVisible":
                    return ScrollBarVisibility.AlwaysVisible;
                case "auto":
                    return ScrollBarVisibility.Auto;
                case "hidden":
                    return ScrollBarVisibility.Hidden;
            }
            throw new Exception("Cannot unmarshal type ScrollBarVisibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScrollBarVisibility)untypedValue;
            switch (value)
            {
                case ScrollBarVisibility.AlwaysVisible:
                    serializer.Serialize(writer, "alwaysVisible");
                    return;
                case ScrollBarVisibility.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case ScrollBarVisibility.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
            }
            throw new Exception("Cannot marshal type ScrollBarVisibility");
        }

        public static readonly ScrollBarVisibilityConverter Singleton = new ScrollBarVisibilityConverter();
    }

    internal class TouchScrollBehaviorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TouchScrollBehavior) || t == typeof(TouchScrollBehavior?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "clamped":
                    return TouchScrollBehavior.Clamped;
                case "elastic":
                    return TouchScrollBehavior.Elastic;
                case "unrestricted":
                    return TouchScrollBehavior.Unrestricted;
            }
            throw new Exception("Cannot unmarshal type TouchScrollBehavior");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TouchScrollBehavior)untypedValue;
            switch (value)
            {
                case TouchScrollBehavior.Clamped:
                    serializer.Serialize(writer, "clamped");
                    return;
                case TouchScrollBehavior.Elastic:
                    serializer.Serialize(writer, "elastic");
                    return;
                case TouchScrollBehavior.Unrestricted:
                    serializer.Serialize(writer, "unrestricted");
                    return;
            }
            throw new Exception("Cannot marshal type TouchScrollBehavior");
        }

        public static readonly TouchScrollBehaviorConverter Singleton = new TouchScrollBehaviorConverter();
    }

    internal class SliderDirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SliderDirection) || t == typeof(SliderDirection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "horizontal":
                    return SliderDirection.Horizontal;
                case "vertical":
                    return SliderDirection.Vertical;
            }
            throw new Exception("Cannot unmarshal type SliderDirection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SliderDirection)untypedValue;
            switch (value)
            {
                case SliderDirection.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case SliderDirection.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type SliderDirection");
        }

        public static readonly SliderDirectionConverter Singleton = new SliderDirectionConverter();
    }
}
