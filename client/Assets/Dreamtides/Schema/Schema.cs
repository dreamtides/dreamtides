// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Dreamtides.Schema;
//
//    var schemaTypes = SchemaTypes.FromJson(jsonString);

namespace Dreamtides.Schema
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class SchemaTypes
    {
        [JsonProperty("clientLogRequest", Required = Required.Always)]
        public ClientLogRequest ClientLogRequest { get; set; }

        [JsonProperty("clientLogResponse", Required = Required.Always)]
        public ClientLogResponse ClientLogResponse { get; set; }

        [JsonProperty("connectRequest", Required = Required.Always)]
        public ConnectRequest ConnectRequest { get; set; }

        [JsonProperty("connectResponse", Required = Required.Always)]
        public ConnectResponse ConnectResponse { get; set; }

        [JsonProperty("performActionRequest", Required = Required.Always)]
        public PerformActionRequest PerformActionRequest { get; set; }

        [JsonProperty("performActionResponse", Required = Required.Always)]
        public PerformActionResponse PerformActionResponse { get; set; }

        [JsonProperty("pollRequest", Required = Required.Always)]
        public PollRequest PollRequest { get; set; }

        [JsonProperty("pollResponse", Required = Required.Always)]
        public PollResponse PollResponse { get; set; }
    }

    public partial class ClientLogRequest
    {
        [JsonProperty("entry", Required = Required.Always)]
        public Entry Entry { get; set; }
    }

    public partial class EventSpan
    {
        [JsonProperty("entries", Required = Required.Always)]
        public List<Entry> Entries { get; set; }

        [JsonProperty("name", Required = Required.Always)]
        public Name Name { get; set; }
    }

    public partial class Entry
    {
        [JsonProperty("event", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Event Event { get; set; }

        [JsonProperty("eventSpan", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public EventSpan EventSpan { get; set; }
    }

    public partial class Event
    {
        [JsonProperty("log_type", Required = Required.Always)]
        public LogType LogType { get; set; }

        [JsonProperty("message", Required = Required.Always)]
        public string Message { get; set; }
    }

    public partial class ClientLogResponse
    {
        [JsonProperty("success", Required = Required.Always)]
        public bool Success { get; set; }
    }

    public partial class ConnectRequest
    {
        /// <summary>
        /// If specified, the battle will be created with the given debug
        /// configuration.
        /// </summary>
        [JsonProperty("debugConfiguration")]
        public DebugConfigurationClass DebugConfiguration { get; set; }

        /// <summary>
        /// Display properties from the client (screen dimensions, mobile device
        /// flag, etc.)
        /// </summary>
        [JsonProperty("displayProperties")]
        public DisplayPropertiesClass DisplayProperties { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        /// <summary>
        /// Contains the path to a persistent data directory.
        ///
        /// When you build the Unity application, a GUID is generated that is based
        /// on the Bundle Identifier. This GUID is part of persistentDataPath. If
        /// you keep the same Bundle Identifier in future versions, the application
        /// keeps accessing the same location on every update.
        /// </summary>
        [JsonProperty("persistentDataPath", Required = Required.Always)]
        public string PersistentDataPath { get; set; }

        [JsonProperty("testScenario")]
        public string TestScenario { get; set; }

        /// <summary>
        /// If specified, treats this as a multiplayer game using the save file
        /// provided in this ID and adds this user as a player in the battle.
        /// </summary>
        [JsonProperty("vsOpponent")]
        public Guid? VsOpponent { get; set; }
    }

    public partial class DebugConfigurationClass
    {
        /// <summary>
        /// If specified, the enemy will be this player type.
        /// </summary>
        [JsonProperty("enemy")]
        public EnemyClass Enemy { get; set; }

        /// <summary>
        /// If specified, the battle will be seeded with the given value. Otherwise
        /// a random seed will be used.
        /// </summary>
        [JsonProperty("seed")]
        public long? Seed { get; set; }
    }

    public partial class EnemyClass
    {
        [JsonProperty("user", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Guid? User { get; set; }

        [JsonProperty("agent", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Agent? Agent { get; set; }
    }

    public partial class AgentClass
    {
        [JsonProperty("monteCarlo", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? MonteCarlo { get; set; }

        [JsonProperty("monteCarloSingleThreaded", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? MonteCarloSingleThreaded { get; set; }
    }

    public partial class DisplayPropertiesClass
    {
        [JsonProperty("isMobileDevice", Required = Required.Always)]
        public bool IsMobileDevice { get; set; }

        [JsonProperty("screenHeight", Required = Required.Always)]
        public long ScreenHeight { get; set; }

        [JsonProperty("screenWidth", Required = Required.Always)]
        public long ScreenWidth { get; set; }
    }

    public partial class Metadata
    {
        /// <summary>
        /// ID of the current battle.
        /// </summary>
        [JsonProperty("battleId")]
        public Guid? BattleId { get; set; }

        /// <summary>
        /// If specified, the request is part of an integration test with the given
        /// ID. State will not be persisted.
        /// </summary>
        [JsonProperty("integrationTestId")]
        public Guid? IntegrationTestId { get; set; }

        /// <summary>
        /// Identifies the request from the client.
        /// </summary>
        [JsonProperty("requestId")]
        public Guid? RequestId { get; set; }

        /// <summary>
        /// ID of the user making the request.
        /// </summary>
        [JsonProperty("userId", Required = Required.Always)]
        public Guid UserId { get; set; }
    }

    public partial class ConnectResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public Commands Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        [JsonProperty("responseVersion", Required = Required.Always)]
        public Guid ResponseVersion { get; set; }
    }

    /// <summary>
    /// A list of [ParallelCommandGroup]s to execute sequentially.
    /// </summary>
    public partial class Commands
    {
        [JsonProperty("groups", Required = Required.Always)]
        public List<GroupElement> Groups { get; set; }
    }

    /// <summary>
    /// A set of [Command]s to execute simultaneously.
    /// </summary>
    public partial class GroupElement
    {
        [JsonProperty("commands", Required = Required.Always)]
        public List<CommandElement> Commands { get; set; }
    }

    /// <summary>
    /// Represents an animated update to the visual state of the game.
    /// </summary>
    public partial class CommandElement
    {
        [JsonProperty("updateBattle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public UpdateBattle UpdateBattle { get; set; }

        [JsonProperty("wait", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public WaitElement Wait { get; set; }

        [JsonProperty("fireProjectile", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FireProjectile FireProjectile { get; set; }

        [JsonProperty("dissolveCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DissolveCard DissolveCard { get; set; }

        [JsonProperty("displayGameMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayGameMessage? DisplayGameMessage { get; set; }

        [JsonProperty("displayEffect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEffect DisplayEffect { get; set; }

        [JsonProperty("playAudioClip", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PlayAudioClip PlayAudioClip { get; set; }

        [JsonProperty("drawUserCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawUserCards DrawUserCards { get; set; }

        [JsonProperty("displayJudgment", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayJudgment DisplayJudgment { get; set; }

        [JsonProperty("displayDreamwellActivation", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayDreamwellActivation DisplayDreamwellActivation { get; set; }

        [JsonProperty("displayEnemyMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEnemyMessage DisplayEnemyMessage { get; set; }

        [JsonProperty("toggleThinkingIndicator", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ToggleThinkingIndicator ToggleThinkingIndicator { get; set; }

        [JsonProperty("playStudioAnimation", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PlayStudioAnimation PlayStudioAnimation { get; set; }
    }

    public partial class DisplayDreamwellActivation
    {
        /// <summary>
        /// The card to display an activation for. This card will be moved from its
        /// current position (assumed to be the 'Dreamwell' position) to the
        /// DreamwellActivation position, and an update to the player's produced
        /// energy value will be displayed.
        ///
        /// If there are triggered events as a result of this activation, the card
        /// should be kept in the DreamwellActivation position for the next
        /// update. Otherwise it's typical to return the card to the Dreamwell
        /// position.
        /// </summary>
        [JsonProperty("cardId", Required = Required.Always)]
        public string CardId { get; set; }

        /// <summary>
        /// New energy available to this player, if it has changed.
        /// </summary>
        [JsonProperty("newEnergy")]
        public long? NewEnergy { get; set; }

        /// <summary>
        /// New energy produced by this player at the start of the turn, if it has
        /// changed.
        /// </summary>
        [JsonProperty("newProducedEnergy")]
        public long? NewProducedEnergy { get; set; }

        /// <summary>
        /// The player to display the dreamwell activation for.
        /// </summary>
        [JsonProperty("player", Required = Required.Always)]
        public Deck Player { get; set; }
    }

    public partial class DisplayEffect
    {
        /// <summary>
        /// How long to wait before continuing with animations.
        /// </summary>
        [JsonProperty("duration", Required = Required.Always)]
        public WaitElement Duration { get; set; }

        /// <summary>
        /// The effect to display.
        /// </summary>
        [JsonProperty("effect", Required = Required.Always)]
        public EffectClass Effect { get; set; }

        /// <summary>
        /// Local scale to apply to this effect
        /// </summary>
        [JsonProperty("scale", Required = Required.Always)]
        public Amount Scale { get; set; }

        /// <summary>
        /// Sound to play along with effect
        /// </summary>
        [JsonProperty("sound")]
        public SoundClass Sound { get; set; }

        /// <summary>
        /// The target to display the effect on.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public Source Target { get; set; }
    }

    /// <summary>
    /// How long to wait before continuing with animations.
    ///
    /// How long to pause before continuing with animations.
    ///
    /// Time to display each card before moving it to hand.
    ///
    /// Should be less than stagger_interval for best results.
    ///
    /// Time to wait between drawing subsequent cards.
    /// </summary>
    public partial class WaitElement
    {
        [JsonProperty("millisecondsValue", Required = Required.Always)]
        public long MillisecondsValue { get; set; }
    }

    /// <summary>
    /// The effect to display.
    /// </summary>
    public partial class EffectClass
    {
        [JsonProperty("effect", Required = Required.Always)]
        public string Effect { get; set; }
    }

    /// <summary>
    /// Local scale to apply to this effect
    /// </summary>
    public partial class Amount
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    /// <summary>
    /// Sound to play
    /// </summary>
    public partial class SoundClass
    {
        [JsonProperty("audioClip", Required = Required.Always)]
        public string AudioClip { get; set; }
    }

    /// <summary>
    /// The target to display the effect on.
    /// </summary>
    public partial class Source
    {
        [JsonProperty("cardId", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string CardId { get; set; }

        [JsonProperty("deck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? Deck { get; set; }

        [JsonProperty("void", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? Void { get; set; }

        [JsonProperty("avatar", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? Avatar { get; set; }
    }

    public partial class DisplayEnemyMessage
    {
        [JsonProperty("message", Required = Required.Always)]
        public string Message { get; set; }

        [JsonProperty("showDuration", Required = Required.Always)]
        public WaitElement ShowDuration { get; set; }
    }

    public partial class DisplayJudgment
    {
        /// <summary>
        /// The new score for the player, if it has changed.
        /// </summary>
        [JsonProperty("newScore")]
        public long? NewScore { get; set; }

        /// <summary>
        /// The player to display the judgment animation for.
        /// </summary>
        [JsonProperty("player", Required = Required.Always)]
        public Deck Player { get; set; }
    }

    public partial class DissolveCard
    {
        /// <summary>
        /// The color to use for the dissolve effect.
        /// </summary>
        [JsonProperty("color", Required = Required.Always)]
        public ColorClass Color { get; set; }

        /// <summary>
        /// The speed multiplier of the dissolve effect. Defaults to 1.
        /// </summary>
        [JsonProperty("dissolveSpeed")]
        public double? DissolveSpeed { get; set; }

        /// <summary>
        /// The material to use for the dissolve effect.
        /// </summary>
        [JsonProperty("material", Required = Required.Always)]
        public Material Material { get; set; }

        /// <summary>
        /// If true, dissolve will be played backwards to "create" the card.
        /// </summary>
        [JsonProperty("reverse", Required = Required.Always)]
        public bool Reverse { get; set; }

        /// <summary>
        /// Sound to play
        /// </summary>
        [JsonProperty("sound")]
        public SoundClass Sound { get; set; }

        /// <summary>
        /// The card to dissolve.
        ///
        /// Once a card is dissolved, it will be invisible until a reverse dissolve
        /// is applied to it.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public string Target { get; set; }
    }

    /// <summary>
    /// Represents a color with the given RGBA values represented as floats in the
    /// 0-1 range.
    ///
    /// The color to use for the dissolve effect.
    /// </summary>
    public partial class ColorClass
    {
        [JsonProperty("alpha", Required = Required.Always)]
        public double Alpha { get; set; }

        [JsonProperty("blue", Required = Required.Always)]
        public double Blue { get; set; }

        [JsonProperty("green", Required = Required.Always)]
        public double Green { get; set; }

        [JsonProperty("red", Required = Required.Always)]
        public double Red { get; set; }
    }

    /// <summary>
    /// The material to use for the dissolve effect.
    /// </summary>
    public partial class Material
    {
        [JsonProperty("material", Required = Required.Always)]
        public string MaterialMaterial { get; set; }
    }

    public partial class DrawUserCards
    {
        /// <summary>
        /// Cards to draw. Must already be present in user deck.
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<DrawUserCardsCard> Cards { get; set; }

        /// <summary>
        /// Time to display each card before moving it to hand.
        ///
        /// Should be less than stagger_interval for best results.
        /// </summary>
        [JsonProperty("pauseDuration", Required = Required.Always)]
        public WaitElement PauseDuration { get; set; }

        /// <summary>
        /// Time to wait between drawing subsequent cards.
        /// </summary>
        [JsonProperty("staggerInterval", Required = Required.Always)]
        public WaitElement StaggerInterval { get; set; }
    }

    /// <summary>
    /// Represents the visual state of a card or ability in a game
    /// </summary>
    public partial class DrawUserCardsCard
    {
        /// <summary>
        /// Face up/face down state for this card
        /// </summary>
        [JsonProperty("cardFacing", Required = Required.Always)]
        public CardFacing CardFacing { get; set; }

        /// <summary>
        /// Optionally, a position at which to create this card.
        ///
        /// If this card does not already exist, it will be created at this position
        /// before being animated to [Self::position].
        /// </summary>
        [JsonProperty("createPosition")]
        public JumpToPositionClass CreatePosition { get; set; }

        /// <summary>
        /// Optionally, a position at which to destroy this card.
        ///
        /// If provided, the card will be animated to this position before being
        /// destroyed.
        /// </summary>
        [JsonProperty("destroyPosition")]
        public JumpToPositionClass DestroyPosition { get; set; }

        /// <summary>
        /// Identifier for this card
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public string Id { get; set; }

        /// <summary>
        /// Position of this card in the UI
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public JumpToPositionClass Position { get; set; }

        /// <summary>
        /// Represents the general category of card being displayed.
        /// </summary>
        [JsonProperty("prefab", Required = Required.Always)]
        public PrefabEnum Prefab { get; set; }

        /// <summary>
        /// If this card is revealed to the viewer, contains information on the
        /// revealed face of the card.
        /// </summary>
        [JsonProperty("revealed")]
        public RevealedClass Revealed { get; set; }

        /// <summary>
        /// True if this card is in a hidden zone but known to one or more opponents
        /// </summary>
        [JsonProperty("revealedToOpponents", Required = Required.Always)]
        public bool RevealedToOpponents { get; set; }
    }

    /// <summary>
    /// Represents the position of some object in the UI
    ///
    /// Position of this card in the UI
    /// </summary>
    public partial class JumpToPositionClass
    {
        /// <summary>
        /// Position category
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public Position Position { get; set; }

        /// <summary>
        /// Sorting key, determines order within the position
        /// </summary>
        [JsonProperty("sortingKey", Required = Required.Always)]
        public long SortingKey { get; set; }

        /// <summary>
        /// Sub-key, used to break ties in sorting
        /// </summary>
        [JsonProperty("sortingSubKey", Required = Required.Always)]
        public long SortingSubKey { get; set; }
    }

    /// <summary>
    /// Object is on the stack, typically used by cards which were just played.
    ///
    /// There are four types of stacks. By default, cards display at a large
    /// display size, blocking the view of the battlefield. However, if any
    /// cards are present on the stack which target a character on the
    /// battlefield, the cards are displayed at a smaller size in order to
    /// enable viewing & selecting targets appropriately, based on the set of
    /// cards which are current or eligible targets.
    ///
    /// Object is in a player's hand
    ///
    /// Object is on top of a player's deck
    ///
    /// Object is shuffled into a player's deck
    ///
    /// Object is in a player's void
    ///
    /// Object is in this player's banished zone
    ///
    /// Object is on the battlefield
    ///
    /// Object is in a player's status zone
    ///
    /// Object is being displayed in a selector to determine the order of cards,
    /// e.g. when resolving the "forsee" effect.
    ///
    /// Object is in the dreamwell for a player (usually off-screen).
    ///
    /// Object is hidden within a card
    /// </summary>
    public partial class PositionPositionClass
    {
        [JsonProperty("onStack", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public OnStack? OnStack { get; set; }

        [JsonProperty("inHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? InHand { get; set; }

        [JsonProperty("onTopOfDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? OnTopOfDeck { get; set; }

        [JsonProperty("inDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? InDeck { get; set; }

        [JsonProperty("inVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? InVoid { get; set; }

        [JsonProperty("inBanished", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? InBanished { get; set; }

        [JsonProperty("onBattlefield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? OnBattlefield { get; set; }

        [JsonProperty("inPlayerStatus", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? InPlayerStatus { get; set; }

        [JsonProperty("cardOrderSelector", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardOrderSelector? CardOrderSelector { get; set; }

        [JsonProperty("inDreamwell", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Deck? InDreamwell { get; set; }

        [JsonProperty("hiddenWithinCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string HiddenWithinCard { get; set; }
    }

    /// <summary>
    /// Visual state of a revealed card
    /// </summary>
    public partial class RevealedClass
    {
        /// <summary>
        /// Actions available for this card
        /// </summary>
        [JsonProperty("actions", Required = Required.Always)]
        public Actions Actions { get; set; }

        /// <summary>
        /// Type or subtype of this card
        /// </summary>
        [JsonProperty("cardType", Required = Required.Always)]
        public string CardType { get; set; }

        /// <summary>
        /// Cost of this card
        /// </summary>
        [JsonProperty("cost")]
        public long? Cost { get; set; }

        /// <summary>
        /// Special effects to display for this card
        /// </summary>
        [JsonProperty("effects", Required = Required.Always)]
        public Effects Effects { get; set; }

        /// <summary>
        /// Image for this card
        /// </summary>
        [JsonProperty("image", Required = Required.Always)]
        public Image Image { get; set; }

        /// <summary>
        /// Data providing supplemental information about this card on long
        /// press/hover.
        /// </summary>
        [JsonProperty("infoZoomData")]
        public InfoZoomDataClass InfoZoomData { get; set; }

        /// <summary>
        /// True if this card can be played during the opponent's turn
        /// </summary>
        [JsonProperty("isFast", Required = Required.Always)]
        public bool IsFast { get; set; }

        /// <summary>
        /// Name of this card
        /// </summary>
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }

        /// <summary>
        /// Outline color of this card
        /// </summary>
        [JsonProperty("outlineColor")]
        public ColorClass OutlineColor { get; set; }

        /// <summary>
        /// Energy produced by this card
        /// </summary>
        [JsonProperty("produced")]
        public long? Produced { get; set; }

        /// <summary>
        /// Rules text to display for this car
        /// </summary>
        [JsonProperty("rulesText", Required = Required.Always)]
        public string RulesText { get; set; }

        /// <summary>
        /// Spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public long? Spark { get; set; }
    }

    /// <summary>
    /// Actions available for this card
    /// </summary>
    public partial class Actions
    {
        /// <summary>
        /// If this card can currently be played from hand, an action to invoke when
        /// played.
        /// </summary>
        [JsonProperty("canPlay")]
        public CanPlay? CanPlay { get; set; }

        /// <summary>
        /// If this card can currently be dragged within a Card Order Selector, the
        /// card ID to use when selecting order.
        /// </summary>
        [JsonProperty("canSelectOrder")]
        public long? CanSelectOrder { get; set; }

        /// <summary>
        /// Action to perform when this card is clicked.
        /// </summary>
        [JsonProperty("onClick")]
        public CanPlay? OnClick { get; set; }

        /// <summary>
        /// Sound to play when this card is played.
        /// </summary>
        [JsonProperty("onPlaySound")]
        public SoundClass OnPlaySound { get; set; }

        /// <summary>
        /// Preview of the battle state after this card is played.
        /// </summary>
        [JsonProperty("playEffectPreview")]
        public ActiveClass PlayEffectPreview { get; set; }
    }

    public partial class CanPlayClass
    {
        [JsonProperty("debugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("battleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? BattleAction { get; set; }

        [JsonProperty("battleDisplayAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleDisplayAction? BattleDisplayAction { get; set; }

        [JsonProperty("undo", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawCard? Undo { get; set; }
    }

    /// <summary>
    /// Developer action
    ///
    /// Play a card in the user's hand.
    ///
    /// Select a character as a target
    ///
    /// Select a card on the stack as a target
    ///
    /// Select a choice at a given index position in response to a prompt.
    ///
    /// Pick an amount of energy to pay as an additional cost to play a card.
    ///
    /// Sets the position of a card in a card order selector.
    /// </summary>
    public partial class BattleActionClass
    {
        [JsonProperty("debug", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugElement Debug { get; set; }

        [JsonProperty("playCardFromHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? PlayCardFromHand { get; set; }

        [JsonProperty("selectCharacterTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectCharacterTarget { get; set; }

        [JsonProperty("selectStackCardTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectStackCardTarget { get; set; }

        [JsonProperty("selectPromptChoice", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectPromptChoice { get; set; }

        [JsonProperty("selectEnergyAdditionalCost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectEnergyAdditionalCost { get; set; }

        [JsonProperty("selectCardOrder", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SelectCardOrder SelectCardOrder { get; set; }
    }

    /// <summary>
    /// Draw a card
    ///
    /// Set the energy of the player
    ///
    /// Set the points total of the player
    ///
    /// Set the produced energy of the player
    ///
    /// Set the spark bonus of the player
    ///
    /// Add a specific card to hand
    ///
    /// Add a specific card to battlefield
    ///
    /// Add a specific card to void
    ///
    /// Move all cards from hand to deck
    ///
    /// Set the number of cards remaining in a player's deck. All other cards
    /// are moved to the void.
    /// </summary>
    public partial class DebugElement
    {
        [JsonProperty("drawCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawCard? DrawCard { get; set; }

        [JsonProperty("setEnergy", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> SetEnergy { get; set; }

        [JsonProperty("setPoints", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> SetPoints { get; set; }

        [JsonProperty("setProducedEnergy", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> SetProducedEnergy { get; set; }

        [JsonProperty("setSparkBonus", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> SetSparkBonus { get; set; }

        [JsonProperty("addCardToHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> AddCardToHand { get; set; }

        [JsonProperty("addCardToBattlefield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> AddCardToBattlefield { get; set; }

        [JsonProperty("addCardToVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> AddCardToVoid { get; set; }

        [JsonProperty("moveHandToDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawCard? MoveHandToDeck { get; set; }

        [JsonProperty("setCardsRemainingInDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<object> SetCardsRemainingInDeck { get; set; }
    }

    public partial class SelectCardOrder
    {
        [JsonProperty("cardId", Required = Required.Always)]
        public long CardId { get; set; }

        [JsonProperty("position", Required = Required.Always)]
        public long Position { get; set; }

        [JsonProperty("target", Required = Required.Always)]
        public CardOrderSelector Target { get; set; }
    }

    /// <summary>
    /// Sets the selected amount of energy to pay as an additional cost to play
    /// a card.
    ///
    /// Opens a panel based on its address.
    /// </summary>
    public partial class BattleDisplayActionClass
    {
        [JsonProperty("browseCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BrowseCards? BrowseCards { get; set; }

        [JsonProperty("setSelectedEnergyAdditionalCost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SetSelectedEnergyAdditionalCost { get; set; }

        [JsonProperty("openPanel", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public OpenPanel? OpenPanel { get; set; }
    }

    public partial class OpenPanelClass
    {
        [JsonProperty("viewLogs", Required = Required.AllowNull)]
        public string ViewLogs { get; set; }
    }

    public partial class DebugActionClass
    {
        [JsonProperty("setOpponentAgent", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Agent? SetOpponentAgent { get; set; }

        [JsonProperty("applyActionList", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<DebugElement> ApplyActionList { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a battle, shown e.g. in response to a
    /// card being selected to be played.
    /// </summary>
    public partial class ActiveClass
    {
        [JsonProperty("cards", Required = Required.Always)]
        public List<ActiveCard> Cards { get; set; }

        [JsonProperty("enemy", Required = Required.Always)]
        public ActiveEnemy Enemy { get; set; }

        [JsonProperty("previewMessage")]
        public ScreenOverlayElement PreviewMessage { get; set; }

        [JsonProperty("user", Required = Required.Always)]
        public ActiveEnemy User { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a card.
    /// </summary>
    public partial class ActiveCard
    {
        /// <summary>
        /// Icon to display over this card on the battlefield
        /// </summary>
        [JsonProperty("battlefieldIcon")]
        public string BattlefieldIcon { get; set; }

        /// <summary>
        /// Color of the battlefield icon
        /// </summary>
        [JsonProperty("battlefieldIconColor")]
        public ColorClass BattlefieldIconColor { get; set; }

        /// <summary>
        /// Identifier for this card
        /// </summary>
        [JsonProperty("cardId", Required = Required.Always)]
        public string CardId { get; set; }

        /// <summary>
        /// New cost value for this card
        /// </summary>
        [JsonProperty("cost")]
        public long? Cost { get; set; }

        /// <summary>
        /// New spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public long? Spark { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a player
    /// </summary>
    public partial class ActiveEnemy
    {
        /// <summary>
        /// New energy available to this player
        /// </summary>
        [JsonProperty("energy")]
        public long? Energy { get; set; }

        /// <summary>
        /// New energy produced total
        /// </summary>
        [JsonProperty("producedEnergy")]
        public long? ProducedEnergy { get; set; }

        /// <summary>
        /// New score total
        /// </summary>
        [JsonProperty("score")]
        public long? Score { get; set; }

        /// <summary>
        /// New total spark for this player
        /// </summary>
        [JsonProperty("totalSpark")]
        public long? TotalSpark { get; set; }
    }

    public partial class DraggableNode
    {
        [JsonProperty("customDragIndicator")]
        public ScreenOverlayElement CustomDragIndicator { get; set; }

        [JsonProperty("dropTargetIdentifiers", Required = Required.Always)]
        public List<string> DropTargetIdentifiers { get; set; }

        [JsonProperty("hideIndicatorChildren", Required = Required.Always)]
        public List<string> HideIndicatorChildren { get; set; }

        [JsonProperty("horizontalDragStartDistance")]
        public long? HorizontalDragStartDistance { get; set; }

        [JsonProperty("onDragDetected")]
        public CanPlay? OnDragDetected { get; set; }

        [JsonProperty("onDrop")]
        public CanPlay? OnDrop { get; set; }

        [JsonProperty("overTargetIndicator")]
        public ScreenOverlayElement OverTargetIndicator { get; set; }

        [JsonProperty("removeOriginal")]
        public bool? RemoveOriginal { get; set; }
    }

    public partial class NodeTypeClass
    {
        [JsonProperty("text", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Text Text { get; set; }

        [JsonProperty("scrollViewNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ScrollViewNode ScrollViewNode { get; set; }

        [JsonProperty("draggableNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DraggableNode DraggableNode { get; set; }

        [JsonProperty("textFieldNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TextFieldNode TextFieldNode { get; set; }

        [JsonProperty("sliderNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SliderNode SliderNode { get; set; }
    }

    public partial class ScreenOverlayElement
    {
        [JsonProperty("children", Required = Required.Always)]
        public List<ScreenOverlayElement> Children { get; set; }

        [JsonProperty("eventHandlers")]
        public EventHandlersClass EventHandlers { get; set; }

        [JsonProperty("hoverStyle")]
        public HoverStyleClass HoverStyle { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nodeType")]
        public NodeTypeClass NodeType { get; set; }

        /// <summary>
        /// Style to apply to the element when it is first attached to a panel.
        /// </summary>
        [JsonProperty("onAttachStyle")]
        public HoverStyleClass OnAttachStyle { get; set; }

        /// <summary>
        /// How long to keep the `on_attach_style` applied.
        ///
        /// If not specified, the style will be applied indefinitely.
        /// </summary>
        [JsonProperty("onAttachStyleDuration")]
        public WaitElement OnAttachStyleDuration { get; set; }

        [JsonProperty("pressedStyle")]
        public HoverStyleClass PressedStyle { get; set; }

        [JsonProperty("style")]
        public HoverStyleClass Style { get; set; }
    }

    public partial class ScrollViewNode
    {
        [JsonProperty("elasticity")]
        public double? Elasticity { get; set; }

        [JsonProperty("horizontalPageSize")]
        public double? HorizontalPageSize { get; set; }

        [JsonProperty("horizontalScrollBar")]
        public HorizontalScrollBarClass HorizontalScrollBar { get; set; }

        [JsonProperty("horizontalScrollBarVisibility")]
        public HorizontalScrollBarVisibilityEnum? HorizontalScrollBarVisibility { get; set; }

        [JsonProperty("mouseWheelScrollSize")]
        public double? MouseWheelScrollSize { get; set; }

        [JsonProperty("scrollDecelerationRate")]
        public double? ScrollDecelerationRate { get; set; }

        [JsonProperty("touchScrollBehavior")]
        public TouchScrollBehaviorEnum? TouchScrollBehavior { get; set; }

        [JsonProperty("verticalPageSize")]
        public double? VerticalPageSize { get; set; }

        [JsonProperty("verticalScrollBar")]
        public HorizontalScrollBarClass VerticalScrollBar { get; set; }

        [JsonProperty("verticalScrollBarVisibility")]
        public HorizontalScrollBarVisibilityEnum? VerticalScrollBarVisibility { get; set; }
    }

    public partial class HorizontalScrollBarClass
    {
        [JsonProperty("style")]
        public HoverStyleClass Style { get; set; }
    }

    public partial class HoverStyleClass
    {
        [JsonProperty("alignContent")]
        public AlignContentEnum? AlignContent { get; set; }

        [JsonProperty("alignItems")]
        public AlignContentEnum? AlignItems { get; set; }

        [JsonProperty("alignSelf")]
        public AlignContentEnum? AlignSelf { get; set; }

        [JsonProperty("backgroundColor")]
        public ColorClass BackgroundColor { get; set; }

        [JsonProperty("backgroundImage")]
        public SpriteClass BackgroundImage { get; set; }

        [JsonProperty("backgroundImageTintColor")]
        public ColorClass BackgroundImageTintColor { get; set; }

        [JsonProperty("borderColor")]
        public BorderColorClass BorderColor { get; set; }

        [JsonProperty("borderRadius")]
        public BorderRadiusClass BorderRadius { get; set; }

        [JsonProperty("borderWidth")]
        public BorderWidthClass BorderWidth { get; set; }

        [JsonProperty("color")]
        public ColorClass Color { get; set; }

        [JsonProperty("display")]
        public DisplayEnum? Display { get; set; }

        [JsonProperty("flexBasis")]
        public BottomLeft FlexBasis { get; set; }

        [JsonProperty("flexDirection")]
        public FlexDirectionEnum? FlexDirection { get; set; }

        [JsonProperty("flexGrow")]
        public double? FlexGrow { get; set; }

        [JsonProperty("flexShrink")]
        public double? FlexShrink { get; set; }

        [JsonProperty("font")]
        public FontClass Font { get; set; }

        [JsonProperty("fontSize")]
        public BottomLeft FontSize { get; set; }

        [JsonProperty("fontStyle")]
        public FontStyleEnum? FontStyle { get; set; }

        [JsonProperty("height")]
        public BottomLeft Height { get; set; }

        [JsonProperty("imageSlice")]
        public ImageSliceClass ImageSlice { get; set; }

        [JsonProperty("inset")]
        public InsetClass Inset { get; set; }

        [JsonProperty("justifyContent")]
        public JustifyContentEnum? JustifyContent { get; set; }

        [JsonProperty("letterSpacing")]
        public BottomLeft LetterSpacing { get; set; }

        [JsonProperty("margin")]
        public MarginClass Margin { get; set; }

        [JsonProperty("maxHeight")]
        public BottomLeft MaxHeight { get; set; }

        [JsonProperty("maxWidth")]
        public BottomLeft MaxWidth { get; set; }

        [JsonProperty("minHeight")]
        public BottomLeft MinHeight { get; set; }

        [JsonProperty("minWidth")]
        public BottomLeft MinWidth { get; set; }

        [JsonProperty("opacity")]
        public double? Opacity { get; set; }

        [JsonProperty("overflow")]
        public OverflowEnum? Overflow { get; set; }

        [JsonProperty("overflowClipBox")]
        public OverflowClipBoxEnum? OverflowClipBox { get; set; }

        [JsonProperty("padding")]
        public MarginClass Padding { get; set; }

        [JsonProperty("paragraphSpacing")]
        public BottomLeft ParagraphSpacing { get; set; }

        [JsonProperty("pickingMode")]
        public PickingModeEnum? PickingMode { get; set; }

        [JsonProperty("position")]
        public HoverStylePosition? Position { get; set; }

        [JsonProperty("rotate")]
        public RotateClass Rotate { get; set; }

        [JsonProperty("scale")]
        public ScaleClass Scale { get; set; }

        [JsonProperty("textAlign")]
        public TextAlignEnum? TextAlign { get; set; }

        [JsonProperty("textOutlineColor")]
        public ColorClass TextOutlineColor { get; set; }

        [JsonProperty("textOutlineWidth")]
        public double? TextOutlineWidth { get; set; }

        [JsonProperty("textOverflow")]
        public TextOverflowEnum? TextOverflow { get; set; }

        [JsonProperty("textOverflowPosition")]
        public TextOverflowPositionEnum? TextOverflowPosition { get; set; }

        [JsonProperty("textShadow")]
        public TextShadowClass TextShadow { get; set; }

        [JsonProperty("transformOrigin")]
        public TransformOriginClass TransformOrigin { get; set; }

        [JsonProperty("transitionDelays", Required = Required.Always)]
        public List<WaitElement> TransitionDelays { get; set; }

        [JsonProperty("transitionDurations", Required = Required.Always)]
        public List<WaitElement> TransitionDurations { get; set; }

        [JsonProperty("transitionEasingModes", Required = Required.Always)]
        public List<TransitionEasingModeElement> TransitionEasingModes { get; set; }

        [JsonProperty("transitionProperties", Required = Required.Always)]
        public List<string> TransitionProperties { get; set; }

        [JsonProperty("translate")]
        public TransformOriginClass Translate { get; set; }

        [JsonProperty("visibility")]
        public OverflowEnum? Visibility { get; set; }

        [JsonProperty("whiteSpace")]
        public WhiteSpaceEnum? WhiteSpace { get; set; }

        [JsonProperty("width")]
        public BottomLeft Width { get; set; }

        [JsonProperty("wordSpacing")]
        public BottomLeft WordSpacing { get; set; }

        [JsonProperty("wrap")]
        public WrapEnum? Wrap { get; set; }
    }

    public partial class SpriteClass
    {
        [JsonProperty("sprite", Required = Required.Always)]
        public string Sprite { get; set; }
    }

    public partial class BorderColorClass
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public ColorClass Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public ColorClass Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public ColorClass Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public ColorClass Top { get; set; }
    }

    public partial class BorderRadiusClass
    {
        [JsonProperty("bottomLeft", Required = Required.Always)]
        public BottomLeft BottomLeft { get; set; }

        [JsonProperty("bottomRight", Required = Required.Always)]
        public BottomLeft BottomRight { get; set; }

        [JsonProperty("topLeft", Required = Required.Always)]
        public BottomLeft TopLeft { get; set; }

        [JsonProperty("topRight", Required = Required.Always)]
        public BottomLeft TopRight { get; set; }
    }

    public partial class BottomLeft
    {
        [JsonProperty("unit", Required = Required.Always)]
        public Unit Unit { get; set; }

        [JsonProperty("value", Required = Required.Always)]
        public double Value { get; set; }
    }

    public partial class BorderWidthClass
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public double Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public double Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public double Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public double Top { get; set; }
    }

    public partial class FontClass
    {
        [JsonProperty("font", Required = Required.Always)]
        public string Font { get; set; }
    }

    public partial class ImageSliceClass
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public long Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public long Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public long Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public long Top { get; set; }
    }

    public partial class InsetClass
    {
        [JsonProperty("bottom")]
        public BottomLeft Bottom { get; set; }

        [JsonProperty("left")]
        public BottomLeft Left { get; set; }

        [JsonProperty("right")]
        public BottomLeft Right { get; set; }

        [JsonProperty("top")]
        public BottomLeft Top { get; set; }
    }

    public partial class MarginClass
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public BottomLeft Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public BottomLeft Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public BottomLeft Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public BottomLeft Top { get; set; }
    }

    public partial class RotateClass
    {
        [JsonProperty("degrees", Required = Required.Always)]
        public double Degrees { get; set; }
    }

    public partial class ScaleClass
    {
        [JsonProperty("amount", Required = Required.Always)]
        public Amount Amount { get; set; }
    }

    public partial class TextShadowClass
    {
        [JsonProperty("blurRadius", Required = Required.Always)]
        public double BlurRadius { get; set; }

        [JsonProperty("color", Required = Required.Always)]
        public ColorClass Color { get; set; }

        [JsonProperty("offset", Required = Required.Always)]
        public Offset Offset { get; set; }
    }

    public partial class Offset
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }
    }

    public partial class TransformOriginClass
    {
        [JsonProperty("x", Required = Required.Always)]
        public BottomLeft X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public BottomLeft Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    public partial class SliderNode
    {
        [JsonProperty("direction")]
        public DirectionEnum? Direction { get; set; }

        [JsonProperty("dragContainerStyle")]
        public HoverStyleClass DragContainerStyle { get; set; }

        [JsonProperty("draggerBorderStyle")]
        public HoverStyleClass DraggerBorderStyle { get; set; }

        [JsonProperty("draggerStyle")]
        public HoverStyleClass DraggerStyle { get; set; }

        [JsonProperty("highValue")]
        public double? HighValue { get; set; }

        [JsonProperty("initialValue")]
        public double? InitialValue { get; set; }

        [JsonProperty("inverted")]
        public bool? Inverted { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("labelStyle")]
        public HoverStyleClass LabelStyle { get; set; }

        [JsonProperty("lowValue")]
        public double? LowValue { get; set; }

        [JsonProperty("pageSize")]
        public double? PageSize { get; set; }

        [JsonProperty("preferenceKey")]
        public string PreferenceKey { get; set; }

        [JsonProperty("showInputField")]
        public bool? ShowInputField { get; set; }

        [JsonProperty("trackerStyle")]
        public HoverStyleClass TrackerStyle { get; set; }
    }

    public partial class Text
    {
        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    public partial class TextFieldNode
    {
        [JsonProperty("doubleClickSelectsWord")]
        public bool? DoubleClickSelectsWord { get; set; }

        [JsonProperty("globalIdentifier")]
        public string GlobalIdentifier { get; set; }

        [JsonProperty("initialText")]
        public string InitialText { get; set; }

        [JsonProperty("isPasswordField")]
        public bool? IsPasswordField { get; set; }

        [JsonProperty("isReadOnly")]
        public bool? IsReadOnly { get; set; }

        [JsonProperty("maskCharacter")]
        public string MaskCharacter { get; set; }

        [JsonProperty("maxLength")]
        public long? MaxLength { get; set; }

        [JsonProperty("multiline")]
        public bool? Multiline { get; set; }

        [JsonProperty("tripleClickSelectsLine")]
        public bool? TripleClickSelectsLine { get; set; }
    }

    public partial class EventHandlersClass
    {
        [JsonProperty("onClick")]
        public CanPlay? OnClick { get; set; }

        [JsonProperty("onFieldChanged")]
        public CanPlay? OnFieldChanged { get; set; }

        [JsonProperty("onLongPress")]
        public CanPlay? OnLongPress { get; set; }

        [JsonProperty("onMouseDown")]
        public CanPlay? OnMouseDown { get; set; }

        [JsonProperty("onMouseEnter")]
        public CanPlay? OnMouseEnter { get; set; }

        [JsonProperty("onMouseLeave")]
        public CanPlay? OnMouseLeave { get; set; }

        [JsonProperty("onMouseUp")]
        public CanPlay? OnMouseUp { get; set; }
    }

    /// <summary>
    /// Special effects to display for this card
    /// </summary>
    public partial class Effects
    {
        /// <summary>
        /// Projectile to display as a trail behind this card.
        /// </summary>
        [JsonProperty("cardTrail")]
        public ProjectileClass CardTrail { get; set; }
    }

    public partial class ProjectileClass
    {
        [JsonProperty("projectile", Required = Required.Always)]
        public string Projectile { get; set; }
    }

    /// <summary>
    /// Image for this card
    /// </summary>
    public partial class Image
    {
        [JsonProperty("sprite", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SpriteClass Sprite { get; set; }

        [JsonProperty("prefab", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ImagePrefab Prefab { get; set; }
    }

    public partial class ImagePrefab
    {
        [JsonProperty("prefab", Required = Required.Always)]
        public PrefabPrefab Prefab { get; set; }

        [JsonProperty("studioType", Required = Required.Always)]
        public StudioType StudioType { get; set; }
    }

    public partial class PrefabPrefab
    {
        [JsonProperty("prefab", Required = Required.Always)]
        public string Prefab { get; set; }
    }

    public partial class InfoZoomDataClass
    {
        /// <summary>
        /// Icons to display on other cards during info zoom, e.g. indicating
        /// targets.
        /// </summary>
        [JsonProperty("icons", Required = Required.Always)]
        public List<IconElement> Icons { get; set; }

        /// <summary>
        /// Additional help text about this card, describing its abilities.
        /// </summary>
        [JsonProperty("supplementalCardInfo")]
        public ScreenOverlayElement SupplementalCardInfo { get; set; }
    }

    public partial class IconElement
    {
        [JsonProperty("cardId", Required = Required.Always)]
        public string CardId { get; set; }

        [JsonProperty("color", Required = Required.Always)]
        public ColorClass Color { get; set; }

        [JsonProperty("icon", Required = Required.Always)]
        public string Icon { get; set; }
    }

    public partial class FireProjectile
    {
        [JsonProperty("additionalHit")]
        public EffectClass AdditionalHit { get; set; }

        [JsonProperty("additionalHitDelay")]
        public WaitElement AdditionalHitDelay { get; set; }

        [JsonProperty("fireSound")]
        public SoundClass FireSound { get; set; }

        [JsonProperty("hideOnHit", Required = Required.Always)]
        public bool HideOnHit { get; set; }

        [JsonProperty("impactSound")]
        public SoundClass ImpactSound { get; set; }

        [JsonProperty("jumpToPosition")]
        public JumpToPositionClass JumpToPosition { get; set; }

        [JsonProperty("projectile", Required = Required.Always)]
        public ProjectileClass Projectile { get; set; }

        [JsonProperty("sourceId", Required = Required.Always)]
        public Source SourceId { get; set; }

        [JsonProperty("targetId", Required = Required.Always)]
        public Source TargetId { get; set; }

        [JsonProperty("travelDuration")]
        public WaitElement TravelDuration { get; set; }

        [JsonProperty("waitDuration")]
        public WaitElement WaitDuration { get; set; }
    }

    public partial class PlayAudioClip
    {
        /// <summary>
        /// How long to pause before continuing with animations.
        /// </summary>
        [JsonProperty("pauseDuration", Required = Required.Always)]
        public WaitElement PauseDuration { get; set; }

        /// <summary>
        /// Sound to play
        /// </summary>
        [JsonProperty("sound", Required = Required.Always)]
        public SoundClass Sound { get; set; }
    }

    public partial class PlayStudioAnimation
    {
        [JsonProperty("animation", Required = Required.Always)]
        public Animation Animation { get; set; }

        [JsonProperty("enterAnimation")]
        public Animation EnterAnimation { get; set; }

        [JsonProperty("exitAnimation")]
        public Animation ExitAnimation { get; set; }

        [JsonProperty("studioType", Required = Required.Always)]
        public StudioType StudioType { get; set; }
    }

    public partial class Animation
    {
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }
    }

    public partial class ToggleThinkingIndicator
    {
        [JsonProperty("show", Required = Required.Always)]
        public bool Show { get; set; }
    }

    public partial class UpdateBattle
    {
        /// <summary>
        /// The battle to update.
        /// </summary>
        [JsonProperty("battle", Required = Required.Always)]
        public Battle Battle { get; set; }

        /// <summary>
        /// Sound to play when the battle is updated.
        /// </summary>
        [JsonProperty("updateSound")]
        public SoundClass UpdateSound { get; set; }
    }

    /// <summary>
    /// The battle to update.
    ///
    /// Represents the visual state of an ongoing dream battle
    /// </summary>
    public partial class Battle
    {
        /// <summary>
        /// Arrows to display between cards
        /// </summary>
        [JsonProperty("arrows", Required = Required.Always)]
        public List<ArrowElement> Arrows { get; set; }

        /// <summary>
        /// Visual state of cards in the game
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<DrawUserCardsCard> Cards { get; set; }

        /// <summary>
        /// Opponent of user
        /// </summary>
        [JsonProperty("enemy", Required = Required.Always)]
        public BattleEnemy Enemy { get; set; }

        /// <summary>
        /// Unique identifier for this dream battle
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public Guid Id { get; set; }

        /// <summary>
        /// UI to display to the player.
        /// </summary>
        [JsonProperty("interface", Required = Required.Always)]
        public Interface Interface { get; set; }

        /// <summary>
        /// Preview of the next state of the battle, used e.g. when confirming
        /// prompt choices.
        /// </summary>
        [JsonProperty("preview", Required = Required.Always)]
        public Preview Preview { get; set; }

        /// <summary>
        /// Player who is operating the client
        /// </summary>
        [JsonProperty("user", Required = Required.Always)]
        public BattleEnemy User { get; set; }
    }

    public partial class ArrowElement
    {
        [JsonProperty("color", Required = Required.Always)]
        public Color Color { get; set; }

        [JsonProperty("source", Required = Required.Always)]
        public Source Source { get; set; }

        [JsonProperty("target", Required = Required.Always)]
        public Source Target { get; set; }
    }

    /// <summary>
    /// Opponent of user
    ///
    /// Represents the visual state of a player in a game
    ///
    /// Player who is operating the client
    /// </summary>
    public partial class BattleEnemy
    {
        /// <summary>
        /// Can this player currently take a game action?
        /// </summary>
        [JsonProperty("canAct", Required = Required.Always)]
        public bool CanAct { get; set; }

        /// <summary>
        /// Energy available to this player
        /// </summary>
        [JsonProperty("energy", Required = Required.Always)]
        public long Energy { get; set; }

        /// <summary>
        /// Is it currently this player's turn?
        /// </summary>
        [JsonProperty("isCurrentTurn", Required = Required.Always)]
        public bool IsCurrentTurn { get; set; }

        /// <summary>
        /// Will this player win the game in their next judgment phase?
        /// </summary>
        [JsonProperty("isVictoryImminent", Required = Required.Always)]
        public bool IsVictoryImminent { get; set; }

        /// <summary>
        /// Energy produced by this player at the start of the current turn
        /// </summary>
        [JsonProperty("producedEnergy", Required = Required.Always)]
        public long ProducedEnergy { get; set; }

        /// <summary>
        /// Current score total
        /// </summary>
        [JsonProperty("score", Required = Required.Always)]
        public long Score { get; set; }

        /// <summary>
        /// Total spark for this player
        /// </summary>
        [JsonProperty("totalSpark", Required = Required.Always)]
        public long TotalSpark { get; set; }
    }

    /// <summary>
    /// UI to display to the player.
    ///
    /// User interaction options
    /// </summary>
    public partial class Interface
    {
        /// <summary>
        /// Button most often used for toggling the visibility of card browsers.
        /// </summary>
        [JsonProperty("bottomRightButton")]
        public BottomRightButtonClass BottomRightButton { get; set; }

        /// <summary>
        /// Options for display of the card order selector
        /// </summary>
        [JsonProperty("cardOrderSelector")]
        public CardOrderSelectorClass CardOrderSelector { get; set; }

        /// <summary>
        /// Button to decrement the number shown in a number prompt.
        /// </summary>
        [JsonProperty("decrementButton")]
        public BottomRightButtonClass DecrementButton { get; set; }

        /// <summary>
        /// Button to toggle the display of the developer panel
        /// </summary>
        [JsonProperty("devButton")]
        public BottomRightButtonClass DevButton { get; set; }

        /// <summary>
        /// Button to increment the number shown in a number prompt.
        /// </summary>
        [JsonProperty("incrementButton")]
        public BottomRightButtonClass IncrementButton { get; set; }

        /// <summary>
        /// Primary action button, used for confirming selections and ending the
        /// turn. None indicates no button should be shown.
        /// </summary>
        [JsonProperty("primaryActionButton")]
        public BottomRightButtonClass PrimaryActionButton { get; set; }

        /// <summary>
        /// If provided, when the primary action button is not visible, the button
        /// will wait for this duration after the last "update" before appearing. If
        /// this is None the button will display immediately.
        /// </summary>
        [JsonProperty("primaryActionShowOnIdleDuration")]
        public WaitElement PrimaryActionShowOnIdleDuration { get; set; }

        /// <summary>
        /// Content to display on top of all other game UI.
        /// </summary>
        [JsonProperty("screenOverlay")]
        public ScreenOverlayElement ScreenOverlay { get; set; }

        /// <summary>
        /// Secondary action button, used for alternative choice options.
        /// </summary>
        [JsonProperty("secondaryActionButton")]
        public BottomRightButtonClass SecondaryActionButton { get; set; }

        /// <summary>
        /// Button to perform an undo operation
        /// </summary>
        [JsonProperty("undoButton")]
        public BottomRightButtonClass UndoButton { get; set; }
    }

    /// <summary>
    /// Button to perform some game action
    /// </summary>
    public partial class BottomRightButtonClass
    {
        /// <summary>
        /// Action to perform when the button is clicked. If None is provided, the
        /// button will appear disabled.
        /// </summary>
        [JsonProperty("action")]
        public CanPlay? Action { get; set; }

        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    public partial class CardOrderSelectorClass
    {
        /// <summary>
        /// Include the user's deck as a card drop target
        /// </summary>
        [JsonProperty("includeDeck", Required = Required.Always)]
        public bool IncludeDeck { get; set; }

        /// <summary>
        /// Include the user's void as a card drop target
        /// </summary>
        [JsonProperty("includeVoid", Required = Required.Always)]
        public bool IncludeVoid { get; set; }
    }

    /// <summary>
    /// Active battle preview, e.g. when a prompt is active.
    /// </summary>
    public partial class PreviewClass
    {
        [JsonProperty("active", Required = Required.Always)]
        public ActiveClass Active { get; set; }
    }

    public partial class PerformActionRequest
    {
        [JsonProperty("action", Required = Required.Always)]
        public ActionUnion Action { get; set; }

        /// <summary>
        /// The version of the last response the client received, used to prevent
        /// duplicate actions.
        /// </summary>
        [JsonProperty("lastResponseVersion")]
        public Guid? LastResponseVersion { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        /// <summary>
        /// If specified, treats this as a multiplayer game using the save file
        /// provided in this ID instead of reading the user's own save file.
        /// </summary>
        [JsonProperty("saveFileId")]
        public Guid? SaveFileId { get; set; }

        [JsonProperty("testScenario")]
        public string TestScenario { get; set; }
    }

    public partial class PurpleSchema
    {
        [JsonProperty("debugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("battleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? BattleAction { get; set; }

        [JsonProperty("battleDisplayAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleDisplayAction? BattleDisplayAction { get; set; }

        [JsonProperty("undo", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawCard? Undo { get; set; }
    }

    public partial class PerformActionResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public Commands Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollRequest
    {
        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollResponse
    {
        [JsonProperty("commands")]
        public Commands Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        [JsonProperty("responseType", Required = Required.Always)]
        public ResponseType ResponseType { get; set; }

        [JsonProperty("responseVersion")]
        public Guid? ResponseVersion { get; set; }
    }

    public enum Name { ApplyCommandGroup, ApplyCommands, Connect, PerformAction, Poll, Untagged, UpdateBattleLayout };

    public enum LogType { Debug, Error, Info, Warning };

    public enum AgentEnum { AlwaysPanic, FirstAvailableAction, RandomAction, WaitFiveSeconds };

    /// <summary>
    /// Represents a player within the context of the display layer.
    ///
    /// The "viewer" is always the player operating the game client, this may
    /// correspond to either of the actual players in the game.
    ///
    /// The player to display the judgment animation for.
    ///
    /// The player to display the dreamwell activation for.
    /// </summary>
    public enum Deck { Enemy, User };

    public enum DisplayGameMessage { Defeat, EnemyTurn, Victory, YourTurn };

    /// <summary>
    /// Face up/face down state for this card
    ///
    /// Whether a card is face-down or face-up
    /// </summary>
    public enum CardFacing { FaceDown, FaceUp };

    /// <summary>
    /// Object position used in interface elements like the deck viewer which
    /// don't rely on game positioning.
    ///
    /// Object is not visible.
    ///
    /// Position for cards to be shown to the user immediately after they're
    /// drawn.
    ///
    /// Object is being displayed in a card browser, e.g. to select from a list
    /// of cards while searching
    ///
    /// Object is in a temporary holding space for cards in hand while resolving
    /// some other 'play card' ability.
    ///
    /// Object is in a position to display itself as part of a dreamwell
    /// activation.
    ///
    /// Object describes a game modifier or ongoing game effect
    ///
    /// Object is in the on-screen storage area, used to hold objects at a small
    /// size when they're not being focused on, e.g. when the user hides a
    /// card browser to get a better view of the battlefield.
    /// </summary>
    public enum PositionPositionEnum { Browser, Default, Drawn, DreamwellActivation, GameModifier, HandStorage, Offscreen, OnScreenStorage };

    public enum CardOrderSelector { Deck, Void };

    public enum OnStack { Default, TargetingBothBattlefields, TargetingEnemyBattlefield, TargetingUserBattlefield };

    /// <summary>
    /// Represents the general category of card being displayed.
    /// </summary>
    public enum PrefabEnum { Character, Dreamsign, Dreamwell, Enemy, Event, Identity, Token };

    public enum ActionEnum { NoOp };

    /// <summary>
    /// Pass on taking actions in response to a card being played by the
    /// opponent, thus causing the stack to be resolved.
    ///
    /// End your turn
    ///
    /// Start your next turn after the opponent takes the `EndTurn` action.
    ///
    /// Toggle the visibility of the card order selector
    ///
    /// Confirm the selected cards to mulligan
    /// </summary>
    public enum BattleActionEnum { EndTurn, PassPriority, StartNextTurn, SubmitMulligan, ToggleOrderSelectorVisibility };

    /// <summary>
    /// Identifies a player in an ongoing battle.
    /// </summary>
    public enum DrawCard { One, Two };

    /// <summary>
    /// Closes the currently open panel.
    ///
    /// Toggles the visibility of the stack.
    /// </summary>
    public enum BattleDisplayActionEnum { CloseCardBrowser, CloseCurrentPanel, ToggleStackVisibility };

    public enum BrowseCards { EnemyDeck, EnemyStatus, EnemyVoid, UserDeck, UserStatus, UserVoid };

    public enum OpenPanelEnum { AddCardToHand, Developer, SetOpponentAgent };

    public enum DebugActionEnum { ApplyTestScenarioAction, RestartBattle };

    public enum AlignContentEnum { Auto, Center, FlexEnd, FlexStart, Stretch };

    public enum Unit { Percentage, Pixels, SafeAreaBottomInset, SafeAreaLeftInset, SafeAreaRightInset, SafeAreaTopInset, ViewportHeight, ViewportWidth };

    public enum DisplayEnum { Flex, None };

    public enum FlexDirectionEnum { Column, ColumnReverse, Row, RowReverse };

    public enum FontStyleEnum { Bold, BoldAndItalic, Italic, Normal };

    public enum JustifyContentEnum { Center, FlexEnd, FlexStart, SpaceAround, SpaceBetween };

    public enum OverflowEnum { Hidden, Visible };

    public enum OverflowClipBoxEnum { ContentBox, PaddingBox };

    public enum PickingModeEnum { Ignore, Position };

    public enum HoverStylePosition { Absolute, Relative };

    public enum TextAlignEnum { LowerCenter, LowerLeft, LowerRight, MiddleCenter, MiddleLeft, MiddleRight, UpperCenter, UpperLeft, UpperRight };

    public enum TextOverflowEnum { Clip, Ellipsis };

    public enum TextOverflowPositionEnum { End, Middle, Start };

    public enum TransitionEasingModeElement { Ease, EaseIn, EaseInBack, EaseInBounce, EaseInCirc, EaseInCubic, EaseInElastic, EaseInOut, EaseInOutBack, EaseInOutBounce, EaseInOutCirc, EaseInOutCubic, EaseInOutElastic, EaseInOutSine, EaseInSine, EaseOut, EaseOutBack, EaseOutBounce, EaseOutCirc, EaseOutCubic, EaseOutElastic, EaseOutSine, Linear };

    public enum WhiteSpaceEnum { NoWrap, Normal };

    public enum WrapEnum { NoWrap, Wrap, WrapReverse };

    public enum HorizontalScrollBarVisibilityEnum { AlwaysVisible, Auto, Hidden };

    public enum TouchScrollBehaviorEnum { Clamped, Elastic, Unrestricted };

    public enum DirectionEnum { Horizontal, Vertical };

    public enum StudioType { EnemyIdentityCard, EnemyStatus, UserIdentityCard, UserStatus };

    public enum Color { Blue, Green, Red };

    /// <summary>
    /// No preview is currently active. Clear any existing preview.
    ///
    /// Unknown battle preview state during animation
    ///
    /// Used to not remove the existing preview to avoid the interface jumping
    /// around between states.
    /// </summary>
    public enum PreviewEnum { None, Pending };

    public enum ResponseType { Final, Incremental };

    public partial struct Agent
    {
        public AgentClass AgentClass;
        public AgentEnum? Enum;

        public static implicit operator Agent(AgentClass AgentClass) => new Agent { AgentClass = AgentClass };
        public static implicit operator Agent(AgentEnum Enum) => new Agent { Enum = Enum };
    }

    /// <summary>
    /// Position category
    ///
    /// Possible types of display positions
    /// </summary>
    public partial struct Position
    {
        public PositionPositionEnum? Enum;
        public PositionPositionClass PositionPositionClass;

        public static implicit operator Position(PositionPositionEnum Enum) => new Position { Enum = Enum };
        public static implicit operator Position(PositionPositionClass PositionPositionClass) => new Position { PositionPositionClass = PositionPositionClass };
    }

    /// <summary>
    /// An action that can be performed in a battle
    /// </summary>
    public partial struct BattleAction
    {
        public BattleActionClass BattleActionClass;
        public BattleActionEnum? Enum;

        public static implicit operator BattleAction(BattleActionClass BattleActionClass) => new BattleAction { BattleActionClass = BattleActionClass };
        public static implicit operator BattleAction(BattleActionEnum Enum) => new BattleAction { Enum = Enum };
    }

    /// <summary>
    /// Identifies a window on screen containing UI elements
    /// </summary>
    public partial struct OpenPanel
    {
        public OpenPanelEnum? Enum;
        public OpenPanelClass OpenPanelClass;

        public static implicit operator OpenPanel(OpenPanelEnum Enum) => new OpenPanel { Enum = Enum };
        public static implicit operator OpenPanel(OpenPanelClass OpenPanelClass) => new OpenPanel { OpenPanelClass = OpenPanelClass };
    }

    public partial struct BattleDisplayAction
    {
        public BattleDisplayActionClass BattleDisplayActionClass;
        public BattleDisplayActionEnum? Enum;

        public static implicit operator BattleDisplayAction(BattleDisplayActionClass BattleDisplayActionClass) => new BattleDisplayAction { BattleDisplayActionClass = BattleDisplayActionClass };
        public static implicit operator BattleDisplayAction(BattleDisplayActionEnum Enum) => new BattleDisplayAction { Enum = Enum };
    }

    /// <summary>
    /// Private actions for developer use
    /// </summary>
    public partial struct DebugAction
    {
        public DebugActionClass DebugActionClass;
        public DebugActionEnum? Enum;

        public static implicit operator DebugAction(DebugActionClass DebugActionClass) => new DebugAction { DebugActionClass = DebugActionClass };
        public static implicit operator DebugAction(DebugActionEnum Enum) => new DebugAction { Enum = Enum };
    }

    public partial struct CanPlay
    {
        public CanPlayClass CanPlayClass;
        public ActionEnum? Enum;

        public static implicit operator CanPlay(CanPlayClass CanPlayClass) => new CanPlay { CanPlayClass = CanPlayClass };
        public static implicit operator CanPlay(ActionEnum Enum) => new CanPlay { Enum = Enum };
        public bool IsNull => CanPlayClass == null && Enum == null;
    }

    /// <summary>
    /// Preview of the next state of the battle, used e.g. when confirming
    /// prompt choices.
    /// </summary>
    public partial struct Preview
    {
        public PreviewEnum? Enum;
        public PreviewClass PreviewClass;

        public static implicit operator Preview(PreviewEnum Enum) => new Preview { Enum = Enum };
        public static implicit operator Preview(PreviewClass PreviewClass) => new Preview { PreviewClass = PreviewClass };
    }

    /// <summary>
    /// All possible user interface actions
    /// </summary>
    public partial struct ActionUnion
    {
        public ActionEnum? Enum;
        public PurpleSchema PurpleSchema;

        public static implicit operator ActionUnion(ActionEnum Enum) => new ActionUnion { Enum = Enum };
        public static implicit operator ActionUnion(PurpleSchema PurpleSchema) => new ActionUnion { PurpleSchema = PurpleSchema };
    }

    public partial class SchemaTypes
    {
        public static SchemaTypes FromJson(string json) => JsonConvert.DeserializeObject<SchemaTypes>(json, Dreamtides.Schema.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SchemaTypes self) => JsonConvert.SerializeObject(self, Dreamtides.Schema.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                LogTypeConverter.Singleton,
                NameConverter.Singleton,
                AgentConverter.Singleton,
                AgentEnumConverter.Singleton,
                DeckConverter.Singleton,
                DisplayGameMessageConverter.Singleton,
                CardFacingConverter.Singleton,
                PositionConverter.Singleton,
                CardOrderSelectorConverter.Singleton,
                OnStackConverter.Singleton,
                PositionPositionEnumConverter.Singleton,
                PrefabEnumConverter.Singleton,
                CanPlayConverter.Singleton,
                BattleActionConverter.Singleton,
                DrawCardConverter.Singleton,
                BattleActionEnumConverter.Singleton,
                BattleDisplayActionConverter.Singleton,
                BrowseCardsConverter.Singleton,
                OpenPanelConverter.Singleton,
                OpenPanelEnumConverter.Singleton,
                BattleDisplayActionEnumConverter.Singleton,
                DebugActionConverter.Singleton,
                DebugActionEnumConverter.Singleton,
                ActionEnumConverter.Singleton,
                AlignContentEnumConverter.Singleton,
                UnitConverter.Singleton,
                DisplayEnumConverter.Singleton,
                FlexDirectionEnumConverter.Singleton,
                FontStyleEnumConverter.Singleton,
                JustifyContentEnumConverter.Singleton,
                OverflowEnumConverter.Singleton,
                OverflowClipBoxEnumConverter.Singleton,
                PickingModeEnumConverter.Singleton,
                HoverStylePositionConverter.Singleton,
                TextAlignEnumConverter.Singleton,
                TextOverflowEnumConverter.Singleton,
                TextOverflowPositionEnumConverter.Singleton,
                TransitionEasingModeElementConverter.Singleton,
                WhiteSpaceEnumConverter.Singleton,
                WrapEnumConverter.Singleton,
                HorizontalScrollBarVisibilityEnumConverter.Singleton,
                TouchScrollBehaviorEnumConverter.Singleton,
                DirectionEnumConverter.Singleton,
                StudioTypeConverter.Singleton,
                ColorConverter.Singleton,
                PreviewConverter.Singleton,
                PreviewEnumConverter.Singleton,
                ActionUnionConverter.Singleton,
                ResponseTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class LogTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LogType) || t == typeof(LogType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "debug":
                    return LogType.Debug;
                case "error":
                    return LogType.Error;
                case "info":
                    return LogType.Info;
                case "warning":
                    return LogType.Warning;
            }
            throw new Exception("Cannot unmarshal type LogType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LogType)untypedValue;
            switch (value)
            {
                case LogType.Debug:
                    serializer.Serialize(writer, "debug");
                    return;
                case LogType.Error:
                    serializer.Serialize(writer, "error");
                    return;
                case LogType.Info:
                    serializer.Serialize(writer, "info");
                    return;
                case LogType.Warning:
                    serializer.Serialize(writer, "warning");
                    return;
            }
            throw new Exception("Cannot marshal type LogType");
        }

        public static readonly LogTypeConverter Singleton = new LogTypeConverter();
    }

    internal class NameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Name) || t == typeof(Name?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "applyCommandGroup":
                    return Name.ApplyCommandGroup;
                case "applyCommands":
                    return Name.ApplyCommands;
                case "connect":
                    return Name.Connect;
                case "performAction":
                    return Name.PerformAction;
                case "poll":
                    return Name.Poll;
                case "untagged":
                    return Name.Untagged;
                case "updateBattleLayout":
                    return Name.UpdateBattleLayout;
            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Name)untypedValue;
            switch (value)
            {
                case Name.ApplyCommandGroup:
                    serializer.Serialize(writer, "applyCommandGroup");
                    return;
                case Name.ApplyCommands:
                    serializer.Serialize(writer, "applyCommands");
                    return;
                case Name.Connect:
                    serializer.Serialize(writer, "connect");
                    return;
                case Name.PerformAction:
                    serializer.Serialize(writer, "performAction");
                    return;
                case Name.Poll:
                    serializer.Serialize(writer, "poll");
                    return;
                case Name.Untagged:
                    serializer.Serialize(writer, "untagged");
                    return;
                case Name.UpdateBattleLayout:
                    serializer.Serialize(writer, "updateBattleLayout");
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class AgentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Agent) || t == typeof(Agent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "alwaysPanic":
                            return new Agent { Enum = AgentEnum.AlwaysPanic };
                        case "firstAvailableAction":
                            return new Agent { Enum = AgentEnum.FirstAvailableAction };
                        case "randomAction":
                            return new Agent { Enum = AgentEnum.RandomAction };
                        case "waitFiveSeconds":
                            return new Agent { Enum = AgentEnum.WaitFiveSeconds };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AgentClass>(reader);
                    return new Agent { AgentClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Agent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Agent)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case AgentEnum.AlwaysPanic:
                        serializer.Serialize(writer, "alwaysPanic");
                        return;
                    case AgentEnum.FirstAvailableAction:
                        serializer.Serialize(writer, "firstAvailableAction");
                        return;
                    case AgentEnum.RandomAction:
                        serializer.Serialize(writer, "randomAction");
                        return;
                    case AgentEnum.WaitFiveSeconds:
                        serializer.Serialize(writer, "waitFiveSeconds");
                        return;
                }
            }
            if (value.AgentClass != null)
            {
                serializer.Serialize(writer, value.AgentClass);
                return;
            }
            throw new Exception("Cannot marshal type Agent");
        }

        public static readonly AgentConverter Singleton = new AgentConverter();
    }

    internal class AgentEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AgentEnum) || t == typeof(AgentEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alwaysPanic":
                    return AgentEnum.AlwaysPanic;
                case "firstAvailableAction":
                    return AgentEnum.FirstAvailableAction;
                case "randomAction":
                    return AgentEnum.RandomAction;
                case "waitFiveSeconds":
                    return AgentEnum.WaitFiveSeconds;
            }
            throw new Exception("Cannot unmarshal type AgentEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AgentEnum)untypedValue;
            switch (value)
            {
                case AgentEnum.AlwaysPanic:
                    serializer.Serialize(writer, "alwaysPanic");
                    return;
                case AgentEnum.FirstAvailableAction:
                    serializer.Serialize(writer, "firstAvailableAction");
                    return;
                case AgentEnum.RandomAction:
                    serializer.Serialize(writer, "randomAction");
                    return;
                case AgentEnum.WaitFiveSeconds:
                    serializer.Serialize(writer, "waitFiveSeconds");
                    return;
            }
            throw new Exception("Cannot marshal type AgentEnum");
        }

        public static readonly AgentEnumConverter Singleton = new AgentEnumConverter();
    }

    internal class DeckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Deck) || t == typeof(Deck?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Enemy":
                    return Deck.Enemy;
                case "User":
                    return Deck.User;
            }
            throw new Exception("Cannot unmarshal type Deck");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Deck)untypedValue;
            switch (value)
            {
                case Deck.Enemy:
                    serializer.Serialize(writer, "Enemy");
                    return;
                case Deck.User:
                    serializer.Serialize(writer, "User");
                    return;
            }
            throw new Exception("Cannot marshal type Deck");
        }

        public static readonly DeckConverter Singleton = new DeckConverter();
    }

    internal class DisplayGameMessageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayGameMessage) || t == typeof(DisplayGameMessage?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "defeat":
                    return DisplayGameMessage.Defeat;
                case "enemyTurn":
                    return DisplayGameMessage.EnemyTurn;
                case "victory":
                    return DisplayGameMessage.Victory;
                case "yourTurn":
                    return DisplayGameMessage.YourTurn;
            }
            throw new Exception("Cannot unmarshal type DisplayGameMessage");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayGameMessage)untypedValue;
            switch (value)
            {
                case DisplayGameMessage.Defeat:
                    serializer.Serialize(writer, "defeat");
                    return;
                case DisplayGameMessage.EnemyTurn:
                    serializer.Serialize(writer, "enemyTurn");
                    return;
                case DisplayGameMessage.Victory:
                    serializer.Serialize(writer, "victory");
                    return;
                case DisplayGameMessage.YourTurn:
                    serializer.Serialize(writer, "yourTurn");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayGameMessage");
        }

        public static readonly DisplayGameMessageConverter Singleton = new DisplayGameMessageConverter();
    }

    internal class CardFacingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardFacing) || t == typeof(CardFacing?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "faceDown":
                    return CardFacing.FaceDown;
                case "faceUp":
                    return CardFacing.FaceUp;
            }
            throw new Exception("Cannot unmarshal type CardFacing");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardFacing)untypedValue;
            switch (value)
            {
                case CardFacing.FaceDown:
                    serializer.Serialize(writer, "faceDown");
                    return;
                case CardFacing.FaceUp:
                    serializer.Serialize(writer, "faceUp");
                    return;
            }
            throw new Exception("Cannot marshal type CardFacing");
        }

        public static readonly CardFacingConverter Singleton = new CardFacingConverter();
    }

    internal class PositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Position) || t == typeof(Position?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "browser":
                            return new Position { Enum = PositionPositionEnum.Browser };
                        case "default":
                            return new Position { Enum = PositionPositionEnum.Default };
                        case "drawn":
                            return new Position { Enum = PositionPositionEnum.Drawn };
                        case "dreamwellActivation":
                            return new Position { Enum = PositionPositionEnum.DreamwellActivation };
                        case "gameModifier":
                            return new Position { Enum = PositionPositionEnum.GameModifier };
                        case "handStorage":
                            return new Position { Enum = PositionPositionEnum.HandStorage };
                        case "offscreen":
                            return new Position { Enum = PositionPositionEnum.Offscreen };
                        case "onScreenStorage":
                            return new Position { Enum = PositionPositionEnum.OnScreenStorage };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PositionPositionClass>(reader);
                    return new Position { PositionPositionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Position");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Position)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PositionPositionEnum.Browser:
                        serializer.Serialize(writer, "browser");
                        return;
                    case PositionPositionEnum.Default:
                        serializer.Serialize(writer, "default");
                        return;
                    case PositionPositionEnum.Drawn:
                        serializer.Serialize(writer, "drawn");
                        return;
                    case PositionPositionEnum.DreamwellActivation:
                        serializer.Serialize(writer, "dreamwellActivation");
                        return;
                    case PositionPositionEnum.GameModifier:
                        serializer.Serialize(writer, "gameModifier");
                        return;
                    case PositionPositionEnum.HandStorage:
                        serializer.Serialize(writer, "handStorage");
                        return;
                    case PositionPositionEnum.Offscreen:
                        serializer.Serialize(writer, "offscreen");
                        return;
                    case PositionPositionEnum.OnScreenStorage:
                        serializer.Serialize(writer, "onScreenStorage");
                        return;
                }
            }
            if (value.PositionPositionClass != null)
            {
                serializer.Serialize(writer, value.PositionPositionClass);
                return;
            }
            throw new Exception("Cannot marshal type Position");
        }

        public static readonly PositionConverter Singleton = new PositionConverter();
    }

    internal class CardOrderSelectorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardOrderSelector) || t == typeof(CardOrderSelector?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "deck":
                    return CardOrderSelector.Deck;
                case "void":
                    return CardOrderSelector.Void;
            }
            throw new Exception("Cannot unmarshal type CardOrderSelector");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardOrderSelector)untypedValue;
            switch (value)
            {
                case CardOrderSelector.Deck:
                    serializer.Serialize(writer, "deck");
                    return;
                case CardOrderSelector.Void:
                    serializer.Serialize(writer, "void");
                    return;
            }
            throw new Exception("Cannot marshal type CardOrderSelector");
        }

        public static readonly CardOrderSelectorConverter Singleton = new CardOrderSelectorConverter();
    }

    internal class OnStackConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OnStack) || t == typeof(OnStack?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "default":
                    return OnStack.Default;
                case "targetingBothBattlefields":
                    return OnStack.TargetingBothBattlefields;
                case "targetingEnemyBattlefield":
                    return OnStack.TargetingEnemyBattlefield;
                case "targetingUserBattlefield":
                    return OnStack.TargetingUserBattlefield;
            }
            throw new Exception("Cannot unmarshal type OnStack");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OnStack)untypedValue;
            switch (value)
            {
                case OnStack.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case OnStack.TargetingBothBattlefields:
                    serializer.Serialize(writer, "targetingBothBattlefields");
                    return;
                case OnStack.TargetingEnemyBattlefield:
                    serializer.Serialize(writer, "targetingEnemyBattlefield");
                    return;
                case OnStack.TargetingUserBattlefield:
                    serializer.Serialize(writer, "targetingUserBattlefield");
                    return;
            }
            throw new Exception("Cannot marshal type OnStack");
        }

        public static readonly OnStackConverter Singleton = new OnStackConverter();
    }

    internal class PositionPositionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PositionPositionEnum) || t == typeof(PositionPositionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "browser":
                    return PositionPositionEnum.Browser;
                case "default":
                    return PositionPositionEnum.Default;
                case "drawn":
                    return PositionPositionEnum.Drawn;
                case "dreamwellActivation":
                    return PositionPositionEnum.DreamwellActivation;
                case "gameModifier":
                    return PositionPositionEnum.GameModifier;
                case "handStorage":
                    return PositionPositionEnum.HandStorage;
                case "offscreen":
                    return PositionPositionEnum.Offscreen;
                case "onScreenStorage":
                    return PositionPositionEnum.OnScreenStorage;
            }
            throw new Exception("Cannot unmarshal type PositionPositionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PositionPositionEnum)untypedValue;
            switch (value)
            {
                case PositionPositionEnum.Browser:
                    serializer.Serialize(writer, "browser");
                    return;
                case PositionPositionEnum.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case PositionPositionEnum.Drawn:
                    serializer.Serialize(writer, "drawn");
                    return;
                case PositionPositionEnum.DreamwellActivation:
                    serializer.Serialize(writer, "dreamwellActivation");
                    return;
                case PositionPositionEnum.GameModifier:
                    serializer.Serialize(writer, "gameModifier");
                    return;
                case PositionPositionEnum.HandStorage:
                    serializer.Serialize(writer, "handStorage");
                    return;
                case PositionPositionEnum.Offscreen:
                    serializer.Serialize(writer, "offscreen");
                    return;
                case PositionPositionEnum.OnScreenStorage:
                    serializer.Serialize(writer, "onScreenStorage");
                    return;
            }
            throw new Exception("Cannot marshal type PositionPositionEnum");
        }

        public static readonly PositionPositionEnumConverter Singleton = new PositionPositionEnumConverter();
    }

    internal class PrefabEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PrefabEnum) || t == typeof(PrefabEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "character":
                    return PrefabEnum.Character;
                case "dreamsign":
                    return PrefabEnum.Dreamsign;
                case "dreamwell":
                    return PrefabEnum.Dreamwell;
                case "enemy":
                    return PrefabEnum.Enemy;
                case "event":
                    return PrefabEnum.Event;
                case "identity":
                    return PrefabEnum.Identity;
                case "token":
                    return PrefabEnum.Token;
            }
            throw new Exception("Cannot unmarshal type PrefabEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PrefabEnum)untypedValue;
            switch (value)
            {
                case PrefabEnum.Character:
                    serializer.Serialize(writer, "character");
                    return;
                case PrefabEnum.Dreamsign:
                    serializer.Serialize(writer, "dreamsign");
                    return;
                case PrefabEnum.Dreamwell:
                    serializer.Serialize(writer, "dreamwell");
                    return;
                case PrefabEnum.Enemy:
                    serializer.Serialize(writer, "enemy");
                    return;
                case PrefabEnum.Event:
                    serializer.Serialize(writer, "event");
                    return;
                case PrefabEnum.Identity:
                    serializer.Serialize(writer, "identity");
                    return;
                case PrefabEnum.Token:
                    serializer.Serialize(writer, "token");
                    return;
            }
            throw new Exception("Cannot marshal type PrefabEnum");
        }

        public static readonly PrefabEnumConverter Singleton = new PrefabEnumConverter();
    }

    internal class CanPlayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CanPlay) || t == typeof(CanPlay?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new CanPlay { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "noOp")
                    {
                        return new CanPlay { Enum = ActionEnum.NoOp };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<CanPlayClass>(reader);
                    return new CanPlay { CanPlayClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type CanPlay");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CanPlay)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Enum != null)
            {
                if (value.Enum == ActionEnum.NoOp)
                {
                    serializer.Serialize(writer, "noOp");
                    return;
                }
            }
            if (value.CanPlayClass != null)
            {
                serializer.Serialize(writer, value.CanPlayClass);
                return;
            }
            throw new Exception("Cannot marshal type CanPlay");
        }

        public static readonly CanPlayConverter Singleton = new CanPlayConverter();
    }

    internal class BattleActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleAction) || t == typeof(BattleAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "endTurn":
                            return new BattleAction { Enum = BattleActionEnum.EndTurn };
                        case "passPriority":
                            return new BattleAction { Enum = BattleActionEnum.PassPriority };
                        case "startNextTurn":
                            return new BattleAction { Enum = BattleActionEnum.StartNextTurn };
                        case "submitMulligan":
                            return new BattleAction { Enum = BattleActionEnum.SubmitMulligan };
                        case "toggleOrderSelectorVisibility":
                            return new BattleAction { Enum = BattleActionEnum.ToggleOrderSelectorVisibility };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BattleActionClass>(reader);
                    return new BattleAction { BattleActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type BattleAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BattleAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BattleActionEnum.EndTurn:
                        serializer.Serialize(writer, "endTurn");
                        return;
                    case BattleActionEnum.PassPriority:
                        serializer.Serialize(writer, "passPriority");
                        return;
                    case BattleActionEnum.StartNextTurn:
                        serializer.Serialize(writer, "startNextTurn");
                        return;
                    case BattleActionEnum.SubmitMulligan:
                        serializer.Serialize(writer, "submitMulligan");
                        return;
                    case BattleActionEnum.ToggleOrderSelectorVisibility:
                        serializer.Serialize(writer, "toggleOrderSelectorVisibility");
                        return;
                }
            }
            if (value.BattleActionClass != null)
            {
                serializer.Serialize(writer, value.BattleActionClass);
                return;
            }
            throw new Exception("Cannot marshal type BattleAction");
        }

        public static readonly BattleActionConverter Singleton = new BattleActionConverter();
    }

    internal class DrawCardConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DrawCard) || t == typeof(DrawCard?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "one":
                    return DrawCard.One;
                case "two":
                    return DrawCard.Two;
            }
            throw new Exception("Cannot unmarshal type DrawCard");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DrawCard)untypedValue;
            switch (value)
            {
                case DrawCard.One:
                    serializer.Serialize(writer, "one");
                    return;
                case DrawCard.Two:
                    serializer.Serialize(writer, "two");
                    return;
            }
            throw new Exception("Cannot marshal type DrawCard");
        }

        public static readonly DrawCardConverter Singleton = new DrawCardConverter();
    }

    internal class BattleActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleActionEnum) || t == typeof(BattleActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "endTurn":
                    return BattleActionEnum.EndTurn;
                case "passPriority":
                    return BattleActionEnum.PassPriority;
                case "startNextTurn":
                    return BattleActionEnum.StartNextTurn;
                case "submitMulligan":
                    return BattleActionEnum.SubmitMulligan;
                case "toggleOrderSelectorVisibility":
                    return BattleActionEnum.ToggleOrderSelectorVisibility;
            }
            throw new Exception("Cannot unmarshal type BattleActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattleActionEnum)untypedValue;
            switch (value)
            {
                case BattleActionEnum.EndTurn:
                    serializer.Serialize(writer, "endTurn");
                    return;
                case BattleActionEnum.PassPriority:
                    serializer.Serialize(writer, "passPriority");
                    return;
                case BattleActionEnum.StartNextTurn:
                    serializer.Serialize(writer, "startNextTurn");
                    return;
                case BattleActionEnum.SubmitMulligan:
                    serializer.Serialize(writer, "submitMulligan");
                    return;
                case BattleActionEnum.ToggleOrderSelectorVisibility:
                    serializer.Serialize(writer, "toggleOrderSelectorVisibility");
                    return;
            }
            throw new Exception("Cannot marshal type BattleActionEnum");
        }

        public static readonly BattleActionEnumConverter Singleton = new BattleActionEnumConverter();
    }

    internal class BattleDisplayActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleDisplayAction) || t == typeof(BattleDisplayAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "closeCardBrowser":
                            return new BattleDisplayAction { Enum = BattleDisplayActionEnum.CloseCardBrowser };
                        case "closeCurrentPanel":
                            return new BattleDisplayAction { Enum = BattleDisplayActionEnum.CloseCurrentPanel };
                        case "toggleStackVisibility":
                            return new BattleDisplayAction { Enum = BattleDisplayActionEnum.ToggleStackVisibility };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BattleDisplayActionClass>(reader);
                    return new BattleDisplayAction { BattleDisplayActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type BattleDisplayAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BattleDisplayAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BattleDisplayActionEnum.CloseCardBrowser:
                        serializer.Serialize(writer, "closeCardBrowser");
                        return;
                    case BattleDisplayActionEnum.CloseCurrentPanel:
                        serializer.Serialize(writer, "closeCurrentPanel");
                        return;
                    case BattleDisplayActionEnum.ToggleStackVisibility:
                        serializer.Serialize(writer, "toggleStackVisibility");
                        return;
                }
            }
            if (value.BattleDisplayActionClass != null)
            {
                serializer.Serialize(writer, value.BattleDisplayActionClass);
                return;
            }
            throw new Exception("Cannot marshal type BattleDisplayAction");
        }

        public static readonly BattleDisplayActionConverter Singleton = new BattleDisplayActionConverter();
    }

    internal class BrowseCardsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BrowseCards) || t == typeof(BrowseCards?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "enemyDeck":
                    return BrowseCards.EnemyDeck;
                case "enemyStatus":
                    return BrowseCards.EnemyStatus;
                case "enemyVoid":
                    return BrowseCards.EnemyVoid;
                case "userDeck":
                    return BrowseCards.UserDeck;
                case "userStatus":
                    return BrowseCards.UserStatus;
                case "userVoid":
                    return BrowseCards.UserVoid;
            }
            throw new Exception("Cannot unmarshal type BrowseCards");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BrowseCards)untypedValue;
            switch (value)
            {
                case BrowseCards.EnemyDeck:
                    serializer.Serialize(writer, "enemyDeck");
                    return;
                case BrowseCards.EnemyStatus:
                    serializer.Serialize(writer, "enemyStatus");
                    return;
                case BrowseCards.EnemyVoid:
                    serializer.Serialize(writer, "enemyVoid");
                    return;
                case BrowseCards.UserDeck:
                    serializer.Serialize(writer, "userDeck");
                    return;
                case BrowseCards.UserStatus:
                    serializer.Serialize(writer, "userStatus");
                    return;
                case BrowseCards.UserVoid:
                    serializer.Serialize(writer, "userVoid");
                    return;
            }
            throw new Exception("Cannot marshal type BrowseCards");
        }

        public static readonly BrowseCardsConverter Singleton = new BrowseCardsConverter();
    }

    internal class OpenPanelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OpenPanel) || t == typeof(OpenPanel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "addCardToHand":
                            return new OpenPanel { Enum = OpenPanelEnum.AddCardToHand };
                        case "developer":
                            return new OpenPanel { Enum = OpenPanelEnum.Developer };
                        case "setOpponentAgent":
                            return new OpenPanel { Enum = OpenPanelEnum.SetOpponentAgent };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OpenPanelClass>(reader);
                    return new OpenPanel { OpenPanelClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type OpenPanel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (OpenPanel)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case OpenPanelEnum.AddCardToHand:
                        serializer.Serialize(writer, "addCardToHand");
                        return;
                    case OpenPanelEnum.Developer:
                        serializer.Serialize(writer, "developer");
                        return;
                    case OpenPanelEnum.SetOpponentAgent:
                        serializer.Serialize(writer, "setOpponentAgent");
                        return;
                }
            }
            if (value.OpenPanelClass != null)
            {
                serializer.Serialize(writer, value.OpenPanelClass);
                return;
            }
            throw new Exception("Cannot marshal type OpenPanel");
        }

        public static readonly OpenPanelConverter Singleton = new OpenPanelConverter();
    }

    internal class OpenPanelEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OpenPanelEnum) || t == typeof(OpenPanelEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "addCardToHand":
                    return OpenPanelEnum.AddCardToHand;
                case "developer":
                    return OpenPanelEnum.Developer;
                case "setOpponentAgent":
                    return OpenPanelEnum.SetOpponentAgent;
            }
            throw new Exception("Cannot unmarshal type OpenPanelEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OpenPanelEnum)untypedValue;
            switch (value)
            {
                case OpenPanelEnum.AddCardToHand:
                    serializer.Serialize(writer, "addCardToHand");
                    return;
                case OpenPanelEnum.Developer:
                    serializer.Serialize(writer, "developer");
                    return;
                case OpenPanelEnum.SetOpponentAgent:
                    serializer.Serialize(writer, "setOpponentAgent");
                    return;
            }
            throw new Exception("Cannot marshal type OpenPanelEnum");
        }

        public static readonly OpenPanelEnumConverter Singleton = new OpenPanelEnumConverter();
    }

    internal class BattleDisplayActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleDisplayActionEnum) || t == typeof(BattleDisplayActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "closeCardBrowser":
                    return BattleDisplayActionEnum.CloseCardBrowser;
                case "closeCurrentPanel":
                    return BattleDisplayActionEnum.CloseCurrentPanel;
                case "toggleStackVisibility":
                    return BattleDisplayActionEnum.ToggleStackVisibility;
            }
            throw new Exception("Cannot unmarshal type BattleDisplayActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattleDisplayActionEnum)untypedValue;
            switch (value)
            {
                case BattleDisplayActionEnum.CloseCardBrowser:
                    serializer.Serialize(writer, "closeCardBrowser");
                    return;
                case BattleDisplayActionEnum.CloseCurrentPanel:
                    serializer.Serialize(writer, "closeCurrentPanel");
                    return;
                case BattleDisplayActionEnum.ToggleStackVisibility:
                    serializer.Serialize(writer, "toggleStackVisibility");
                    return;
            }
            throw new Exception("Cannot marshal type BattleDisplayActionEnum");
        }

        public static readonly BattleDisplayActionEnumConverter Singleton = new BattleDisplayActionEnumConverter();
    }

    internal class DebugActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugAction) || t == typeof(DebugAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "applyTestScenarioAction":
                            return new DebugAction { Enum = DebugActionEnum.ApplyTestScenarioAction };
                        case "restartBattle":
                            return new DebugAction { Enum = DebugActionEnum.RestartBattle };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DebugActionClass>(reader);
                    return new DebugAction { DebugActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type DebugAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DebugAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case DebugActionEnum.ApplyTestScenarioAction:
                        serializer.Serialize(writer, "applyTestScenarioAction");
                        return;
                    case DebugActionEnum.RestartBattle:
                        serializer.Serialize(writer, "restartBattle");
                        return;
                }
            }
            if (value.DebugActionClass != null)
            {
                serializer.Serialize(writer, value.DebugActionClass);
                return;
            }
            throw new Exception("Cannot marshal type DebugAction");
        }

        public static readonly DebugActionConverter Singleton = new DebugActionConverter();
    }

    internal class DebugActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugActionEnum) || t == typeof(DebugActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "applyTestScenarioAction":
                    return DebugActionEnum.ApplyTestScenarioAction;
                case "restartBattle":
                    return DebugActionEnum.RestartBattle;
            }
            throw new Exception("Cannot unmarshal type DebugActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DebugActionEnum)untypedValue;
            switch (value)
            {
                case DebugActionEnum.ApplyTestScenarioAction:
                    serializer.Serialize(writer, "applyTestScenarioAction");
                    return;
                case DebugActionEnum.RestartBattle:
                    serializer.Serialize(writer, "restartBattle");
                    return;
            }
            throw new Exception("Cannot marshal type DebugActionEnum");
        }

        public static readonly DebugActionEnumConverter Singleton = new DebugActionEnumConverter();
    }

    internal class ActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionEnum) || t == typeof(ActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "noOp")
            {
                return ActionEnum.NoOp;
            }
            throw new Exception("Cannot unmarshal type ActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ActionEnum)untypedValue;
            if (value == ActionEnum.NoOp)
            {
                serializer.Serialize(writer, "noOp");
                return;
            }
            throw new Exception("Cannot marshal type ActionEnum");
        }

        public static readonly ActionEnumConverter Singleton = new ActionEnumConverter();
    }

    internal class AlignContentEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AlignContentEnum) || t == typeof(AlignContentEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "auto":
                    return AlignContentEnum.Auto;
                case "center":
                    return AlignContentEnum.Center;
                case "flexEnd":
                    return AlignContentEnum.FlexEnd;
                case "flexStart":
                    return AlignContentEnum.FlexStart;
                case "stretch":
                    return AlignContentEnum.Stretch;
            }
            throw new Exception("Cannot unmarshal type AlignContentEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AlignContentEnum)untypedValue;
            switch (value)
            {
                case AlignContentEnum.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case AlignContentEnum.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case AlignContentEnum.FlexEnd:
                    serializer.Serialize(writer, "flexEnd");
                    return;
                case AlignContentEnum.FlexStart:
                    serializer.Serialize(writer, "flexStart");
                    return;
                case AlignContentEnum.Stretch:
                    serializer.Serialize(writer, "stretch");
                    return;
            }
            throw new Exception("Cannot marshal type AlignContentEnum");
        }

        public static readonly AlignContentEnumConverter Singleton = new AlignContentEnumConverter();
    }

    internal class UnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Unit) || t == typeof(Unit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "percentage":
                    return Unit.Percentage;
                case "pixels":
                    return Unit.Pixels;
                case "safeAreaBottomInset":
                    return Unit.SafeAreaBottomInset;
                case "safeAreaLeftInset":
                    return Unit.SafeAreaLeftInset;
                case "safeAreaRightInset":
                    return Unit.SafeAreaRightInset;
                case "safeAreaTopInset":
                    return Unit.SafeAreaTopInset;
                case "viewportHeight":
                    return Unit.ViewportHeight;
                case "viewportWidth":
                    return Unit.ViewportWidth;
            }
            throw new Exception("Cannot unmarshal type Unit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Unit)untypedValue;
            switch (value)
            {
                case Unit.Percentage:
                    serializer.Serialize(writer, "percentage");
                    return;
                case Unit.Pixels:
                    serializer.Serialize(writer, "pixels");
                    return;
                case Unit.SafeAreaBottomInset:
                    serializer.Serialize(writer, "safeAreaBottomInset");
                    return;
                case Unit.SafeAreaLeftInset:
                    serializer.Serialize(writer, "safeAreaLeftInset");
                    return;
                case Unit.SafeAreaRightInset:
                    serializer.Serialize(writer, "safeAreaRightInset");
                    return;
                case Unit.SafeAreaTopInset:
                    serializer.Serialize(writer, "safeAreaTopInset");
                    return;
                case Unit.ViewportHeight:
                    serializer.Serialize(writer, "viewportHeight");
                    return;
                case Unit.ViewportWidth:
                    serializer.Serialize(writer, "viewportWidth");
                    return;
            }
            throw new Exception("Cannot marshal type Unit");
        }

        public static readonly UnitConverter Singleton = new UnitConverter();
    }

    internal class DisplayEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayEnum) || t == typeof(DisplayEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "flex":
                    return DisplayEnum.Flex;
                case "none":
                    return DisplayEnum.None;
            }
            throw new Exception("Cannot unmarshal type DisplayEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayEnum)untypedValue;
            switch (value)
            {
                case DisplayEnum.Flex:
                    serializer.Serialize(writer, "flex");
                    return;
                case DisplayEnum.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayEnum");
        }

        public static readonly DisplayEnumConverter Singleton = new DisplayEnumConverter();
    }

    internal class FlexDirectionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDirectionEnum) || t == typeof(FlexDirectionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "column":
                    return FlexDirectionEnum.Column;
                case "columnReverse":
                    return FlexDirectionEnum.ColumnReverse;
                case "row":
                    return FlexDirectionEnum.Row;
                case "rowReverse":
                    return FlexDirectionEnum.RowReverse;
            }
            throw new Exception("Cannot unmarshal type FlexDirectionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDirectionEnum)untypedValue;
            switch (value)
            {
                case FlexDirectionEnum.Column:
                    serializer.Serialize(writer, "column");
                    return;
                case FlexDirectionEnum.ColumnReverse:
                    serializer.Serialize(writer, "columnReverse");
                    return;
                case FlexDirectionEnum.Row:
                    serializer.Serialize(writer, "row");
                    return;
                case FlexDirectionEnum.RowReverse:
                    serializer.Serialize(writer, "rowReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDirectionEnum");
        }

        public static readonly FlexDirectionEnumConverter Singleton = new FlexDirectionEnumConverter();
    }

    internal class FontStyleEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontStyleEnum) || t == typeof(FontStyleEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bold":
                    return FontStyleEnum.Bold;
                case "boldAndItalic":
                    return FontStyleEnum.BoldAndItalic;
                case "italic":
                    return FontStyleEnum.Italic;
                case "normal":
                    return FontStyleEnum.Normal;
            }
            throw new Exception("Cannot unmarshal type FontStyleEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontStyleEnum)untypedValue;
            switch (value)
            {
                case FontStyleEnum.Bold:
                    serializer.Serialize(writer, "bold");
                    return;
                case FontStyleEnum.BoldAndItalic:
                    serializer.Serialize(writer, "boldAndItalic");
                    return;
                case FontStyleEnum.Italic:
                    serializer.Serialize(writer, "italic");
                    return;
                case FontStyleEnum.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontStyleEnum");
        }

        public static readonly FontStyleEnumConverter Singleton = new FontStyleEnumConverter();
    }

    internal class JustifyContentEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(JustifyContentEnum) || t == typeof(JustifyContentEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return JustifyContentEnum.Center;
                case "flexEnd":
                    return JustifyContentEnum.FlexEnd;
                case "flexStart":
                    return JustifyContentEnum.FlexStart;
                case "spaceAround":
                    return JustifyContentEnum.SpaceAround;
                case "spaceBetween":
                    return JustifyContentEnum.SpaceBetween;
            }
            throw new Exception("Cannot unmarshal type JustifyContentEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (JustifyContentEnum)untypedValue;
            switch (value)
            {
                case JustifyContentEnum.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case JustifyContentEnum.FlexEnd:
                    serializer.Serialize(writer, "flexEnd");
                    return;
                case JustifyContentEnum.FlexStart:
                    serializer.Serialize(writer, "flexStart");
                    return;
                case JustifyContentEnum.SpaceAround:
                    serializer.Serialize(writer, "spaceAround");
                    return;
                case JustifyContentEnum.SpaceBetween:
                    serializer.Serialize(writer, "spaceBetween");
                    return;
            }
            throw new Exception("Cannot marshal type JustifyContentEnum");
        }

        public static readonly JustifyContentEnumConverter Singleton = new JustifyContentEnumConverter();
    }

    internal class OverflowEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OverflowEnum) || t == typeof(OverflowEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hidden":
                    return OverflowEnum.Hidden;
                case "visible":
                    return OverflowEnum.Visible;
            }
            throw new Exception("Cannot unmarshal type OverflowEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OverflowEnum)untypedValue;
            switch (value)
            {
                case OverflowEnum.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
                case OverflowEnum.Visible:
                    serializer.Serialize(writer, "visible");
                    return;
            }
            throw new Exception("Cannot marshal type OverflowEnum");
        }

        public static readonly OverflowEnumConverter Singleton = new OverflowEnumConverter();
    }

    internal class OverflowClipBoxEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OverflowClipBoxEnum) || t == typeof(OverflowClipBoxEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "contentBox":
                    return OverflowClipBoxEnum.ContentBox;
                case "paddingBox":
                    return OverflowClipBoxEnum.PaddingBox;
            }
            throw new Exception("Cannot unmarshal type OverflowClipBoxEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OverflowClipBoxEnum)untypedValue;
            switch (value)
            {
                case OverflowClipBoxEnum.ContentBox:
                    serializer.Serialize(writer, "contentBox");
                    return;
                case OverflowClipBoxEnum.PaddingBox:
                    serializer.Serialize(writer, "paddingBox");
                    return;
            }
            throw new Exception("Cannot marshal type OverflowClipBoxEnum");
        }

        public static readonly OverflowClipBoxEnumConverter Singleton = new OverflowClipBoxEnumConverter();
    }

    internal class PickingModeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PickingModeEnum) || t == typeof(PickingModeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ignore":
                    return PickingModeEnum.Ignore;
                case "position":
                    return PickingModeEnum.Position;
            }
            throw new Exception("Cannot unmarshal type PickingModeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PickingModeEnum)untypedValue;
            switch (value)
            {
                case PickingModeEnum.Ignore:
                    serializer.Serialize(writer, "ignore");
                    return;
                case PickingModeEnum.Position:
                    serializer.Serialize(writer, "position");
                    return;
            }
            throw new Exception("Cannot marshal type PickingModeEnum");
        }

        public static readonly PickingModeEnumConverter Singleton = new PickingModeEnumConverter();
    }

    internal class HoverStylePositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HoverStylePosition) || t == typeof(HoverStylePosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "absolute":
                    return HoverStylePosition.Absolute;
                case "relative":
                    return HoverStylePosition.Relative;
            }
            throw new Exception("Cannot unmarshal type HoverStylePosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HoverStylePosition)untypedValue;
            switch (value)
            {
                case HoverStylePosition.Absolute:
                    serializer.Serialize(writer, "absolute");
                    return;
                case HoverStylePosition.Relative:
                    serializer.Serialize(writer, "relative");
                    return;
            }
            throw new Exception("Cannot marshal type HoverStylePosition");
        }

        public static readonly HoverStylePositionConverter Singleton = new HoverStylePositionConverter();
    }

    internal class TextAlignEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextAlignEnum) || t == typeof(TextAlignEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "lowerCenter":
                    return TextAlignEnum.LowerCenter;
                case "lowerLeft":
                    return TextAlignEnum.LowerLeft;
                case "lowerRight":
                    return TextAlignEnum.LowerRight;
                case "middleCenter":
                    return TextAlignEnum.MiddleCenter;
                case "middleLeft":
                    return TextAlignEnum.MiddleLeft;
                case "middleRight":
                    return TextAlignEnum.MiddleRight;
                case "upperCenter":
                    return TextAlignEnum.UpperCenter;
                case "upperLeft":
                    return TextAlignEnum.UpperLeft;
                case "upperRight":
                    return TextAlignEnum.UpperRight;
            }
            throw new Exception("Cannot unmarshal type TextAlignEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextAlignEnum)untypedValue;
            switch (value)
            {
                case TextAlignEnum.LowerCenter:
                    serializer.Serialize(writer, "lowerCenter");
                    return;
                case TextAlignEnum.LowerLeft:
                    serializer.Serialize(writer, "lowerLeft");
                    return;
                case TextAlignEnum.LowerRight:
                    serializer.Serialize(writer, "lowerRight");
                    return;
                case TextAlignEnum.MiddleCenter:
                    serializer.Serialize(writer, "middleCenter");
                    return;
                case TextAlignEnum.MiddleLeft:
                    serializer.Serialize(writer, "middleLeft");
                    return;
                case TextAlignEnum.MiddleRight:
                    serializer.Serialize(writer, "middleRight");
                    return;
                case TextAlignEnum.UpperCenter:
                    serializer.Serialize(writer, "upperCenter");
                    return;
                case TextAlignEnum.UpperLeft:
                    serializer.Serialize(writer, "upperLeft");
                    return;
                case TextAlignEnum.UpperRight:
                    serializer.Serialize(writer, "upperRight");
                    return;
            }
            throw new Exception("Cannot marshal type TextAlignEnum");
        }

        public static readonly TextAlignEnumConverter Singleton = new TextAlignEnumConverter();
    }

    internal class TextOverflowEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflowEnum) || t == typeof(TextOverflowEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "clip":
                    return TextOverflowEnum.Clip;
                case "ellipsis":
                    return TextOverflowEnum.Ellipsis;
            }
            throw new Exception("Cannot unmarshal type TextOverflowEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflowEnum)untypedValue;
            switch (value)
            {
                case TextOverflowEnum.Clip:
                    serializer.Serialize(writer, "clip");
                    return;
                case TextOverflowEnum.Ellipsis:
                    serializer.Serialize(writer, "ellipsis");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflowEnum");
        }

        public static readonly TextOverflowEnumConverter Singleton = new TextOverflowEnumConverter();
    }

    internal class TextOverflowPositionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflowPositionEnum) || t == typeof(TextOverflowPositionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "end":
                    return TextOverflowPositionEnum.End;
                case "middle":
                    return TextOverflowPositionEnum.Middle;
                case "start":
                    return TextOverflowPositionEnum.Start;
            }
            throw new Exception("Cannot unmarshal type TextOverflowPositionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflowPositionEnum)untypedValue;
            switch (value)
            {
                case TextOverflowPositionEnum.End:
                    serializer.Serialize(writer, "end");
                    return;
                case TextOverflowPositionEnum.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case TextOverflowPositionEnum.Start:
                    serializer.Serialize(writer, "start");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflowPositionEnum");
        }

        public static readonly TextOverflowPositionEnumConverter Singleton = new TextOverflowPositionEnumConverter();
    }

    internal class TransitionEasingModeElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransitionEasingModeElement) || t == typeof(TransitionEasingModeElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ease":
                    return TransitionEasingModeElement.Ease;
                case "easeIn":
                    return TransitionEasingModeElement.EaseIn;
                case "easeInBack":
                    return TransitionEasingModeElement.EaseInBack;
                case "easeInBounce":
                    return TransitionEasingModeElement.EaseInBounce;
                case "easeInCirc":
                    return TransitionEasingModeElement.EaseInCirc;
                case "easeInCubic":
                    return TransitionEasingModeElement.EaseInCubic;
                case "easeInElastic":
                    return TransitionEasingModeElement.EaseInElastic;
                case "easeInOut":
                    return TransitionEasingModeElement.EaseInOut;
                case "easeInOutBack":
                    return TransitionEasingModeElement.EaseInOutBack;
                case "easeInOutBounce":
                    return TransitionEasingModeElement.EaseInOutBounce;
                case "easeInOutCirc":
                    return TransitionEasingModeElement.EaseInOutCirc;
                case "easeInOutCubic":
                    return TransitionEasingModeElement.EaseInOutCubic;
                case "easeInOutElastic":
                    return TransitionEasingModeElement.EaseInOutElastic;
                case "easeInOutSine":
                    return TransitionEasingModeElement.EaseInOutSine;
                case "easeInSine":
                    return TransitionEasingModeElement.EaseInSine;
                case "easeOut":
                    return TransitionEasingModeElement.EaseOut;
                case "easeOutBack":
                    return TransitionEasingModeElement.EaseOutBack;
                case "easeOutBounce":
                    return TransitionEasingModeElement.EaseOutBounce;
                case "easeOutCirc":
                    return TransitionEasingModeElement.EaseOutCirc;
                case "easeOutCubic":
                    return TransitionEasingModeElement.EaseOutCubic;
                case "easeOutElastic":
                    return TransitionEasingModeElement.EaseOutElastic;
                case "easeOutSine":
                    return TransitionEasingModeElement.EaseOutSine;
                case "linear":
                    return TransitionEasingModeElement.Linear;
            }
            throw new Exception("Cannot unmarshal type TransitionEasingModeElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TransitionEasingModeElement)untypedValue;
            switch (value)
            {
                case TransitionEasingModeElement.Ease:
                    serializer.Serialize(writer, "ease");
                    return;
                case TransitionEasingModeElement.EaseIn:
                    serializer.Serialize(writer, "easeIn");
                    return;
                case TransitionEasingModeElement.EaseInBack:
                    serializer.Serialize(writer, "easeInBack");
                    return;
                case TransitionEasingModeElement.EaseInBounce:
                    serializer.Serialize(writer, "easeInBounce");
                    return;
                case TransitionEasingModeElement.EaseInCirc:
                    serializer.Serialize(writer, "easeInCirc");
                    return;
                case TransitionEasingModeElement.EaseInCubic:
                    serializer.Serialize(writer, "easeInCubic");
                    return;
                case TransitionEasingModeElement.EaseInElastic:
                    serializer.Serialize(writer, "easeInElastic");
                    return;
                case TransitionEasingModeElement.EaseInOut:
                    serializer.Serialize(writer, "easeInOut");
                    return;
                case TransitionEasingModeElement.EaseInOutBack:
                    serializer.Serialize(writer, "easeInOutBack");
                    return;
                case TransitionEasingModeElement.EaseInOutBounce:
                    serializer.Serialize(writer, "easeInOutBounce");
                    return;
                case TransitionEasingModeElement.EaseInOutCirc:
                    serializer.Serialize(writer, "easeInOutCirc");
                    return;
                case TransitionEasingModeElement.EaseInOutCubic:
                    serializer.Serialize(writer, "easeInOutCubic");
                    return;
                case TransitionEasingModeElement.EaseInOutElastic:
                    serializer.Serialize(writer, "easeInOutElastic");
                    return;
                case TransitionEasingModeElement.EaseInOutSine:
                    serializer.Serialize(writer, "easeInOutSine");
                    return;
                case TransitionEasingModeElement.EaseInSine:
                    serializer.Serialize(writer, "easeInSine");
                    return;
                case TransitionEasingModeElement.EaseOut:
                    serializer.Serialize(writer, "easeOut");
                    return;
                case TransitionEasingModeElement.EaseOutBack:
                    serializer.Serialize(writer, "easeOutBack");
                    return;
                case TransitionEasingModeElement.EaseOutBounce:
                    serializer.Serialize(writer, "easeOutBounce");
                    return;
                case TransitionEasingModeElement.EaseOutCirc:
                    serializer.Serialize(writer, "easeOutCirc");
                    return;
                case TransitionEasingModeElement.EaseOutCubic:
                    serializer.Serialize(writer, "easeOutCubic");
                    return;
                case TransitionEasingModeElement.EaseOutElastic:
                    serializer.Serialize(writer, "easeOutElastic");
                    return;
                case TransitionEasingModeElement.EaseOutSine:
                    serializer.Serialize(writer, "easeOutSine");
                    return;
                case TransitionEasingModeElement.Linear:
                    serializer.Serialize(writer, "linear");
                    return;
            }
            throw new Exception("Cannot marshal type TransitionEasingModeElement");
        }

        public static readonly TransitionEasingModeElementConverter Singleton = new TransitionEasingModeElementConverter();
    }

    internal class WhiteSpaceEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WhiteSpaceEnum) || t == typeof(WhiteSpaceEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "noWrap":
                    return WhiteSpaceEnum.NoWrap;
                case "normal":
                    return WhiteSpaceEnum.Normal;
            }
            throw new Exception("Cannot unmarshal type WhiteSpaceEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WhiteSpaceEnum)untypedValue;
            switch (value)
            {
                case WhiteSpaceEnum.NoWrap:
                    serializer.Serialize(writer, "noWrap");
                    return;
                case WhiteSpaceEnum.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type WhiteSpaceEnum");
        }

        public static readonly WhiteSpaceEnumConverter Singleton = new WhiteSpaceEnumConverter();
    }

    internal class WrapEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WrapEnum) || t == typeof(WrapEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "noWrap":
                    return WrapEnum.NoWrap;
                case "wrap":
                    return WrapEnum.Wrap;
                case "wrapReverse":
                    return WrapEnum.WrapReverse;
            }
            throw new Exception("Cannot unmarshal type WrapEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WrapEnum)untypedValue;
            switch (value)
            {
                case WrapEnum.NoWrap:
                    serializer.Serialize(writer, "noWrap");
                    return;
                case WrapEnum.Wrap:
                    serializer.Serialize(writer, "wrap");
                    return;
                case WrapEnum.WrapReverse:
                    serializer.Serialize(writer, "wrapReverse");
                    return;
            }
            throw new Exception("Cannot marshal type WrapEnum");
        }

        public static readonly WrapEnumConverter Singleton = new WrapEnumConverter();
    }

    internal class HorizontalScrollBarVisibilityEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HorizontalScrollBarVisibilityEnum) || t == typeof(HorizontalScrollBarVisibilityEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alwaysVisible":
                    return HorizontalScrollBarVisibilityEnum.AlwaysVisible;
                case "auto":
                    return HorizontalScrollBarVisibilityEnum.Auto;
                case "hidden":
                    return HorizontalScrollBarVisibilityEnum.Hidden;
            }
            throw new Exception("Cannot unmarshal type HorizontalScrollBarVisibilityEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HorizontalScrollBarVisibilityEnum)untypedValue;
            switch (value)
            {
                case HorizontalScrollBarVisibilityEnum.AlwaysVisible:
                    serializer.Serialize(writer, "alwaysVisible");
                    return;
                case HorizontalScrollBarVisibilityEnum.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case HorizontalScrollBarVisibilityEnum.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
            }
            throw new Exception("Cannot marshal type HorizontalScrollBarVisibilityEnum");
        }

        public static readonly HorizontalScrollBarVisibilityEnumConverter Singleton = new HorizontalScrollBarVisibilityEnumConverter();
    }

    internal class TouchScrollBehaviorEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TouchScrollBehaviorEnum) || t == typeof(TouchScrollBehaviorEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "clamped":
                    return TouchScrollBehaviorEnum.Clamped;
                case "elastic":
                    return TouchScrollBehaviorEnum.Elastic;
                case "unrestricted":
                    return TouchScrollBehaviorEnum.Unrestricted;
            }
            throw new Exception("Cannot unmarshal type TouchScrollBehaviorEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TouchScrollBehaviorEnum)untypedValue;
            switch (value)
            {
                case TouchScrollBehaviorEnum.Clamped:
                    serializer.Serialize(writer, "clamped");
                    return;
                case TouchScrollBehaviorEnum.Elastic:
                    serializer.Serialize(writer, "elastic");
                    return;
                case TouchScrollBehaviorEnum.Unrestricted:
                    serializer.Serialize(writer, "unrestricted");
                    return;
            }
            throw new Exception("Cannot marshal type TouchScrollBehaviorEnum");
        }

        public static readonly TouchScrollBehaviorEnumConverter Singleton = new TouchScrollBehaviorEnumConverter();
    }

    internal class DirectionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DirectionEnum) || t == typeof(DirectionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "horizontal":
                    return DirectionEnum.Horizontal;
                case "vertical":
                    return DirectionEnum.Vertical;
            }
            throw new Exception("Cannot unmarshal type DirectionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DirectionEnum)untypedValue;
            switch (value)
            {
                case DirectionEnum.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case DirectionEnum.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type DirectionEnum");
        }

        public static readonly DirectionEnumConverter Singleton = new DirectionEnumConverter();
    }

    internal class StudioTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StudioType) || t == typeof(StudioType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "enemyIdentityCard":
                    return StudioType.EnemyIdentityCard;
                case "enemyStatus":
                    return StudioType.EnemyStatus;
                case "userIdentityCard":
                    return StudioType.UserIdentityCard;
                case "userStatus":
                    return StudioType.UserStatus;
            }
            throw new Exception("Cannot unmarshal type StudioType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StudioType)untypedValue;
            switch (value)
            {
                case StudioType.EnemyIdentityCard:
                    serializer.Serialize(writer, "enemyIdentityCard");
                    return;
                case StudioType.EnemyStatus:
                    serializer.Serialize(writer, "enemyStatus");
                    return;
                case StudioType.UserIdentityCard:
                    serializer.Serialize(writer, "userIdentityCard");
                    return;
                case StudioType.UserStatus:
                    serializer.Serialize(writer, "userStatus");
                    return;
            }
            throw new Exception("Cannot marshal type StudioType");
        }

        public static readonly StudioTypeConverter Singleton = new StudioTypeConverter();
    }

    internal class ColorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Color) || t == typeof(Color?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "blue":
                    return Color.Blue;
                case "green":
                    return Color.Green;
                case "red":
                    return Color.Red;
            }
            throw new Exception("Cannot unmarshal type Color");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Color)untypedValue;
            switch (value)
            {
                case Color.Blue:
                    serializer.Serialize(writer, "blue");
                    return;
                case Color.Green:
                    serializer.Serialize(writer, "green");
                    return;
                case Color.Red:
                    serializer.Serialize(writer, "red");
                    return;
            }
            throw new Exception("Cannot marshal type Color");
        }

        public static readonly ColorConverter Singleton = new ColorConverter();
    }

    internal class PreviewConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Preview) || t == typeof(Preview?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "none":
                            return new Preview { Enum = PreviewEnum.None };
                        case "pending":
                            return new Preview { Enum = PreviewEnum.Pending };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PreviewClass>(reader);
                    return new Preview { PreviewClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Preview");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Preview)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PreviewEnum.None:
                        serializer.Serialize(writer, "none");
                        return;
                    case PreviewEnum.Pending:
                        serializer.Serialize(writer, "pending");
                        return;
                }
            }
            if (value.PreviewClass != null)
            {
                serializer.Serialize(writer, value.PreviewClass);
                return;
            }
            throw new Exception("Cannot marshal type Preview");
        }

        public static readonly PreviewConverter Singleton = new PreviewConverter();
    }

    internal class PreviewEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PreviewEnum) || t == typeof(PreviewEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "none":
                    return PreviewEnum.None;
                case "pending":
                    return PreviewEnum.Pending;
            }
            throw new Exception("Cannot unmarshal type PreviewEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PreviewEnum)untypedValue;
            switch (value)
            {
                case PreviewEnum.None:
                    serializer.Serialize(writer, "none");
                    return;
                case PreviewEnum.Pending:
                    serializer.Serialize(writer, "pending");
                    return;
            }
            throw new Exception("Cannot marshal type PreviewEnum");
        }

        public static readonly PreviewEnumConverter Singleton = new PreviewEnumConverter();
    }

    internal class ActionUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionUnion) || t == typeof(ActionUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "noOp")
                    {
                        return new ActionUnion { Enum = ActionEnum.NoOp };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleSchema>(reader);
                    return new ActionUnion { PurpleSchema = objectValue };
            }
            throw new Exception("Cannot unmarshal type ActionUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ActionUnion)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == ActionEnum.NoOp)
                {
                    serializer.Serialize(writer, "noOp");
                    return;
                }
            }
            if (value.PurpleSchema != null)
            {
                serializer.Serialize(writer, value.PurpleSchema);
                return;
            }
            throw new Exception("Cannot marshal type ActionUnion");
        }

        public static readonly ActionUnionConverter Singleton = new ActionUnionConverter();
    }

    internal class ResponseTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ResponseType) || t == typeof(ResponseType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "final":
                    return ResponseType.Final;
                case "incremental":
                    return ResponseType.Incremental;
            }
            throw new Exception("Cannot unmarshal type ResponseType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ResponseType)untypedValue;
            switch (value)
            {
                case ResponseType.Final:
                    serializer.Serialize(writer, "final");
                    return;
                case ResponseType.Incremental:
                    serializer.Serialize(writer, "incremental");
                    return;
            }
            throw new Exception("Cannot marshal type ResponseType");
        }

        public static readonly ResponseTypeConverter Singleton = new ResponseTypeConverter();
    }
}
