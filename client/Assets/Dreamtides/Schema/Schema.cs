// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Dreamtides.Schema;
//
//    var schemaTypes = SchemaTypes.FromJson(jsonString);

namespace Dreamtides.Schema
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class SchemaTypes
    {
        [JsonProperty("client_log_request", Required = Required.Always)]
        public ClientLogRequest ClientLogRequest { get; set; }

        [JsonProperty("client_log_response", Required = Required.Always)]
        public ClientLogResponse ClientLogResponse { get; set; }

        [JsonProperty("connect_request", Required = Required.Always)]
        public ConnectRequest ConnectRequest { get; set; }

        [JsonProperty("connect_response", Required = Required.Always)]
        public ConnectResponse ConnectResponse { get; set; }

        [JsonProperty("perform_action_request", Required = Required.Always)]
        public PerformActionRequest PerformActionRequest { get; set; }

        [JsonProperty("perform_action_response", Required = Required.Always)]
        public PerformActionResponse PerformActionResponse { get; set; }

        [JsonProperty("poll_request", Required = Required.Always)]
        public PollRequest PollRequest { get; set; }

        [JsonProperty("poll_response", Required = Required.Always)]
        public PollResponse PollResponse { get; set; }
    }

    public partial class ClientLogRequest
    {
        [JsonProperty("entry", Required = Required.Always)]
        public LogEntry Entry { get; set; }
    }

    public partial class EventSpan
    {
        [JsonProperty("entries", Required = Required.Always)]
        public List<LogEntry> Entries { get; set; }

        [JsonProperty("name", Required = Required.Always)]
        public LogSpanName Name { get; set; }
    }

    public partial class LogEntry
    {
        [JsonProperty("Event", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Event Event { get; set; }

        [JsonProperty("EventSpan", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public EventSpan EventSpan { get; set; }
    }

    public partial class Event
    {
        [JsonProperty("log_type", Required = Required.Always)]
        public LogType LogType { get; set; }

        [JsonProperty("message", Required = Required.Always)]
        public string Message { get; set; }
    }

    public partial class ClientLogResponse
    {
        [JsonProperty("success", Required = Required.Always)]
        public bool Success { get; set; }
    }

    public partial class ConnectRequest
    {
        /// <summary>
        /// If specified, the battle will be created with the given debug
        /// configuration.
        /// </summary>
        [JsonProperty("debug_configuration")]
        public DebugConfiguration DebugConfiguration { get; set; }

        /// <summary>
        /// Display properties from the client (screen dimensions, mobile device
        /// flag, etc.)
        /// </summary>
        [JsonProperty("display_properties")]
        public DisplayProperties DisplayProperties { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        /// <summary>
        /// Contains the path to a persistent data directory.
        ///
        /// When you build the Unity application, a GUID is generated that is based
        /// on the Bundle Identifier. This GUID is part of persistentDataPath. If
        /// you keep the same Bundle Identifier in future versions, the application
        /// keeps accessing the same location on every update.
        /// </summary>
        [JsonProperty("persistent_data_path", Required = Required.Always)]
        public string PersistentDataPath { get; set; }

        /// <summary>
        /// If specified, treats this as a multiplayer game using the save file
        /// provided in this ID and adds this user as a player in the battle.
        /// </summary>
        [JsonProperty("vs_opponent")]
        public Guid? VsOpponent { get; set; }
    }

    public partial class DebugConfiguration
    {
        /// <summary>
        /// If specified, the enemy will be this player type.
        /// </summary>
        [JsonProperty("enemy")]
        public PlayerType Enemy { get; set; }

        /// <summary>
        /// If specified, the battle will be seeded with the given value. Otherwise
        /// a random seed will be used.
        /// </summary>
        [JsonProperty("seed")]
        public long? Seed { get; set; }
    }

    public partial class PlayerType
    {
        [JsonProperty("User", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Guid? User { get; set; }

        [JsonProperty("Agent", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public GameAi? Agent { get; set; }
    }

    public partial class GameAiClass
    {
        [JsonProperty("MonteCarlo", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? MonteCarlo { get; set; }

        [JsonProperty("MonteCarloSingleThreaded", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? MonteCarloSingleThreaded { get; set; }
    }

    public partial class DisplayProperties
    {
        [JsonProperty("is_mobile_device", Required = Required.Always)]
        public bool IsMobileDevice { get; set; }

        [JsonProperty("screen_height", Required = Required.Always)]
        public long ScreenHeight { get; set; }

        [JsonProperty("screen_width", Required = Required.Always)]
        public long ScreenWidth { get; set; }
    }

    public partial class Metadata
    {
        /// <summary>
        /// ID of the current battle.
        /// </summary>
        [JsonProperty("battle_id")]
        public Guid? BattleId { get; set; }

        /// <summary>
        /// If specified, the request is part of an integration test with the given
        /// ID. State will not be persisted.
        /// </summary>
        [JsonProperty("integration_test_id")]
        public Guid? IntegrationTestId { get; set; }

        /// <summary>
        /// Identifies the request from the client.
        /// </summary>
        [JsonProperty("request_id")]
        public Guid? RequestId { get; set; }

        /// <summary>
        /// ID of the user making the request.
        /// </summary>
        [JsonProperty("user_id", Required = Required.Always)]
        public Guid UserId { get; set; }
    }

    public partial class ConnectResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        [JsonProperty("response_version", Required = Required.Always)]
        public Guid ResponseVersion { get; set; }
    }

    /// <summary>
    /// A list of [ParallelCommandGroup]s to execute sequentially.
    /// </summary>
    public partial class CommandSequence
    {
        [JsonProperty("groups", Required = Required.Always)]
        public List<ParallelCommandGroup> Groups { get; set; }
    }

    /// <summary>
    /// A set of [Command]s to execute simultaneously.
    /// </summary>
    public partial class ParallelCommandGroup
    {
        [JsonProperty("commands", Required = Required.Always)]
        public List<Command> Commands { get; set; }
    }

    /// <summary>
    /// Represents an animated update to the visual state of the game.
    /// </summary>
    public partial class Command
    {
        [JsonProperty("UpdateBattle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public UpdateBattleCommand UpdateBattle { get; set; }

        [JsonProperty("Wait", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Milliseconds Wait { get; set; }

        [JsonProperty("FireProjectile", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FireProjectileCommand FireProjectile { get; set; }

        [JsonProperty("DissolveCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DissolveCardCommand DissolveCard { get; set; }

        [JsonProperty("DisplayGameMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public GameMessageType? DisplayGameMessage { get; set; }

        [JsonProperty("DisplayEffect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEffectCommand DisplayEffect { get; set; }

        [JsonProperty("PlayAudioClip", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PlayAudioClipCommand PlayAudioClip { get; set; }

        [JsonProperty("DrawUserCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawUserCardsCommand DrawUserCards { get; set; }

        [JsonProperty("DisplayJudgment", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayJudgmentCommand DisplayJudgment { get; set; }

        [JsonProperty("DisplayDreamwellActivation", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayDreamwellActivationCommand DisplayDreamwellActivation { get; set; }

        [JsonProperty("DisplayEnemyMessage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayEnemyMessageCommand DisplayEnemyMessage { get; set; }

        [JsonProperty("PlayStudioAnimation", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PlayStudioAnimationCommand PlayStudioAnimation { get; set; }
    }

    public partial class DisplayDreamwellActivationCommand
    {
        /// <summary>
        /// The card to display an activation for. This card will be moved from its
        /// current position (assumed to be the 'Dreamwell' position) to the
        /// DreamwellActivation position, and an update to the player's produced
        /// energy value will be displayed.
        ///
        /// If there are triggered events as a result of this activation, the card
        /// should be kept in the DreamwellActivation position for the next
        /// update. Otherwise it's typical to return the card to the Dreamwell
        /// position.
        /// </summary>
        [JsonProperty("card_id", Required = Required.Always)]
        public string CardId { get; set; }

        /// <summary>
        /// New energy available to this player, if it has changed.
        /// </summary>
        [JsonProperty("new_energy")]
        public long? NewEnergy { get; set; }

        /// <summary>
        /// New energy produced by this player at the start of the turn, if it has
        /// changed.
        /// </summary>
        [JsonProperty("new_produced_energy")]
        public long? NewProducedEnergy { get; set; }

        /// <summary>
        /// The player to display the dreamwell activation for.
        /// </summary>
        [JsonProperty("player", Required = Required.Always)]
        public DisplayPlayer Player { get; set; }
    }

    public partial class DisplayEffectCommand
    {
        /// <summary>
        /// How long to wait before continuing with animations.
        /// </summary>
        [JsonProperty("duration", Required = Required.Always)]
        public Milliseconds Duration { get; set; }

        /// <summary>
        /// The effect to display.
        /// </summary>
        [JsonProperty("effect", Required = Required.Always)]
        public EffectAddress Effect { get; set; }

        /// <summary>
        /// Local scale to apply to this effect
        /// </summary>
        [JsonProperty("scale", Required = Required.Always)]
        public FlexVector3 Scale { get; set; }

        /// <summary>
        /// Sound to play along with effect
        /// </summary>
        [JsonProperty("sound")]
        public AudioClipAddress Sound { get; set; }

        /// <summary>
        /// The target to display the effect on.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public GameObjectId Target { get; set; }
    }

    /// <summary>
    /// How long to wait before continuing with animations.
    ///
    /// How long to pause before continuing with animations.
    ///
    /// Time to display each card before moving it to hand.
    ///
    /// Should be less than stagger_interval for best results.
    ///
    /// Time to wait between drawing subsequent cards.
    /// </summary>
    public partial class Milliseconds
    {
        [JsonProperty("milliseconds_value", Required = Required.Always)]
        public long MillisecondsValue { get; set; }
    }

    /// <summary>
    /// The effect to display.
    /// </summary>
    public partial class EffectAddress
    {
        [JsonProperty("effect", Required = Required.Always)]
        public string Effect { get; set; }
    }

    /// <summary>
    /// Local scale to apply to this effect
    /// </summary>
    public partial class FlexVector3
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    /// <summary>
    /// Sound to play
    /// </summary>
    public partial class AudioClipAddress
    {
        [JsonProperty("audio_clip", Required = Required.Always)]
        public string AudioClip { get; set; }
    }

    /// <summary>
    /// The target to display the effect on.
    /// </summary>
    public partial class GameObjectId
    {
        [JsonProperty("CardId", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string CardId { get; set; }

        [JsonProperty("Deck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Deck { get; set; }

        [JsonProperty("Void", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Void { get; set; }

        [JsonProperty("Avatar", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? Avatar { get; set; }
    }

    public partial class DisplayEnemyMessageCommand
    {
        [JsonProperty("message", Required = Required.Always)]
        public string Message { get; set; }

        [JsonProperty("show_duration", Required = Required.Always)]
        public Milliseconds ShowDuration { get; set; }
    }

    public partial class DisplayJudgmentCommand
    {
        /// <summary>
        /// The new score for the player, if it has changed.
        /// </summary>
        [JsonProperty("new_score")]
        public long? NewScore { get; set; }

        /// <summary>
        /// The player to display the judgment animation for.
        /// </summary>
        [JsonProperty("player", Required = Required.Always)]
        public DisplayPlayer Player { get; set; }
    }

    public partial class DissolveCardCommand
    {
        /// <summary>
        /// The color to use for the dissolve effect.
        /// </summary>
        [JsonProperty("color", Required = Required.Always)]
        public DisplayColor Color { get; set; }

        /// <summary>
        /// The speed multiplier of the dissolve effect. Defaults to 1.
        /// </summary>
        [JsonProperty("dissolve_speed")]
        public double? DissolveSpeed { get; set; }

        /// <summary>
        /// The material to use for the dissolve effect.
        /// </summary>
        [JsonProperty("material", Required = Required.Always)]
        public MaterialAddress Material { get; set; }

        /// <summary>
        /// If true, dissolve will be played backwards to "create" the card.
        /// </summary>
        [JsonProperty("reverse", Required = Required.Always)]
        public bool Reverse { get; set; }

        /// <summary>
        /// Sound to play
        /// </summary>
        [JsonProperty("sound")]
        public AudioClipAddress Sound { get; set; }

        /// <summary>
        /// The card to dissolve.
        ///
        /// Once a card is dissolved, it will be invisible until a reverse dissolve
        /// is applied to it.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public string Target { get; set; }
    }

    /// <summary>
    /// Represents a color with the given RGBA values represented as floats in the
    /// 0-1 range.
    ///
    /// The color to use for the dissolve effect.
    /// </summary>
    public partial class DisplayColor
    {
        [JsonProperty("alpha", Required = Required.Always)]
        public double Alpha { get; set; }

        [JsonProperty("blue", Required = Required.Always)]
        public double Blue { get; set; }

        [JsonProperty("green", Required = Required.Always)]
        public double Green { get; set; }

        [JsonProperty("red", Required = Required.Always)]
        public double Red { get; set; }
    }

    /// <summary>
    /// The material to use for the dissolve effect.
    /// </summary>
    public partial class MaterialAddress
    {
        [JsonProperty("material", Required = Required.Always)]
        public string Material { get; set; }
    }

    public partial class DrawUserCardsCommand
    {
        /// <summary>
        /// Cards to draw. Must already be present in user deck.
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardView> Cards { get; set; }

        /// <summary>
        /// Time to display each card before moving it to hand.
        ///
        /// Should be less than stagger_interval for best results.
        /// </summary>
        [JsonProperty("pause_duration", Required = Required.Always)]
        public Milliseconds PauseDuration { get; set; }

        /// <summary>
        /// Time to wait between drawing subsequent cards.
        /// </summary>
        [JsonProperty("stagger_interval", Required = Required.Always)]
        public Milliseconds StaggerInterval { get; set; }
    }

    /// <summary>
    /// Represents the visual state of a card or ability in a game
    /// </summary>
    public partial class CardView
    {
        /// <summary>
        /// True if this card is initially revealed and thus should not play the
        /// 'flip' animation from its back side.
        /// </summary>
        [JsonProperty("backless", Required = Required.Always)]
        public bool Backless { get; set; }

        /// <summary>
        /// Face up/face down state for this card
        /// </summary>
        [JsonProperty("card_facing", Required = Required.Always)]
        public CardFacing CardFacing { get; set; }

        /// <summary>
        /// Optionally, a position at which to create this card.
        ///
        /// If this card does not already exist, it will be created at this position
        /// before being animated to [Self::position].
        /// </summary>
        [JsonProperty("create_position")]
        public ObjectPosition CreatePosition { get; set; }

        /// <summary>
        /// Optionally, a sound to play when this card is created.
        /// </summary>
        [JsonProperty("create_sound")]
        public AudioClipAddress CreateSound { get; set; }

        /// <summary>
        /// Optionally, a position at which to destroy this card.
        ///
        /// If provided, the card will be animated to this position before being
        /// destroyed.
        /// </summary>
        [JsonProperty("destroy_position")]
        public ObjectPosition DestroyPosition { get; set; }

        /// <summary>
        /// Identifier for this card
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public string Id { get; set; }

        /// <summary>
        /// Position of this card in the UI
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public ObjectPosition Position { get; set; }

        /// <summary>
        /// Represents the general category of card being displayed.
        /// </summary>
        [JsonProperty("prefab", Required = Required.Always)]
        public CardPrefab Prefab { get; set; }

        /// <summary>
        /// If this card is revealed to the viewer, contains information on the
        /// revealed face of the card.
        /// </summary>
        [JsonProperty("revealed")]
        public RevealedCardView Revealed { get; set; }

        /// <summary>
        /// True if this card is in a hidden zone but known to one or more opponents
        /// </summary>
        [JsonProperty("revealed_to_opponents", Required = Required.Always)]
        public bool RevealedToOpponents { get; set; }
    }

    /// <summary>
    /// Represents the position of some object in the UI
    ///
    /// Position of this card in the UI
    /// </summary>
    public partial class ObjectPosition
    {
        /// <summary>
        /// Position category
        /// </summary>
        [JsonProperty("position", Required = Required.Always)]
        public Position Position { get; set; }

        /// <summary>
        /// Sorting key, determines order within the position
        /// </summary>
        [JsonProperty("sorting_key", Required = Required.Always)]
        public long SortingKey { get; set; }
    }

    /// <summary>
    /// Object is on the stack, typically used by cards which were just played.
    ///
    /// There are four types of stacks. By default, cards display at a large
    /// display size, blocking the view of the battlefield. However, if any
    /// cards are present on the stack which target a character on the
    /// battlefield, the cards are displayed at a smaller size in order to
    /// enable viewing & selecting targets appropriately, based on the set of
    /// cards which are current or eligible targets.
    ///
    /// Object is in a player's hand
    ///
    /// Object is shuffled into a player's deck
    ///
    /// Object is in a player's void
    ///
    /// Object is in this player's banished zone
    ///
    /// Object is on the battlefield
    ///
    /// Object is in a player's status zone
    ///
    /// Object is being displayed in a selector to determine the order of cards,
    /// e.g. when resolving the "forsee" effect.
    ///
    /// Object is in the dreamwell for a player (usually off-screen).
    ///
    /// Object is hidden within a card
    ///
    /// Object is above the void, used to display void cards which are currently
    /// being targeted.
    /// </summary>
    public partial class PositionClass
    {
        [JsonProperty("OnStack", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public StackType? OnStack { get; set; }

        [JsonProperty("InHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InHand { get; set; }

        [JsonProperty("InDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InDeck { get; set; }

        [JsonProperty("InVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InVoid { get; set; }

        [JsonProperty("InBanished", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InBanished { get; set; }

        [JsonProperty("OnBattlefield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? OnBattlefield { get; set; }

        [JsonProperty("InPlayerStatus", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InPlayerStatus { get; set; }

        [JsonProperty("CardOrderSelector", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardOrderSelectionTargetDiscriminants? CardOrderSelector { get; set; }

        [JsonProperty("InDreamwell", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? InDreamwell { get; set; }

        [JsonProperty("HiddenWithinCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string HiddenWithinCard { get; set; }

        [JsonProperty("AboveVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPlayer? AboveVoid { get; set; }
    }

    /// <summary>
    /// Visual state of a revealed card
    /// </summary>
    public partial class RevealedCardView
    {
        /// <summary>
        /// Actions available for this card
        /// </summary>
        [JsonProperty("actions", Required = Required.Always)]
        public CardActions Actions { get; set; }

        /// <summary>
        /// Type or subtype of this card
        /// </summary>
        [JsonProperty("card_type", Required = Required.Always)]
        public string CardType { get; set; }

        /// <summary>
        /// Cost of this card
        /// </summary>
        [JsonProperty("cost")]
        public string Cost { get; set; }

        /// <summary>
        /// Special effects to display for this card
        /// </summary>
        [JsonProperty("effects", Required = Required.Always)]
        public CardEffects Effects { get; set; }

        /// <summary>
        /// Image for this card
        /// </summary>
        [JsonProperty("image", Required = Required.Always)]
        public DisplayImage Image { get; set; }

        /// <summary>
        /// Data providing supplemental information about this card on long
        /// press/hover.
        /// </summary>
        [JsonProperty("info_zoom_data")]
        public InfoZoomData InfoZoomData { get; set; }

        /// <summary>
        /// True if this card can be played during the opponent's turn
        /// </summary>
        [JsonProperty("is_fast", Required = Required.Always)]
        public bool IsFast { get; set; }

        /// <summary>
        /// Name of this card
        /// </summary>
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }

        /// <summary>
        /// Outline color of this card
        /// </summary>
        [JsonProperty("outline_color")]
        public DisplayColor OutlineColor { get; set; }

        /// <summary>
        /// Energy produced by this card
        /// </summary>
        [JsonProperty("produced")]
        public string Produced { get; set; }

        /// <summary>
        /// Rules text to display for this car
        /// </summary>
        [JsonProperty("rules_text", Required = Required.Always)]
        public string RulesText { get; set; }

        /// <summary>
        /// Spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public string Spark { get; set; }
    }

    /// <summary>
    /// Actions available for this card
    /// </summary>
    public partial class CardActions
    {
        /// <summary>
        /// If this card can currently be played from hand, an action to invoke when
        /// played.
        /// </summary>
        [JsonProperty("can_play")]
        public ActionUnion? CanPlay { get; set; }

        /// <summary>
        /// If this card can currently be dragged within a Card Order Selector, the
        /// card ID to use when selecting order.
        /// </summary>
        [JsonProperty("can_select_order")]
        public long? CanSelectOrder { get; set; }

        /// <summary>
        /// Action to perform when this card is clicked.
        /// </summary>
        [JsonProperty("on_click")]
        public ActionUnion? OnClick { get; set; }

        /// <summary>
        /// Sound to play when this card is played.
        /// </summary>
        [JsonProperty("on_play_sound")]
        public AudioClipAddress OnPlaySound { get; set; }

        /// <summary>
        /// Preview of the battle state after this card is played.
        /// </summary>
        [JsonProperty("play_effect_preview")]
        public BattlePreviewView PlayEffectPreview { get; set; }
    }

    public partial class ActionClass
    {
        [JsonProperty("DebugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("BattleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? BattleAction { get; set; }

        [JsonProperty("BattleDisplayAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleDisplayAction? BattleDisplayAction { get; set; }

        [JsonProperty("Undo", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PlayerName? Undo { get; set; }
    }

    /// <summary>
    /// Developer action
    ///
    /// Play a card in the user's hand using the standard play action.
    ///
    /// Play a card in the user's void using the given ability.
    ///
    /// Activate a character's ability.
    ///
    /// Select a character as a target
    ///
    /// Select a card on the stack as a target
    ///
    /// Select a card in a void as a target
    ///
    /// Select a choice at a given index position in response to a prompt.
    ///
    /// Pick an amount of energy to pay as an additional cost to play a card.
    ///
    /// Sets the position of a card in a card order selector.
    ///
    /// Select a modal effect choice for an effect or item on the stack
    /// </summary>
    public partial class BattleActionClass
    {
        [JsonProperty("Debug", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugBattleAction? Debug { get; set; }

        [JsonProperty("PlayCardFromHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? PlayCardFromHand { get; set; }

        [JsonProperty("PlayCardFromVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<PlayCardFromVoid> PlayCardFromVoid { get; set; }

        [JsonProperty("ActivateAbility", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ActivatedAbilityId ActivateAbility { get; set; }

        [JsonProperty("SelectCharacterTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectCharacterTarget { get; set; }

        [JsonProperty("SelectStackCardTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectStackCardTarget { get; set; }

        [JsonProperty("SelectVoidCardTarget", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectVoidCardTarget { get; set; }

        [JsonProperty("SelectPromptChoice", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectPromptChoice { get; set; }

        [JsonProperty("SelectEnergyAdditionalCost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectEnergyAdditionalCost { get; set; }

        [JsonProperty("SelectOrderForDeckCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DeckCardSelectedOrder SelectOrderForDeckCard { get; set; }

        [JsonProperty("SelectModalEffectChoice", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SelectModalEffectChoice { get; set; }
    }

    /// <summary>
    /// Identifies an activated ability of a character.
    /// </summary>
    public partial class ActivatedAbilityId
    {
        [JsonProperty("ability_number", Required = Required.Always)]
        public long AbilityNumber { get; set; }

        [JsonProperty("character_id", Required = Required.Always)]
        public long CharacterId { get; set; }
    }

    /// <summary>
    /// Draw a card
    ///
    /// Set the energy of the player
    ///
    /// Set the points total of the player
    ///
    /// Set the produced energy of the player
    ///
    /// Set the spark bonus of the player
    ///
    /// Add a specific card to hand
    ///
    /// Add a specific card to battlefield
    ///
    /// Add a specific card to void
    ///
    /// Move all cards from hand to deck
    ///
    /// Set the number of cards remaining in a player's deck. All other cards
    /// are moved to the void.
    ///
    /// Play a card for the opponent, with prompt choices
    /// </summary>
    public partial class DebugBattleActionClass
    {
        [JsonProperty("DrawCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DrawCard DrawCard { get; set; }

        [JsonProperty("SetEnergy", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SetEnergy SetEnergy { get; set; }

        [JsonProperty("SetPoints", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SetPoints SetPoints { get; set; }

        [JsonProperty("SetProducedEnergy", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SetProducedEnergy SetProducedEnergy { get; set; }

        [JsonProperty("SetSparkBonus", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SetSparkBonus SetSparkBonus { get; set; }

        [JsonProperty("AddCardToHand", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public AddCardToHand AddCardToHand { get; set; }

        [JsonProperty("AddCardToBattlefield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public AddCardToBattlefield AddCardToBattlefield { get; set; }

        [JsonProperty("AddCardToVoid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public AddCardToVoid AddCardToVoid { get; set; }

        [JsonProperty("MoveHandToDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public MoveHandToDeck MoveHandToDeck { get; set; }

        [JsonProperty("SetCardsRemainingInDeck", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SetCardsRemainingInDeck SetCardsRemainingInDeck { get; set; }

        [JsonProperty("OpponentPlayCard", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public OpponentPlayCard OpponentPlayCard { get; set; }
    }

    public partial class AddCardToBattlefield
    {
        [JsonProperty("card", Required = Required.Always)]
        public CardName Card { get; set; }

        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class AddCardToHand
    {
        [JsonProperty("card", Required = Required.Always)]
        public CardName Card { get; set; }

        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class AddCardToVoid
    {
        [JsonProperty("card", Required = Required.Always)]
        public CardName Card { get; set; }

        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class DrawCard
    {
        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class MoveHandToDeck
    {
        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class OpponentPlayCard
    {
        [JsonProperty("card", Required = Required.Always)]
        public CardName Card { get; set; }
    }

    public partial class SetCardsRemainingInDeck
    {
        [JsonProperty("cards", Required = Required.Always)]
        public long Cards { get; set; }

        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class SetEnergy
    {
        [JsonProperty("energy", Required = Required.Always)]
        public long Energy { get; set; }

        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class SetPoints
    {
        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }

        [JsonProperty("points", Required = Required.Always)]
        public long Points { get; set; }
    }

    public partial class SetProducedEnergy
    {
        [JsonProperty("energy", Required = Required.Always)]
        public long Energy { get; set; }

        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }
    }

    public partial class SetSparkBonus
    {
        [JsonProperty("player", Required = Required.Always)]
        public PlayerName Player { get; set; }

        [JsonProperty("spark", Required = Required.Always)]
        public long Spark { get; set; }
    }

    /// <summary>
    /// Identifies an ability of a card.
    /// </summary>
    public partial class AbilityId
    {
        [JsonProperty("ability_number", Required = Required.Always)]
        public long AbilityNumber { get; set; }

        [JsonProperty("card_id", Required = Required.Always)]
        public long CardId { get; set; }
    }

    public partial class DeckCardSelectedOrder
    {
        [JsonProperty("card_id", Required = Required.Always)]
        public long CardId { get; set; }

        [JsonProperty("target", Required = Required.Always)]
        public CardOrderSelectionTarget Target { get; set; }
    }

    public partial class CardOrderSelectionTargetClass
    {
        [JsonProperty("Deck", Required = Required.Always)]
        public long Deck { get; set; }
    }

    /// <summary>
    /// Sets the selected amount of energy to pay as an additional cost to play
    /// a card.
    ///
    /// Opens a panel based on its address.
    /// </summary>
    public partial class BattleDisplayActionClass
    {
        [JsonProperty("BrowseCards", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CardBrowserType? BrowseCards { get; set; }

        [JsonProperty("SetSelectedEnergyAdditionalCost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? SetSelectedEnergyAdditionalCost { get; set; }

        [JsonProperty("OpenPanel", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PanelAddress? OpenPanel { get; set; }
    }

    public partial class PanelAddressClass
    {
        [JsonProperty("ViewLogs", Required = Required.AllowNull)]
        public string ViewLogs { get; set; }
    }

    public partial class DebugActionClass
    {
        [JsonProperty("RestartBattleWithDecks", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public RestartBattleWithDecks RestartBattleWithDecks { get; set; }

        [JsonProperty("SetOpponentAgent", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public GameAi? SetOpponentAgent { get; set; }

        [JsonProperty("ApplyActionList", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<DebugBattleAction> ApplyActionList { get; set; }

        [JsonProperty("CloseCurrentPanelApplyAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugBattleAction? CloseCurrentPanelApplyAction { get; set; }

        [JsonProperty("PerformOpponentAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? PerformOpponentAction { get; set; }
    }

    public partial class RestartBattleWithDecks
    {
        [JsonProperty("one", Required = Required.Always)]
        public TestDeckName One { get; set; }

        [JsonProperty("two", Required = Required.Always)]
        public TestDeckName Two { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a battle, shown e.g. in response to a
    /// card being selected to be played.
    /// </summary>
    public partial class BattlePreviewView
    {
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardPreviewView> Cards { get; set; }

        [JsonProperty("enemy", Required = Required.Always)]
        public PlayerPreviewView Enemy { get; set; }

        [JsonProperty("preview_message")]
        public FlexNode PreviewMessage { get; set; }

        [JsonProperty("user", Required = Required.Always)]
        public PlayerPreviewView User { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a card.
    /// </summary>
    public partial class CardPreviewView
    {
        /// <summary>
        /// Icon to display over this card on the battlefield
        /// </summary>
        [JsonProperty("battlefield_icon")]
        public string BattlefieldIcon { get; set; }

        /// <summary>
        /// Color of the battlefield icon
        /// </summary>
        [JsonProperty("battlefield_icon_color")]
        public DisplayColor BattlefieldIconColor { get; set; }

        /// <summary>
        /// Identifier for this card
        /// </summary>
        [JsonProperty("card_id", Required = Required.Always)]
        public string CardId { get; set; }

        /// <summary>
        /// New cost value for this card
        /// </summary>
        [JsonProperty("cost")]
        public string Cost { get; set; }

        /// <summary>
        /// New spark value for this card
        /// </summary>
        [JsonProperty("spark")]
        public string Spark { get; set; }
    }

    /// <summary>
    /// Preview of a potential future state of a player
    /// </summary>
    public partial class PlayerPreviewView
    {
        /// <summary>
        /// New energy available to this player
        /// </summary>
        [JsonProperty("energy")]
        public long? Energy { get; set; }

        /// <summary>
        /// New energy produced total
        /// </summary>
        [JsonProperty("produced_energy")]
        public long? ProducedEnergy { get; set; }

        /// <summary>
        /// New score total
        /// </summary>
        [JsonProperty("score")]
        public long? Score { get; set; }

        /// <summary>
        /// New total spark for this player
        /// </summary>
        [JsonProperty("total_spark")]
        public long? TotalSpark { get; set; }
    }

    public partial class DraggableNode
    {
        [JsonProperty("custom_drag_indicator")]
        public FlexNode CustomDragIndicator { get; set; }

        [JsonProperty("drop_target_identifiers", Required = Required.Always)]
        public List<string> DropTargetIdentifiers { get; set; }

        [JsonProperty("hide_indicator_children", Required = Required.Always)]
        public List<string> HideIndicatorChildren { get; set; }

        [JsonProperty("horizontal_drag_start_distance")]
        public long? HorizontalDragStartDistance { get; set; }

        [JsonProperty("on_drag_detected")]
        public ActionUnion? OnDragDetected { get; set; }

        [JsonProperty("on_drop")]
        public ActionUnion? OnDrop { get; set; }

        [JsonProperty("over_target_indicator")]
        public FlexNode OverTargetIndicator { get; set; }

        [JsonProperty("remove_original")]
        public bool? RemoveOriginal { get; set; }
    }

    public partial class NodeType
    {
        [JsonProperty("Text", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TextNode Text { get; set; }

        [JsonProperty("ScrollViewNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ScrollViewNode ScrollViewNode { get; set; }

        [JsonProperty("DraggableNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DraggableNode DraggableNode { get; set; }

        [JsonProperty("TextFieldNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TextFieldNode TextFieldNode { get; set; }

        [JsonProperty("SliderNode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SliderNode SliderNode { get; set; }
    }

    public partial class FlexNode
    {
        [JsonProperty("children", Required = Required.Always)]
        public List<FlexNode> Children { get; set; }

        [JsonProperty("event_handlers")]
        public EventHandlers EventHandlers { get; set; }

        [JsonProperty("hover_style")]
        public FlexStyle HoverStyle { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("node_type")]
        public NodeType NodeType { get; set; }

        /// <summary>
        /// Style to apply to the element when it is first attached to a panel.
        /// </summary>
        [JsonProperty("on_attach_style")]
        public FlexStyle OnAttachStyle { get; set; }

        /// <summary>
        /// How long to keep the `on_attach_style` applied.
        ///
        /// If not specified, the style will be applied indefinitely.
        /// </summary>
        [JsonProperty("on_attach_style_duration")]
        public Milliseconds OnAttachStyleDuration { get; set; }

        [JsonProperty("pressed_style")]
        public FlexStyle PressedStyle { get; set; }

        [JsonProperty("style")]
        public FlexStyle Style { get; set; }
    }

    public partial class ScrollViewNode
    {
        [JsonProperty("elasticity")]
        public double? Elasticity { get; set; }

        [JsonProperty("horizontal_page_size")]
        public double? HorizontalPageSize { get; set; }

        [JsonProperty("horizontal_scroll_bar")]
        public ScrollBar HorizontalScrollBar { get; set; }

        [JsonProperty("horizontal_scroll_bar_visibility")]
        public ScrollBarVisibility? HorizontalScrollBarVisibility { get; set; }

        [JsonProperty("mouse_wheel_scroll_size")]
        public double? MouseWheelScrollSize { get; set; }

        [JsonProperty("scroll_deceleration_rate")]
        public double? ScrollDecelerationRate { get; set; }

        [JsonProperty("touch_scroll_behavior")]
        public TouchScrollBehavior? TouchScrollBehavior { get; set; }

        [JsonProperty("vertical_page_size")]
        public double? VerticalPageSize { get; set; }

        [JsonProperty("vertical_scroll_bar")]
        public ScrollBar VerticalScrollBar { get; set; }

        [JsonProperty("vertical_scroll_bar_visibility")]
        public ScrollBarVisibility? VerticalScrollBarVisibility { get; set; }
    }

    public partial class ScrollBar
    {
        [JsonProperty("style")]
        public FlexStyle Style { get; set; }
    }

    public partial class FlexStyle
    {
        [JsonProperty("align_content")]
        public FlexAlign? AlignContent { get; set; }

        [JsonProperty("align_items")]
        public FlexAlign? AlignItems { get; set; }

        [JsonProperty("align_self")]
        public FlexAlign? AlignSelf { get; set; }

        [JsonProperty("background_color")]
        public DisplayColor BackgroundColor { get; set; }

        [JsonProperty("background_image")]
        public SpriteAddress BackgroundImage { get; set; }

        [JsonProperty("background_image_tint_color")]
        public DisplayColor BackgroundImageTintColor { get; set; }

        [JsonProperty("border_color")]
        public BorderColor BorderColor { get; set; }

        [JsonProperty("border_radius")]
        public BorderRadius BorderRadius { get; set; }

        [JsonProperty("border_width")]
        public BorderWidth BorderWidth { get; set; }

        [JsonProperty("color")]
        public DisplayColor Color { get; set; }

        [JsonProperty("display")]
        public FlexDisplayStyle? Display { get; set; }

        [JsonProperty("flex_basis")]
        public Dimension FlexBasis { get; set; }

        [JsonProperty("flex_direction")]
        public FlexDirection? FlexDirection { get; set; }

        [JsonProperty("flex_grow")]
        public double? FlexGrow { get; set; }

        [JsonProperty("flex_shrink")]
        public double? FlexShrink { get; set; }

        [JsonProperty("font")]
        public FontAddress Font { get; set; }

        [JsonProperty("font_size")]
        public Dimension FontSize { get; set; }

        [JsonProperty("font_style")]
        public FontStyle? FontStyle { get; set; }

        [JsonProperty("height")]
        public Dimension Height { get; set; }

        [JsonProperty("image_slice")]
        public ImageSlice ImageSlice { get; set; }

        [JsonProperty("inset")]
        public FlexInsets Inset { get; set; }

        [JsonProperty("justify_content")]
        public FlexJustify? JustifyContent { get; set; }

        [JsonProperty("letter_spacing")]
        public Dimension LetterSpacing { get; set; }

        [JsonProperty("margin")]
        public DimensionGroup Margin { get; set; }

        [JsonProperty("max_height")]
        public Dimension MaxHeight { get; set; }

        [JsonProperty("max_width")]
        public Dimension MaxWidth { get; set; }

        [JsonProperty("min_height")]
        public Dimension MinHeight { get; set; }

        [JsonProperty("min_width")]
        public Dimension MinWidth { get; set; }

        [JsonProperty("opacity")]
        public double? Opacity { get; set; }

        [JsonProperty("overflow")]
        public FlexVisibility? Overflow { get; set; }

        [JsonProperty("overflow_clip_box")]
        public OverflowClipBox? OverflowClipBox { get; set; }

        [JsonProperty("padding")]
        public DimensionGroup Padding { get; set; }

        [JsonProperty("paragraph_spacing")]
        public Dimension ParagraphSpacing { get; set; }

        [JsonProperty("picking_mode")]
        public FlexPickingMode? PickingMode { get; set; }

        [JsonProperty("position")]
        public FlexPosition? Position { get; set; }

        [JsonProperty("rotate")]
        public FlexRotate Rotate { get; set; }

        [JsonProperty("scale")]
        public FlexScale Scale { get; set; }

        [JsonProperty("text_align")]
        public TextAlign? TextAlign { get; set; }

        [JsonProperty("text_outline_color")]
        public DisplayColor TextOutlineColor { get; set; }

        [JsonProperty("text_outline_width")]
        public double? TextOutlineWidth { get; set; }

        [JsonProperty("text_overflow")]
        public TextOverflow? TextOverflow { get; set; }

        [JsonProperty("text_overflow_position")]
        public TextOverflowPosition? TextOverflowPosition { get; set; }

        [JsonProperty("text_shadow")]
        public TextShadow TextShadow { get; set; }

        [JsonProperty("transform_origin")]
        public FlexTranslate TransformOrigin { get; set; }

        [JsonProperty("transition_delays", Required = Required.Always)]
        public List<Milliseconds> TransitionDelays { get; set; }

        [JsonProperty("transition_durations", Required = Required.Always)]
        public List<Milliseconds> TransitionDurations { get; set; }

        [JsonProperty("transition_easing_modes", Required = Required.Always)]
        public List<EasingMode> TransitionEasingModes { get; set; }

        [JsonProperty("transition_properties", Required = Required.Always)]
        public List<string> TransitionProperties { get; set; }

        [JsonProperty("translate")]
        public FlexTranslate Translate { get; set; }

        [JsonProperty("visibility")]
        public FlexVisibility? Visibility { get; set; }

        [JsonProperty("white_space")]
        public WhiteSpace? WhiteSpace { get; set; }

        [JsonProperty("width")]
        public Dimension Width { get; set; }

        [JsonProperty("word_spacing")]
        public Dimension WordSpacing { get; set; }

        [JsonProperty("wrap")]
        public FlexWrap? Wrap { get; set; }
    }

    public partial class SpriteAddress
    {
        [JsonProperty("sprite", Required = Required.Always)]
        public string Sprite { get; set; }
    }

    public partial class BorderColor
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public DisplayColor Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public DisplayColor Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public DisplayColor Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public DisplayColor Top { get; set; }
    }

    public partial class BorderRadius
    {
        [JsonProperty("bottom_left", Required = Required.Always)]
        public Dimension BottomLeft { get; set; }

        [JsonProperty("bottom_right", Required = Required.Always)]
        public Dimension BottomRight { get; set; }

        [JsonProperty("top_left", Required = Required.Always)]
        public Dimension TopLeft { get; set; }

        [JsonProperty("top_right", Required = Required.Always)]
        public Dimension TopRight { get; set; }
    }

    public partial class Dimension
    {
        [JsonProperty("unit", Required = Required.Always)]
        public DimensionUnit Unit { get; set; }

        [JsonProperty("value", Required = Required.Always)]
        public double Value { get; set; }
    }

    public partial class BorderWidth
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public double Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public double Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public double Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public double Top { get; set; }
    }

    public partial class FontAddress
    {
        [JsonProperty("font", Required = Required.Always)]
        public string Font { get; set; }
    }

    public partial class ImageSlice
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public long Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public long Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public long Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public long Top { get; set; }
    }

    public partial class FlexInsets
    {
        [JsonProperty("bottom")]
        public Dimension Bottom { get; set; }

        [JsonProperty("left")]
        public Dimension Left { get; set; }

        [JsonProperty("right")]
        public Dimension Right { get; set; }

        [JsonProperty("top")]
        public Dimension Top { get; set; }
    }

    public partial class DimensionGroup
    {
        [JsonProperty("bottom", Required = Required.Always)]
        public Dimension Bottom { get; set; }

        [JsonProperty("left", Required = Required.Always)]
        public Dimension Left { get; set; }

        [JsonProperty("right", Required = Required.Always)]
        public Dimension Right { get; set; }

        [JsonProperty("top", Required = Required.Always)]
        public Dimension Top { get; set; }
    }

    public partial class FlexRotate
    {
        [JsonProperty("degrees", Required = Required.Always)]
        public double Degrees { get; set; }
    }

    public partial class FlexScale
    {
        [JsonProperty("amount", Required = Required.Always)]
        public FlexVector3 Amount { get; set; }
    }

    public partial class TextShadow
    {
        [JsonProperty("blur_radius", Required = Required.Always)]
        public double BlurRadius { get; set; }

        [JsonProperty("color", Required = Required.Always)]
        public DisplayColor Color { get; set; }

        [JsonProperty("offset", Required = Required.Always)]
        public FlexVector2 Offset { get; set; }
    }

    public partial class FlexVector2
    {
        [JsonProperty("x", Required = Required.Always)]
        public double X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public double Y { get; set; }
    }

    public partial class FlexTranslate
    {
        [JsonProperty("x", Required = Required.Always)]
        public Dimension X { get; set; }

        [JsonProperty("y", Required = Required.Always)]
        public Dimension Y { get; set; }

        [JsonProperty("z", Required = Required.Always)]
        public double Z { get; set; }
    }

    public partial class SliderNode
    {
        [JsonProperty("direction")]
        public SliderDirection? Direction { get; set; }

        [JsonProperty("drag_container_style")]
        public FlexStyle DragContainerStyle { get; set; }

        [JsonProperty("dragger_border_style")]
        public FlexStyle DraggerBorderStyle { get; set; }

        [JsonProperty("dragger_style")]
        public FlexStyle DraggerStyle { get; set; }

        [JsonProperty("high_value")]
        public double? HighValue { get; set; }

        [JsonProperty("initial_value")]
        public double? InitialValue { get; set; }

        [JsonProperty("inverted")]
        public bool? Inverted { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("label_style")]
        public FlexStyle LabelStyle { get; set; }

        [JsonProperty("low_value")]
        public double? LowValue { get; set; }

        [JsonProperty("page_size")]
        public double? PageSize { get; set; }

        [JsonProperty("preference_key")]
        public string PreferenceKey { get; set; }

        [JsonProperty("show_input_field")]
        public bool? ShowInputField { get; set; }

        [JsonProperty("tracker_style")]
        public FlexStyle TrackerStyle { get; set; }
    }

    public partial class TextNode
    {
        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    public partial class TextFieldNode
    {
        [JsonProperty("double_click_selects_word")]
        public bool? DoubleClickSelectsWord { get; set; }

        [JsonProperty("global_identifier")]
        public string GlobalIdentifier { get; set; }

        [JsonProperty("initial_text")]
        public string InitialText { get; set; }

        [JsonProperty("is_password_field")]
        public bool? IsPasswordField { get; set; }

        [JsonProperty("is_read_only")]
        public bool? IsReadOnly { get; set; }

        [JsonProperty("mask_character")]
        public string MaskCharacter { get; set; }

        [JsonProperty("max_length")]
        public long? MaxLength { get; set; }

        [JsonProperty("multiline")]
        public bool? Multiline { get; set; }

        [JsonProperty("triple_click_selects_line")]
        public bool? TripleClickSelectsLine { get; set; }
    }

    public partial class EventHandlers
    {
        [JsonProperty("on_click")]
        public ActionUnion? OnClick { get; set; }

        [JsonProperty("on_field_changed")]
        public ActionUnion? OnFieldChanged { get; set; }

        [JsonProperty("on_long_press")]
        public ActionUnion? OnLongPress { get; set; }

        [JsonProperty("on_mouse_down")]
        public ActionUnion? OnMouseDown { get; set; }

        [JsonProperty("on_mouse_enter")]
        public ActionUnion? OnMouseEnter { get; set; }

        [JsonProperty("on_mouse_leave")]
        public ActionUnion? OnMouseLeave { get; set; }

        [JsonProperty("on_mouse_up")]
        public ActionUnion? OnMouseUp { get; set; }
    }

    /// <summary>
    /// Special effects to display for this card
    /// </summary>
    public partial class CardEffects
    {
        /// <summary>
        /// Projectile to display as a trail behind this card.
        /// </summary>
        [JsonProperty("card_trail")]
        public ProjectileAddress CardTrail { get; set; }

        /// <summary>
        /// Ongoing visual effect to display for this card.
        ///
        /// If a previous effect with a different address is present, it will be
        /// destroyed before adding this effect. If an effect with the same address
        /// is present, this will be ignored.
        /// </summary>
        [JsonProperty("looping_effect")]
        public EffectAddress LoopingEffect { get; set; }
    }

    public partial class ProjectileAddress
    {
        [JsonProperty("projectile", Required = Required.Always)]
        public string Projectile { get; set; }
    }

    /// <summary>
    /// Image for this card
    /// </summary>
    public partial class DisplayImage
    {
        [JsonProperty("Sprite", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SpriteAddress Sprite { get; set; }

        [JsonProperty("Prefab", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DisplayPrefabImage Prefab { get; set; }
    }

    public partial class DisplayPrefabImage
    {
        [JsonProperty("prefab", Required = Required.Always)]
        public PrefabAddress Prefab { get; set; }

        [JsonProperty("studio_type", Required = Required.Always)]
        public StudioType StudioType { get; set; }
    }

    public partial class PrefabAddress
    {
        [JsonProperty("prefab", Required = Required.Always)]
        public string Prefab { get; set; }
    }

    public partial class InfoZoomData
    {
        /// <summary>
        /// Icons to display on other cards during info zoom, e.g. indicating
        /// targets.
        /// </summary>
        [JsonProperty("icons", Required = Required.Always)]
        public List<InfoZoomIcon> Icons { get; set; }

        /// <summary>
        /// Additional help text about this card, describing its abilities.
        /// </summary>
        [JsonProperty("supplemental_card_info")]
        public FlexNode SupplementalCardInfo { get; set; }
    }

    public partial class InfoZoomIcon
    {
        [JsonProperty("card_id", Required = Required.Always)]
        public string CardId { get; set; }

        [JsonProperty("color", Required = Required.Always)]
        public DisplayColor Color { get; set; }

        [JsonProperty("icon", Required = Required.Always)]
        public string Icon { get; set; }
    }

    public partial class FireProjectileCommand
    {
        [JsonProperty("additional_hit")]
        public EffectAddress AdditionalHit { get; set; }

        [JsonProperty("additional_hit_delay")]
        public Milliseconds AdditionalHitDelay { get; set; }

        [JsonProperty("fire_sound")]
        public AudioClipAddress FireSound { get; set; }

        [JsonProperty("hide_on_hit", Required = Required.Always)]
        public bool HideOnHit { get; set; }

        [JsonProperty("impact_sound")]
        public AudioClipAddress ImpactSound { get; set; }

        [JsonProperty("jump_to_position")]
        public ObjectPosition JumpToPosition { get; set; }

        [JsonProperty("projectile", Required = Required.Always)]
        public ProjectileAddress Projectile { get; set; }

        [JsonProperty("source_id", Required = Required.Always)]
        public GameObjectId SourceId { get; set; }

        [JsonProperty("target_id", Required = Required.Always)]
        public GameObjectId TargetId { get; set; }

        [JsonProperty("travel_duration")]
        public Milliseconds TravelDuration { get; set; }

        [JsonProperty("wait_duration")]
        public Milliseconds WaitDuration { get; set; }
    }

    public partial class PlayAudioClipCommand
    {
        /// <summary>
        /// How long to pause before continuing with animations.
        /// </summary>
        [JsonProperty("pause_duration", Required = Required.Always)]
        public Milliseconds PauseDuration { get; set; }

        /// <summary>
        /// Sound to play
        /// </summary>
        [JsonProperty("sound", Required = Required.Always)]
        public AudioClipAddress Sound { get; set; }
    }

    public partial class PlayStudioAnimationCommand
    {
        [JsonProperty("animation", Required = Required.Always)]
        public StudioAnimation Animation { get; set; }

        [JsonProperty("enter_animation")]
        public StudioAnimation EnterAnimation { get; set; }

        [JsonProperty("exit_animation")]
        public StudioAnimation ExitAnimation { get; set; }

        [JsonProperty("studio_type", Required = Required.Always)]
        public StudioType StudioType { get; set; }
    }

    public partial class StudioAnimation
    {
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }
    }

    public partial class UpdateBattleCommand
    {
        /// <summary>
        /// The battle to update.
        /// </summary>
        [JsonProperty("battle", Required = Required.Always)]
        public BattleView Battle { get; set; }

        /// <summary>
        /// Sound to play when the battle is updated.
        /// </summary>
        [JsonProperty("update_sound")]
        public AudioClipAddress UpdateSound { get; set; }
    }

    /// <summary>
    /// The battle to update.
    ///
    /// Represents the visual state of an ongoing dream battle
    /// </summary>
    public partial class BattleView
    {
        /// <summary>
        /// Arrows to display between cards
        /// </summary>
        [JsonProperty("arrows", Required = Required.Always)]
        public List<DisplayArrow> Arrows { get; set; }

        /// <summary>
        /// Visual state of cards in the game
        /// </summary>
        [JsonProperty("cards", Required = Required.Always)]
        public List<CardView> Cards { get; set; }

        /// <summary>
        /// Opponent of user
        /// </summary>
        [JsonProperty("enemy", Required = Required.Always)]
        public PlayerView Enemy { get; set; }

        /// <summary>
        /// Unique identifier for this dream battle
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public Guid Id { get; set; }

        /// <summary>
        /// UI to display to the player.
        /// </summary>
        [JsonProperty("interface", Required = Required.Always)]
        public InterfaceView Interface { get; set; }

        /// <summary>
        /// Preview of the next state of the battle, used e.g. when confirming
        /// prompt choices.
        /// </summary>
        [JsonProperty("preview", Required = Required.Always)]
        public BattlePreviewState Preview { get; set; }

        /// <summary>
        /// Player who is operating the client
        /// </summary>
        [JsonProperty("user", Required = Required.Always)]
        public PlayerView User { get; set; }
    }

    public partial class DisplayArrow
    {
        [JsonProperty("color", Required = Required.Always)]
        public ArrowStyle Color { get; set; }

        [JsonProperty("source", Required = Required.Always)]
        public GameObjectId Source { get; set; }

        [JsonProperty("target", Required = Required.Always)]
        public GameObjectId Target { get; set; }
    }

    /// <summary>
    /// Opponent of user
    ///
    /// Represents the visual state of a player in a game
    ///
    /// Player who is operating the client
    /// </summary>
    public partial class PlayerView
    {
        /// <summary>
        /// Can this player currently take a game action?
        /// </summary>
        [JsonProperty("can_act", Required = Required.Always)]
        public bool CanAct { get; set; }

        /// <summary>
        /// Energy available to this player
        /// </summary>
        [JsonProperty("energy", Required = Required.Always)]
        public long Energy { get; set; }

        /// <summary>
        /// Will this player win the game in their next judgment phase?
        /// </summary>
        [JsonProperty("is_victory_imminent", Required = Required.Always)]
        public bool IsVictoryImminent { get; set; }

        /// <summary>
        /// Energy produced by this player at the start of the current turn
        /// </summary>
        [JsonProperty("produced_energy", Required = Required.Always)]
        public long ProducedEnergy { get; set; }

        /// <summary>
        /// Current score total
        /// </summary>
        [JsonProperty("score", Required = Required.Always)]
        public long Score { get; set; }

        /// <summary>
        /// Total spark for this player
        /// </summary>
        [JsonProperty("total_spark", Required = Required.Always)]
        public long TotalSpark { get; set; }

        /// <summary>
        /// Indicates whether it is this player's turn, and if so, which phase of
        /// the turn they are in.
        /// </summary>
        [JsonProperty("turn_indicator")]
        public DisplayedTurnIndicator? TurnIndicator { get; set; }
    }

    /// <summary>
    /// UI to display to the player.
    ///
    /// User interaction options
    /// </summary>
    public partial class InterfaceView
    {
        /// <summary>
        /// Button most often used for toggling the visibility of card browsers.
        /// </summary>
        [JsonProperty("bottom_right_button")]
        public ButtonView BottomRightButton { get; set; }

        /// <summary>
        /// Options for displaying the card browser
        /// </summary>
        [JsonProperty("browser")]
        public CardBrowserView Browser { get; set; }

        /// <summary>
        /// Options for display of the card order selector
        /// </summary>
        [JsonProperty("card_order_selector")]
        public CardOrderSelectorView CardOrderSelector { get; set; }

        /// <summary>
        /// Button to decrement the number shown in a number prompt.
        /// </summary>
        [JsonProperty("decrement_button")]
        public ButtonView DecrementButton { get; set; }

        /// <summary>
        /// Button to toggle the display of the developer panel
        /// </summary>
        [JsonProperty("dev_button")]
        public ButtonView DevButton { get; set; }

        /// <summary>
        /// Whether any panels are currently open
        /// </summary>
        [JsonProperty("has_open_panels", Required = Required.Always)]
        public bool HasOpenPanels { get; set; }

        /// <summary>
        /// Button to increment the number shown in a number prompt.
        /// </summary>
        [JsonProperty("increment_button")]
        public ButtonView IncrementButton { get; set; }

        /// <summary>
        /// Primary action button, used for confirming selections and ending the
        /// turn. None indicates no button should be shown.
        /// </summary>
        [JsonProperty("primary_action_button")]
        public ButtonView PrimaryActionButton { get; set; }

        /// <summary>
        /// If provided, when the primary action button is not visible, the button
        /// will wait for this duration after the last "update" before appearing. If
        /// this is None the button will display immediately.
        /// </summary>
        [JsonProperty("primary_action_show_on_idle_duration")]
        public Milliseconds PrimaryActionShowOnIdleDuration { get; set; }

        /// <summary>
        /// Content to display on top of all other game UI.
        /// </summary>
        [JsonProperty("screen_overlay")]
        public FlexNode ScreenOverlay { get; set; }

        /// <summary>
        /// Secondary action button, used for alternative choice options.
        /// </summary>
        [JsonProperty("secondary_action_button")]
        public ButtonView SecondaryActionButton { get; set; }

        /// <summary>
        /// Button to perform an undo operation
        /// </summary>
        [JsonProperty("undo_button")]
        public ButtonView UndoButton { get; set; }
    }

    /// <summary>
    /// Button to perform some game action
    /// </summary>
    public partial class ButtonView
    {
        /// <summary>
        /// Action to perform when the button is clicked. If None is provided, the
        /// button will appear disabled.
        /// </summary>
        [JsonProperty("action")]
        public ActionUnion? Action { get; set; }

        [JsonProperty("label", Required = Required.Always)]
        public string Label { get; set; }
    }

    public partial class CardBrowserView
    {
        /// <summary>
        /// Action to perform when the close button is clicked.
        ///
        /// If None is provided, no close button should be shown.
        /// </summary>
        [JsonProperty("close_button")]
        public ActionUnion? CloseButton { get; set; }
    }

    public partial class CardOrderSelectorView
    {
        /// <summary>
        /// Include the user's deck as a card drop target
        /// </summary>
        [JsonProperty("include_deck", Required = Required.Always)]
        public bool IncludeDeck { get; set; }

        /// <summary>
        /// Include the user's void as a card drop target
        /// </summary>
        [JsonProperty("include_void", Required = Required.Always)]
        public bool IncludeVoid { get; set; }
    }

    /// <summary>
    /// Active battle preview, e.g. when a prompt is active.
    /// </summary>
    public partial class BattlePreviewStateClass
    {
        [JsonProperty("Active", Required = Required.Always)]
        public BattlePreviewView Active { get; set; }
    }

    public partial class PerformActionRequest
    {
        [JsonProperty("action", Required = Required.Always)]
        public GameAction Action { get; set; }

        /// <summary>
        /// The version of the last response the client received, used to prevent
        /// duplicate actions.
        /// </summary>
        [JsonProperty("last_response_version")]
        public Guid? LastResponseVersion { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        /// <summary>
        /// If specified, treats this as a multiplayer game using the save file
        /// provided in this ID instead of reading the user's own save file.
        /// </summary>
        [JsonProperty("save_file_id")]
        public Guid? SaveFileId { get; set; }
    }

    public partial class GameActionClass
    {
        [JsonProperty("DebugAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DebugAction? DebugAction { get; set; }

        [JsonProperty("BattleAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleAction? BattleAction { get; set; }

        [JsonProperty("BattleDisplayAction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BattleDisplayAction? BattleDisplayAction { get; set; }

        [JsonProperty("Undo", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public PlayerName? Undo { get; set; }
    }

    public partial class PerformActionResponse
    {
        [JsonProperty("commands", Required = Required.Always)]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollRequest
    {
        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }
    }

    public partial class PollResponse
    {
        [JsonProperty("commands")]
        public CommandSequence Commands { get; set; }

        [JsonProperty("metadata", Required = Required.Always)]
        public Metadata Metadata { get; set; }

        [JsonProperty("response_type", Required = Required.Always)]
        public PollResponseType ResponseType { get; set; }

        [JsonProperty("response_version")]
        public Guid? ResponseVersion { get; set; }
    }

    public enum LogSpanName { ApplyCommandGroup, ApplyCommands, Connect, PerformAction, Poll, Untagged, UpdateBattleLayout };

    public enum LogType { Debug, Error, Info, Warning };

    public enum GameAiEnum { AlwaysPanic, FirstAvailableAction, RandomAction, WaitFiveSeconds };

    /// <summary>
    /// Represents a player within the context of the display layer.
    ///
    /// The "viewer" is always the player operating the game client, this may
    /// correspond to either of the actual players in the game.
    ///
    /// The player to display the judgment animation for.
    ///
    /// The player to display the dreamwell activation for.
    /// </summary>
    public enum DisplayPlayer { Enemy, User };

    public enum GameMessageType { Defeat, EnemyTurn, Victory, YourTurn };

    /// <summary>
    /// Face up/face down state for this card
    ///
    /// Whether a card is face-down or face-up
    /// </summary>
    public enum CardFacing { FaceDown, FaceUp };

    /// <summary>
    /// Object position used in interface elements like the deck viewer which
    /// don't rely on game positioning.
    ///
    /// Object is not visible.
    ///
    /// Position for cards to be shown to the user immediately after they're
    /// drawn.
    ///
    /// Object is being displayed in a card browser, e.g. to select from a list
    /// of cards while searching
    ///
    /// Object is in a temporary holding space for cards in hand while resolving
    /// some other 'play card' ability.
    ///
    /// Object is in a position to display itself as part of a dreamwell
    /// activation.
    ///
    /// Object describes a game modifier or ongoing game effect
    ///
    /// Object is in the on-screen storage area, used to hold objects at a small
    /// size when they're not being focused on, e.g. when the user hides a
    /// card browser to get a better view of the battlefield.
    /// </summary>
    public enum PositionEnum { Browser, Default, Drawn, DreamwellActivation, GameModifier, HandStorage, Offscreen, OnScreenStorage };

    /// <summary>
    /// Auto-generated discriminant enum variants
    /// </summary>
    public enum CardOrderSelectionTargetDiscriminants { Deck, Void };

    public enum StackType { Default, TargetingBothBattlefields, TargetingEnemyBattlefield, TargetingUserBattlefield };

    /// <summary>
    /// Represents the general category of card being displayed.
    /// </summary>
    public enum CardPrefab { Character, Dreamsign, Dreamwell, Enemy, Event, Identity, Token };

    public enum GameActionEnum { NoOp };

    /// <summary>
    /// Pass on taking actions in response to a card being played by the
    /// opponent, thus causing the stack to be resolved.
    ///
    /// End your turn
    ///
    /// Start your next turn after the opponent takes the `EndTurn` action.
    ///
    /// Submit the selected void card targets
    ///
    /// Submit the selected deck card order configuration in the current
    /// ordering prompt.
    ///
    /// Confirm the selected cards to mulligan
    /// </summary>
    public enum BattleActionEnum { EndTurn, PassPriority, StartNextTurn, SubmitDeckCardOrder, SubmitMulligan, SubmitVoidCardTargets };

    /// <summary>
    /// Cause the opponent to take a 'continue' legal action
    /// </summary>
    public enum DebugBattleActionEnum { OpponentContinue };

    public enum CardName { TestActivatedAbilityDissolveCharacter, TestActivatedAbilityDrawCard, TestCounterspell, TestCounterspellCharacter, TestCounterspellUnlessPays, TestDissolve, TestDrawOne, TestDrawOneReclaim, TestDualActivatedAbilityCharacter, TestFastActivatedAbilityDrawCardCharacter, TestFastMultiActivatedAbilityDrawCardCharacter, TestForeseeOne, TestForeseeOneDrawACard, TestForeseeOneDrawReclaim, TestForeseeOneReclaim, TestForeseeTwo, TestModalDrawOneOrDissolveEnemy, TestModalDrawOneOrDrawTwo, TestModalReturnToHandOrDrawTwo, TestMultiActivatedAbilityDrawCardCharacter, TestNamedDissolve, TestPreventDissolveThisTurn, TestReturnOneOrTwoVoidEventCardsToHand, TestReturnToHand, TestReturnVoidCardToHand, TestTriggerGainSparkOnPlayCardEnemyTurn, TestTriggerGainSparkWhenMaterializeAnotherCharacter, TestTriggerGainTwoSparkOnPlayCardEnemyTurn, TestVanillaCharacter, TestVariableEnergyDraw };

    /// <summary>
    /// Identifies a player in an ongoing battle.
    /// </summary>
    public enum PlayerName { One, Two };

    public enum CardOrderSelectionTargetEnum { Void };

    /// <summary>
    /// Closes the currently open panel.
    ///
    /// Toggles the visibility of the stack.
    /// </summary>
    public enum BattleDisplayActionEnum { CloseCardBrowser, CloseCurrentPanel, ToggleStackVisibility };

    public enum CardBrowserType { EnemyDeck, EnemyStatus, EnemyVoid, UserDeck, UserStatus, UserVoid };

    public enum PanelAddressEnum { AddCardToHand, Developer, PlayOpponentCard, SetOpponentAgent };

    public enum DebugActionEnum { ApplyTestScenarioAction, RestartBattle, SetOpponentAsHuman };

    public enum TestDeckName { CoreEleven, StartingFive };

    public enum FlexAlign { Auto, Center, FlexEnd, FlexStart, Stretch };

    public enum DimensionUnit { Percentage, Pixels, SafeAreaBottomInset, SafeAreaLeftInset, SafeAreaRightInset, SafeAreaTopInset, ViewportHeight, ViewportWidth };

    public enum FlexDisplayStyle { Flex, None };

    public enum FlexDirection { Column, ColumnReverse, Row, RowReverse };

    public enum FontStyle { Bold, BoldAndItalic, Italic, Normal };

    public enum FlexJustify { Center, FlexEnd, FlexStart, SpaceAround, SpaceBetween };

    public enum FlexVisibility { Hidden, Visible };

    public enum OverflowClipBox { ContentBox, PaddingBox };

    public enum FlexPickingMode { Ignore, Position };

    public enum FlexPosition { Absolute, Relative };

    public enum TextAlign { LowerCenter, LowerLeft, LowerRight, MiddleCenter, MiddleLeft, MiddleRight, UpperCenter, UpperLeft, UpperRight };

    public enum TextOverflow { Clip, Ellipsis };

    public enum TextOverflowPosition { End, Middle, Start };

    public enum EasingMode { Ease, EaseIn, EaseInBack, EaseInBounce, EaseInCirc, EaseInCubic, EaseInElastic, EaseInOut, EaseInOutBack, EaseInOutBounce, EaseInOutCirc, EaseInOutCubic, EaseInOutElastic, EaseInOutSine, EaseInSine, EaseOut, EaseOutBack, EaseOutBounce, EaseOutCirc, EaseOutCubic, EaseOutElastic, EaseOutSine, Linear };

    public enum WhiteSpace { NoWrap, Normal };

    public enum FlexWrap { NoWrap, Wrap, WrapReverse };

    public enum ScrollBarVisibility { AlwaysVisible, Auto, Hidden };

    public enum TouchScrollBehavior { Clamped, Elastic, Unrestricted };

    public enum SliderDirection { Horizontal, Vertical };

    public enum StudioType { EnemyIdentityCard, EnemyStatus, UserIdentityCard, UserStatus };

    public enum ArrowStyle { Blue, Green, Red };

    /// <summary>
    /// Left indicator, indicates start of turn or main phase
    ///
    /// Right indicator, indicates ending phase
    /// </summary>
    public enum DisplayedTurnIndicator { Left, Right };

    /// <summary>
    /// No preview is currently active. Clear any existing preview.
    ///
    /// Unknown battle preview state during animation
    ///
    /// Used to not remove the existing preview to avoid the interface jumping
    /// around between states.
    /// </summary>
    public enum BattlePreviewStateEnum { None, Pending };

    public enum PollResponseType { Final, Incremental, None };

    public partial struct GameAi
    {
        public GameAiEnum? Enum;
        public GameAiClass GameAiClass;

        public static implicit operator GameAi(GameAiEnum Enum) => new GameAi { Enum = Enum };
        public static implicit operator GameAi(GameAiClass GameAiClass) => new GameAi { GameAiClass = GameAiClass };
    }

    /// <summary>
    /// Position category
    ///
    /// Possible types of display positions
    /// </summary>
    public partial struct Position
    {
        public PositionEnum? Enum;
        public PositionClass PositionClass;

        public static implicit operator Position(PositionEnum Enum) => new Position { Enum = Enum };
        public static implicit operator Position(PositionClass PositionClass) => new Position { PositionClass = PositionClass };
    }

    public partial struct DebugBattleAction
    {
        public DebugBattleActionClass DebugBattleActionClass;
        public DebugBattleActionEnum? Enum;

        public static implicit operator DebugBattleAction(DebugBattleActionClass DebugBattleActionClass) => new DebugBattleAction { DebugBattleActionClass = DebugBattleActionClass };
        public static implicit operator DebugBattleAction(DebugBattleActionEnum Enum) => new DebugBattleAction { Enum = Enum };
    }

    public partial struct PlayCardFromVoid
    {
        public AbilityId AbilityId;
        public long? Integer;

        public static implicit operator PlayCardFromVoid(AbilityId AbilityId) => new PlayCardFromVoid { AbilityId = AbilityId };
        public static implicit operator PlayCardFromVoid(long Integer) => new PlayCardFromVoid { Integer = Integer };
    }

    public partial struct CardOrderSelectionTarget
    {
        public CardOrderSelectionTargetClass CardOrderSelectionTargetClass;
        public CardOrderSelectionTargetEnum? Enum;

        public static implicit operator CardOrderSelectionTarget(CardOrderSelectionTargetClass CardOrderSelectionTargetClass) => new CardOrderSelectionTarget { CardOrderSelectionTargetClass = CardOrderSelectionTargetClass };
        public static implicit operator CardOrderSelectionTarget(CardOrderSelectionTargetEnum Enum) => new CardOrderSelectionTarget { Enum = Enum };
    }

    /// <summary>
    /// An action that can be performed in a battle
    /// </summary>
    public partial struct BattleAction
    {
        public BattleActionClass BattleActionClass;
        public BattleActionEnum? Enum;

        public static implicit operator BattleAction(BattleActionClass BattleActionClass) => new BattleAction { BattleActionClass = BattleActionClass };
        public static implicit operator BattleAction(BattleActionEnum Enum) => new BattleAction { Enum = Enum };
    }

    /// <summary>
    /// Identifies a window on screen containing UI elements
    /// </summary>
    public partial struct PanelAddress
    {
        public PanelAddressEnum? Enum;
        public PanelAddressClass PanelAddressClass;

        public static implicit operator PanelAddress(PanelAddressEnum Enum) => new PanelAddress { Enum = Enum };
        public static implicit operator PanelAddress(PanelAddressClass PanelAddressClass) => new PanelAddress { PanelAddressClass = PanelAddressClass };
    }

    public partial struct BattleDisplayAction
    {
        public BattleDisplayActionClass BattleDisplayActionClass;
        public BattleDisplayActionEnum? Enum;

        public static implicit operator BattleDisplayAction(BattleDisplayActionClass BattleDisplayActionClass) => new BattleDisplayAction { BattleDisplayActionClass = BattleDisplayActionClass };
        public static implicit operator BattleDisplayAction(BattleDisplayActionEnum Enum) => new BattleDisplayAction { Enum = Enum };
    }

    /// <summary>
    /// Private actions for developer use
    /// </summary>
    public partial struct DebugAction
    {
        public DebugActionClass DebugActionClass;
        public DebugActionEnum? Enum;

        public static implicit operator DebugAction(DebugActionClass DebugActionClass) => new DebugAction { DebugActionClass = DebugActionClass };
        public static implicit operator DebugAction(DebugActionEnum Enum) => new DebugAction { Enum = Enum };
    }

    public partial struct ActionUnion
    {
        public ActionClass ActionClass;
        public GameActionEnum? Enum;

        public static implicit operator ActionUnion(ActionClass ActionClass) => new ActionUnion { ActionClass = ActionClass };
        public static implicit operator ActionUnion(GameActionEnum Enum) => new ActionUnion { Enum = Enum };
        public bool IsNull => ActionClass == null && Enum == null;
    }

    /// <summary>
    /// Preview of the next state of the battle, used e.g. when confirming
    /// prompt choices.
    /// </summary>
    public partial struct BattlePreviewState
    {
        public BattlePreviewStateClass BattlePreviewStateClass;
        public BattlePreviewStateEnum? Enum;

        public static implicit operator BattlePreviewState(BattlePreviewStateClass BattlePreviewStateClass) => new BattlePreviewState { BattlePreviewStateClass = BattlePreviewStateClass };
        public static implicit operator BattlePreviewState(BattlePreviewStateEnum Enum) => new BattlePreviewState { Enum = Enum };
    }

    /// <summary>
    /// All possible user interface actions
    /// </summary>
    public partial struct GameAction
    {
        public GameActionEnum? Enum;
        public GameActionClass GameActionClass;

        public static implicit operator GameAction(GameActionEnum Enum) => new GameAction { Enum = Enum };
        public static implicit operator GameAction(GameActionClass GameActionClass) => new GameAction { GameActionClass = GameActionClass };
    }

    public partial class SchemaTypes
    {
        public static SchemaTypes FromJson(string json) => JsonConvert.DeserializeObject<SchemaTypes>(json, Dreamtides.Schema.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SchemaTypes self) => JsonConvert.SerializeObject(self, Dreamtides.Schema.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                LogTypeConverter.Singleton,
                LogSpanNameConverter.Singleton,
                GameAiConverter.Singleton,
                GameAiEnumConverter.Singleton,
                DisplayPlayerConverter.Singleton,
                GameMessageTypeConverter.Singleton,
                CardFacingConverter.Singleton,
                PositionConverter.Singleton,
                CardOrderSelectionTargetDiscriminantsConverter.Singleton,
                StackTypeConverter.Singleton,
                PositionEnumConverter.Singleton,
                CardPrefabConverter.Singleton,
                ActionUnionConverter.Singleton,
                BattleActionConverter.Singleton,
                DebugBattleActionConverter.Singleton,
                CardNameConverter.Singleton,
                PlayerNameConverter.Singleton,
                DebugBattleActionEnumConverter.Singleton,
                PlayCardFromVoidConverter.Singleton,
                CardOrderSelectionTargetConverter.Singleton,
                CardOrderSelectionTargetEnumConverter.Singleton,
                BattleActionEnumConverter.Singleton,
                BattleDisplayActionConverter.Singleton,
                CardBrowserTypeConverter.Singleton,
                PanelAddressConverter.Singleton,
                PanelAddressEnumConverter.Singleton,
                BattleDisplayActionEnumConverter.Singleton,
                DebugActionConverter.Singleton,
                TestDeckNameConverter.Singleton,
                DebugActionEnumConverter.Singleton,
                GameActionEnumConverter.Singleton,
                FlexAlignConverter.Singleton,
                DimensionUnitConverter.Singleton,
                FlexDisplayStyleConverter.Singleton,
                FlexDirectionConverter.Singleton,
                FontStyleConverter.Singleton,
                FlexJustifyConverter.Singleton,
                FlexVisibilityConverter.Singleton,
                OverflowClipBoxConverter.Singleton,
                FlexPickingModeConverter.Singleton,
                FlexPositionConverter.Singleton,
                TextAlignConverter.Singleton,
                TextOverflowConverter.Singleton,
                TextOverflowPositionConverter.Singleton,
                EasingModeConverter.Singleton,
                WhiteSpaceConverter.Singleton,
                FlexWrapConverter.Singleton,
                ScrollBarVisibilityConverter.Singleton,
                TouchScrollBehaviorConverter.Singleton,
                SliderDirectionConverter.Singleton,
                StudioTypeConverter.Singleton,
                ArrowStyleConverter.Singleton,
                DisplayedTurnIndicatorConverter.Singleton,
                BattlePreviewStateConverter.Singleton,
                BattlePreviewStateEnumConverter.Singleton,
                GameActionConverter.Singleton,
                PollResponseTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class LogTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LogType) || t == typeof(LogType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Debug":
                    return LogType.Debug;
                case "Error":
                    return LogType.Error;
                case "Info":
                    return LogType.Info;
                case "Warning":
                    return LogType.Warning;
            }
            throw new Exception("Cannot unmarshal type LogType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LogType)untypedValue;
            switch (value)
            {
                case LogType.Debug:
                    serializer.Serialize(writer, "Debug");
                    return;
                case LogType.Error:
                    serializer.Serialize(writer, "Error");
                    return;
                case LogType.Info:
                    serializer.Serialize(writer, "Info");
                    return;
                case LogType.Warning:
                    serializer.Serialize(writer, "Warning");
                    return;
            }
            throw new Exception("Cannot marshal type LogType");
        }

        public static readonly LogTypeConverter Singleton = new LogTypeConverter();
    }

    internal class LogSpanNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LogSpanName) || t == typeof(LogSpanName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ApplyCommandGroup":
                    return LogSpanName.ApplyCommandGroup;
                case "ApplyCommands":
                    return LogSpanName.ApplyCommands;
                case "Connect":
                    return LogSpanName.Connect;
                case "PerformAction":
                    return LogSpanName.PerformAction;
                case "Poll":
                    return LogSpanName.Poll;
                case "Untagged":
                    return LogSpanName.Untagged;
                case "UpdateBattleLayout":
                    return LogSpanName.UpdateBattleLayout;
            }
            throw new Exception("Cannot unmarshal type LogSpanName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LogSpanName)untypedValue;
            switch (value)
            {
                case LogSpanName.ApplyCommandGroup:
                    serializer.Serialize(writer, "ApplyCommandGroup");
                    return;
                case LogSpanName.ApplyCommands:
                    serializer.Serialize(writer, "ApplyCommands");
                    return;
                case LogSpanName.Connect:
                    serializer.Serialize(writer, "Connect");
                    return;
                case LogSpanName.PerformAction:
                    serializer.Serialize(writer, "PerformAction");
                    return;
                case LogSpanName.Poll:
                    serializer.Serialize(writer, "Poll");
                    return;
                case LogSpanName.Untagged:
                    serializer.Serialize(writer, "Untagged");
                    return;
                case LogSpanName.UpdateBattleLayout:
                    serializer.Serialize(writer, "UpdateBattleLayout");
                    return;
            }
            throw new Exception("Cannot marshal type LogSpanName");
        }

        public static readonly LogSpanNameConverter Singleton = new LogSpanNameConverter();
    }

    internal class GameAiConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameAi) || t == typeof(GameAi?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "AlwaysPanic":
                            return new GameAi { Enum = GameAiEnum.AlwaysPanic };
                        case "FirstAvailableAction":
                            return new GameAi { Enum = GameAiEnum.FirstAvailableAction };
                        case "RandomAction":
                            return new GameAi { Enum = GameAiEnum.RandomAction };
                        case "WaitFiveSeconds":
                            return new GameAi { Enum = GameAiEnum.WaitFiveSeconds };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<GameAiClass>(reader);
                    return new GameAi { GameAiClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type GameAi");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (GameAi)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case GameAiEnum.AlwaysPanic:
                        serializer.Serialize(writer, "AlwaysPanic");
                        return;
                    case GameAiEnum.FirstAvailableAction:
                        serializer.Serialize(writer, "FirstAvailableAction");
                        return;
                    case GameAiEnum.RandomAction:
                        serializer.Serialize(writer, "RandomAction");
                        return;
                    case GameAiEnum.WaitFiveSeconds:
                        serializer.Serialize(writer, "WaitFiveSeconds");
                        return;
                }
            }
            if (value.GameAiClass != null)
            {
                serializer.Serialize(writer, value.GameAiClass);
                return;
            }
            throw new Exception("Cannot marshal type GameAi");
        }

        public static readonly GameAiConverter Singleton = new GameAiConverter();
    }

    internal class GameAiEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameAiEnum) || t == typeof(GameAiEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AlwaysPanic":
                    return GameAiEnum.AlwaysPanic;
                case "FirstAvailableAction":
                    return GameAiEnum.FirstAvailableAction;
                case "RandomAction":
                    return GameAiEnum.RandomAction;
                case "WaitFiveSeconds":
                    return GameAiEnum.WaitFiveSeconds;
            }
            throw new Exception("Cannot unmarshal type GameAiEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GameAiEnum)untypedValue;
            switch (value)
            {
                case GameAiEnum.AlwaysPanic:
                    serializer.Serialize(writer, "AlwaysPanic");
                    return;
                case GameAiEnum.FirstAvailableAction:
                    serializer.Serialize(writer, "FirstAvailableAction");
                    return;
                case GameAiEnum.RandomAction:
                    serializer.Serialize(writer, "RandomAction");
                    return;
                case GameAiEnum.WaitFiveSeconds:
                    serializer.Serialize(writer, "WaitFiveSeconds");
                    return;
            }
            throw new Exception("Cannot marshal type GameAiEnum");
        }

        public static readonly GameAiEnumConverter Singleton = new GameAiEnumConverter();
    }

    internal class DisplayPlayerConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayPlayer) || t == typeof(DisplayPlayer?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Enemy":
                    return DisplayPlayer.Enemy;
                case "User":
                    return DisplayPlayer.User;
            }
            throw new Exception("Cannot unmarshal type DisplayPlayer");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayPlayer)untypedValue;
            switch (value)
            {
                case DisplayPlayer.Enemy:
                    serializer.Serialize(writer, "Enemy");
                    return;
                case DisplayPlayer.User:
                    serializer.Serialize(writer, "User");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayPlayer");
        }

        public static readonly DisplayPlayerConverter Singleton = new DisplayPlayerConverter();
    }

    internal class GameMessageTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameMessageType) || t == typeof(GameMessageType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Defeat":
                    return GameMessageType.Defeat;
                case "EnemyTurn":
                    return GameMessageType.EnemyTurn;
                case "Victory":
                    return GameMessageType.Victory;
                case "YourTurn":
                    return GameMessageType.YourTurn;
            }
            throw new Exception("Cannot unmarshal type GameMessageType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GameMessageType)untypedValue;
            switch (value)
            {
                case GameMessageType.Defeat:
                    serializer.Serialize(writer, "Defeat");
                    return;
                case GameMessageType.EnemyTurn:
                    serializer.Serialize(writer, "EnemyTurn");
                    return;
                case GameMessageType.Victory:
                    serializer.Serialize(writer, "Victory");
                    return;
                case GameMessageType.YourTurn:
                    serializer.Serialize(writer, "YourTurn");
                    return;
            }
            throw new Exception("Cannot marshal type GameMessageType");
        }

        public static readonly GameMessageTypeConverter Singleton = new GameMessageTypeConverter();
    }

    internal class CardFacingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardFacing) || t == typeof(CardFacing?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FaceDown":
                    return CardFacing.FaceDown;
                case "FaceUp":
                    return CardFacing.FaceUp;
            }
            throw new Exception("Cannot unmarshal type CardFacing");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardFacing)untypedValue;
            switch (value)
            {
                case CardFacing.FaceDown:
                    serializer.Serialize(writer, "FaceDown");
                    return;
                case CardFacing.FaceUp:
                    serializer.Serialize(writer, "FaceUp");
                    return;
            }
            throw new Exception("Cannot marshal type CardFacing");
        }

        public static readonly CardFacingConverter Singleton = new CardFacingConverter();
    }

    internal class PositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Position) || t == typeof(Position?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "Browser":
                            return new Position { Enum = PositionEnum.Browser };
                        case "Default":
                            return new Position { Enum = PositionEnum.Default };
                        case "Drawn":
                            return new Position { Enum = PositionEnum.Drawn };
                        case "DreamwellActivation":
                            return new Position { Enum = PositionEnum.DreamwellActivation };
                        case "GameModifier":
                            return new Position { Enum = PositionEnum.GameModifier };
                        case "HandStorage":
                            return new Position { Enum = PositionEnum.HandStorage };
                        case "Offscreen":
                            return new Position { Enum = PositionEnum.Offscreen };
                        case "OnScreenStorage":
                            return new Position { Enum = PositionEnum.OnScreenStorage };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PositionClass>(reader);
                    return new Position { PositionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Position");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Position)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PositionEnum.Browser:
                        serializer.Serialize(writer, "Browser");
                        return;
                    case PositionEnum.Default:
                        serializer.Serialize(writer, "Default");
                        return;
                    case PositionEnum.Drawn:
                        serializer.Serialize(writer, "Drawn");
                        return;
                    case PositionEnum.DreamwellActivation:
                        serializer.Serialize(writer, "DreamwellActivation");
                        return;
                    case PositionEnum.GameModifier:
                        serializer.Serialize(writer, "GameModifier");
                        return;
                    case PositionEnum.HandStorage:
                        serializer.Serialize(writer, "HandStorage");
                        return;
                    case PositionEnum.Offscreen:
                        serializer.Serialize(writer, "Offscreen");
                        return;
                    case PositionEnum.OnScreenStorage:
                        serializer.Serialize(writer, "OnScreenStorage");
                        return;
                }
            }
            if (value.PositionClass != null)
            {
                serializer.Serialize(writer, value.PositionClass);
                return;
            }
            throw new Exception("Cannot marshal type Position");
        }

        public static readonly PositionConverter Singleton = new PositionConverter();
    }

    internal class CardOrderSelectionTargetDiscriminantsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardOrderSelectionTargetDiscriminants) || t == typeof(CardOrderSelectionTargetDiscriminants?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Deck":
                    return CardOrderSelectionTargetDiscriminants.Deck;
                case "Void":
                    return CardOrderSelectionTargetDiscriminants.Void;
            }
            throw new Exception("Cannot unmarshal type CardOrderSelectionTargetDiscriminants");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardOrderSelectionTargetDiscriminants)untypedValue;
            switch (value)
            {
                case CardOrderSelectionTargetDiscriminants.Deck:
                    serializer.Serialize(writer, "Deck");
                    return;
                case CardOrderSelectionTargetDiscriminants.Void:
                    serializer.Serialize(writer, "Void");
                    return;
            }
            throw new Exception("Cannot marshal type CardOrderSelectionTargetDiscriminants");
        }

        public static readonly CardOrderSelectionTargetDiscriminantsConverter Singleton = new CardOrderSelectionTargetDiscriminantsConverter();
    }

    internal class StackTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StackType) || t == typeof(StackType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Default":
                    return StackType.Default;
                case "TargetingBothBattlefields":
                    return StackType.TargetingBothBattlefields;
                case "TargetingEnemyBattlefield":
                    return StackType.TargetingEnemyBattlefield;
                case "TargetingUserBattlefield":
                    return StackType.TargetingUserBattlefield;
            }
            throw new Exception("Cannot unmarshal type StackType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StackType)untypedValue;
            switch (value)
            {
                case StackType.Default:
                    serializer.Serialize(writer, "Default");
                    return;
                case StackType.TargetingBothBattlefields:
                    serializer.Serialize(writer, "TargetingBothBattlefields");
                    return;
                case StackType.TargetingEnemyBattlefield:
                    serializer.Serialize(writer, "TargetingEnemyBattlefield");
                    return;
                case StackType.TargetingUserBattlefield:
                    serializer.Serialize(writer, "TargetingUserBattlefield");
                    return;
            }
            throw new Exception("Cannot marshal type StackType");
        }

        public static readonly StackTypeConverter Singleton = new StackTypeConverter();
    }

    internal class PositionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PositionEnum) || t == typeof(PositionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Browser":
                    return PositionEnum.Browser;
                case "Default":
                    return PositionEnum.Default;
                case "Drawn":
                    return PositionEnum.Drawn;
                case "DreamwellActivation":
                    return PositionEnum.DreamwellActivation;
                case "GameModifier":
                    return PositionEnum.GameModifier;
                case "HandStorage":
                    return PositionEnum.HandStorage;
                case "Offscreen":
                    return PositionEnum.Offscreen;
                case "OnScreenStorage":
                    return PositionEnum.OnScreenStorage;
            }
            throw new Exception("Cannot unmarshal type PositionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PositionEnum)untypedValue;
            switch (value)
            {
                case PositionEnum.Browser:
                    serializer.Serialize(writer, "Browser");
                    return;
                case PositionEnum.Default:
                    serializer.Serialize(writer, "Default");
                    return;
                case PositionEnum.Drawn:
                    serializer.Serialize(writer, "Drawn");
                    return;
                case PositionEnum.DreamwellActivation:
                    serializer.Serialize(writer, "DreamwellActivation");
                    return;
                case PositionEnum.GameModifier:
                    serializer.Serialize(writer, "GameModifier");
                    return;
                case PositionEnum.HandStorage:
                    serializer.Serialize(writer, "HandStorage");
                    return;
                case PositionEnum.Offscreen:
                    serializer.Serialize(writer, "Offscreen");
                    return;
                case PositionEnum.OnScreenStorage:
                    serializer.Serialize(writer, "OnScreenStorage");
                    return;
            }
            throw new Exception("Cannot marshal type PositionEnum");
        }

        public static readonly PositionEnumConverter Singleton = new PositionEnumConverter();
    }

    internal class CardPrefabConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardPrefab) || t == typeof(CardPrefab?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Character":
                    return CardPrefab.Character;
                case "Dreamsign":
                    return CardPrefab.Dreamsign;
                case "Dreamwell":
                    return CardPrefab.Dreamwell;
                case "Enemy":
                    return CardPrefab.Enemy;
                case "Event":
                    return CardPrefab.Event;
                case "Identity":
                    return CardPrefab.Identity;
                case "Token":
                    return CardPrefab.Token;
            }
            throw new Exception("Cannot unmarshal type CardPrefab");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardPrefab)untypedValue;
            switch (value)
            {
                case CardPrefab.Character:
                    serializer.Serialize(writer, "Character");
                    return;
                case CardPrefab.Dreamsign:
                    serializer.Serialize(writer, "Dreamsign");
                    return;
                case CardPrefab.Dreamwell:
                    serializer.Serialize(writer, "Dreamwell");
                    return;
                case CardPrefab.Enemy:
                    serializer.Serialize(writer, "Enemy");
                    return;
                case CardPrefab.Event:
                    serializer.Serialize(writer, "Event");
                    return;
                case CardPrefab.Identity:
                    serializer.Serialize(writer, "Identity");
                    return;
                case CardPrefab.Token:
                    serializer.Serialize(writer, "Token");
                    return;
            }
            throw new Exception("Cannot marshal type CardPrefab");
        }

        public static readonly CardPrefabConverter Singleton = new CardPrefabConverter();
    }

    internal class ActionUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionUnion) || t == typeof(ActionUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new ActionUnion { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "NoOp")
                    {
                        return new ActionUnion { Enum = GameActionEnum.NoOp };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ActionClass>(reader);
                    return new ActionUnion { ActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type ActionUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ActionUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Enum != null)
            {
                if (value.Enum == GameActionEnum.NoOp)
                {
                    serializer.Serialize(writer, "NoOp");
                    return;
                }
            }
            if (value.ActionClass != null)
            {
                serializer.Serialize(writer, value.ActionClass);
                return;
            }
            throw new Exception("Cannot marshal type ActionUnion");
        }

        public static readonly ActionUnionConverter Singleton = new ActionUnionConverter();
    }

    internal class BattleActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleAction) || t == typeof(BattleAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "EndTurn":
                            return new BattleAction { Enum = BattleActionEnum.EndTurn };
                        case "PassPriority":
                            return new BattleAction { Enum = BattleActionEnum.PassPriority };
                        case "StartNextTurn":
                            return new BattleAction { Enum = BattleActionEnum.StartNextTurn };
                        case "SubmitDeckCardOrder":
                            return new BattleAction { Enum = BattleActionEnum.SubmitDeckCardOrder };
                        case "SubmitMulligan":
                            return new BattleAction { Enum = BattleActionEnum.SubmitMulligan };
                        case "SubmitVoidCardTargets":
                            return new BattleAction { Enum = BattleActionEnum.SubmitVoidCardTargets };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BattleActionClass>(reader);
                    return new BattleAction { BattleActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type BattleAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BattleAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BattleActionEnum.EndTurn:
                        serializer.Serialize(writer, "EndTurn");
                        return;
                    case BattleActionEnum.PassPriority:
                        serializer.Serialize(writer, "PassPriority");
                        return;
                    case BattleActionEnum.StartNextTurn:
                        serializer.Serialize(writer, "StartNextTurn");
                        return;
                    case BattleActionEnum.SubmitDeckCardOrder:
                        serializer.Serialize(writer, "SubmitDeckCardOrder");
                        return;
                    case BattleActionEnum.SubmitMulligan:
                        serializer.Serialize(writer, "SubmitMulligan");
                        return;
                    case BattleActionEnum.SubmitVoidCardTargets:
                        serializer.Serialize(writer, "SubmitVoidCardTargets");
                        return;
                }
            }
            if (value.BattleActionClass != null)
            {
                serializer.Serialize(writer, value.BattleActionClass);
                return;
            }
            throw new Exception("Cannot marshal type BattleAction");
        }

        public static readonly BattleActionConverter Singleton = new BattleActionConverter();
    }

    internal class DebugBattleActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugBattleAction) || t == typeof(DebugBattleAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "OpponentContinue")
                    {
                        return new DebugBattleAction { Enum = DebugBattleActionEnum.OpponentContinue };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DebugBattleActionClass>(reader);
                    return new DebugBattleAction { DebugBattleActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type DebugBattleAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DebugBattleAction)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == DebugBattleActionEnum.OpponentContinue)
                {
                    serializer.Serialize(writer, "OpponentContinue");
                    return;
                }
            }
            if (value.DebugBattleActionClass != null)
            {
                serializer.Serialize(writer, value.DebugBattleActionClass);
                return;
            }
            throw new Exception("Cannot marshal type DebugBattleAction");
        }

        public static readonly DebugBattleActionConverter Singleton = new DebugBattleActionConverter();
    }

    internal class CardNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardName) || t == typeof(CardName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "TestActivatedAbilityDissolveCharacter":
                    return CardName.TestActivatedAbilityDissolveCharacter;
                case "TestActivatedAbilityDrawCard":
                    return CardName.TestActivatedAbilityDrawCard;
                case "TestCounterspell":
                    return CardName.TestCounterspell;
                case "TestCounterspellCharacter":
                    return CardName.TestCounterspellCharacter;
                case "TestCounterspellUnlessPays":
                    return CardName.TestCounterspellUnlessPays;
                case "TestDissolve":
                    return CardName.TestDissolve;
                case "TestDrawOne":
                    return CardName.TestDrawOne;
                case "TestDrawOneReclaim":
                    return CardName.TestDrawOneReclaim;
                case "TestDualActivatedAbilityCharacter":
                    return CardName.TestDualActivatedAbilityCharacter;
                case "TestFastActivatedAbilityDrawCardCharacter":
                    return CardName.TestFastActivatedAbilityDrawCardCharacter;
                case "TestFastMultiActivatedAbilityDrawCardCharacter":
                    return CardName.TestFastMultiActivatedAbilityDrawCardCharacter;
                case "TestForeseeOne":
                    return CardName.TestForeseeOne;
                case "TestForeseeOneDrawACard":
                    return CardName.TestForeseeOneDrawACard;
                case "TestForeseeOneDrawReclaim":
                    return CardName.TestForeseeOneDrawReclaim;
                case "TestForeseeOneReclaim":
                    return CardName.TestForeseeOneReclaim;
                case "TestForeseeTwo":
                    return CardName.TestForeseeTwo;
                case "TestModalDrawOneOrDissolveEnemy":
                    return CardName.TestModalDrawOneOrDissolveEnemy;
                case "TestModalDrawOneOrDrawTwo":
                    return CardName.TestModalDrawOneOrDrawTwo;
                case "TestModalReturnToHandOrDrawTwo":
                    return CardName.TestModalReturnToHandOrDrawTwo;
                case "TestMultiActivatedAbilityDrawCardCharacter":
                    return CardName.TestMultiActivatedAbilityDrawCardCharacter;
                case "TestNamedDissolve":
                    return CardName.TestNamedDissolve;
                case "TestPreventDissolveThisTurn":
                    return CardName.TestPreventDissolveThisTurn;
                case "TestReturnOneOrTwoVoidEventCardsToHand":
                    return CardName.TestReturnOneOrTwoVoidEventCardsToHand;
                case "TestReturnToHand":
                    return CardName.TestReturnToHand;
                case "TestReturnVoidCardToHand":
                    return CardName.TestReturnVoidCardToHand;
                case "TestTriggerGainSparkOnPlayCardEnemyTurn":
                    return CardName.TestTriggerGainSparkOnPlayCardEnemyTurn;
                case "TestTriggerGainSparkWhenMaterializeAnotherCharacter":
                    return CardName.TestTriggerGainSparkWhenMaterializeAnotherCharacter;
                case "TestTriggerGainTwoSparkOnPlayCardEnemyTurn":
                    return CardName.TestTriggerGainTwoSparkOnPlayCardEnemyTurn;
                case "TestVanillaCharacter":
                    return CardName.TestVanillaCharacter;
                case "TestVariableEnergyDraw":
                    return CardName.TestVariableEnergyDraw;
            }
            throw new Exception("Cannot unmarshal type CardName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardName)untypedValue;
            switch (value)
            {
                case CardName.TestActivatedAbilityDissolveCharacter:
                    serializer.Serialize(writer, "TestActivatedAbilityDissolveCharacter");
                    return;
                case CardName.TestActivatedAbilityDrawCard:
                    serializer.Serialize(writer, "TestActivatedAbilityDrawCard");
                    return;
                case CardName.TestCounterspell:
                    serializer.Serialize(writer, "TestCounterspell");
                    return;
                case CardName.TestCounterspellCharacter:
                    serializer.Serialize(writer, "TestCounterspellCharacter");
                    return;
                case CardName.TestCounterspellUnlessPays:
                    serializer.Serialize(writer, "TestCounterspellUnlessPays");
                    return;
                case CardName.TestDissolve:
                    serializer.Serialize(writer, "TestDissolve");
                    return;
                case CardName.TestDrawOne:
                    serializer.Serialize(writer, "TestDrawOne");
                    return;
                case CardName.TestDrawOneReclaim:
                    serializer.Serialize(writer, "TestDrawOneReclaim");
                    return;
                case CardName.TestDualActivatedAbilityCharacter:
                    serializer.Serialize(writer, "TestDualActivatedAbilityCharacter");
                    return;
                case CardName.TestFastActivatedAbilityDrawCardCharacter:
                    serializer.Serialize(writer, "TestFastActivatedAbilityDrawCardCharacter");
                    return;
                case CardName.TestFastMultiActivatedAbilityDrawCardCharacter:
                    serializer.Serialize(writer, "TestFastMultiActivatedAbilityDrawCardCharacter");
                    return;
                case CardName.TestForeseeOne:
                    serializer.Serialize(writer, "TestForeseeOne");
                    return;
                case CardName.TestForeseeOneDrawACard:
                    serializer.Serialize(writer, "TestForeseeOneDrawACard");
                    return;
                case CardName.TestForeseeOneDrawReclaim:
                    serializer.Serialize(writer, "TestForeseeOneDrawReclaim");
                    return;
                case CardName.TestForeseeOneReclaim:
                    serializer.Serialize(writer, "TestForeseeOneReclaim");
                    return;
                case CardName.TestForeseeTwo:
                    serializer.Serialize(writer, "TestForeseeTwo");
                    return;
                case CardName.TestModalDrawOneOrDissolveEnemy:
                    serializer.Serialize(writer, "TestModalDrawOneOrDissolveEnemy");
                    return;
                case CardName.TestModalDrawOneOrDrawTwo:
                    serializer.Serialize(writer, "TestModalDrawOneOrDrawTwo");
                    return;
                case CardName.TestModalReturnToHandOrDrawTwo:
                    serializer.Serialize(writer, "TestModalReturnToHandOrDrawTwo");
                    return;
                case CardName.TestMultiActivatedAbilityDrawCardCharacter:
                    serializer.Serialize(writer, "TestMultiActivatedAbilityDrawCardCharacter");
                    return;
                case CardName.TestNamedDissolve:
                    serializer.Serialize(writer, "TestNamedDissolve");
                    return;
                case CardName.TestPreventDissolveThisTurn:
                    serializer.Serialize(writer, "TestPreventDissolveThisTurn");
                    return;
                case CardName.TestReturnOneOrTwoVoidEventCardsToHand:
                    serializer.Serialize(writer, "TestReturnOneOrTwoVoidEventCardsToHand");
                    return;
                case CardName.TestReturnToHand:
                    serializer.Serialize(writer, "TestReturnToHand");
                    return;
                case CardName.TestReturnVoidCardToHand:
                    serializer.Serialize(writer, "TestReturnVoidCardToHand");
                    return;
                case CardName.TestTriggerGainSparkOnPlayCardEnemyTurn:
                    serializer.Serialize(writer, "TestTriggerGainSparkOnPlayCardEnemyTurn");
                    return;
                case CardName.TestTriggerGainSparkWhenMaterializeAnotherCharacter:
                    serializer.Serialize(writer, "TestTriggerGainSparkWhenMaterializeAnotherCharacter");
                    return;
                case CardName.TestTriggerGainTwoSparkOnPlayCardEnemyTurn:
                    serializer.Serialize(writer, "TestTriggerGainTwoSparkOnPlayCardEnemyTurn");
                    return;
                case CardName.TestVanillaCharacter:
                    serializer.Serialize(writer, "TestVanillaCharacter");
                    return;
                case CardName.TestVariableEnergyDraw:
                    serializer.Serialize(writer, "TestVariableEnergyDraw");
                    return;
            }
            throw new Exception("Cannot marshal type CardName");
        }

        public static readonly CardNameConverter Singleton = new CardNameConverter();
    }

    internal class PlayerNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PlayerName) || t == typeof(PlayerName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "One":
                    return PlayerName.One;
                case "Two":
                    return PlayerName.Two;
            }
            throw new Exception("Cannot unmarshal type PlayerName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PlayerName)untypedValue;
            switch (value)
            {
                case PlayerName.One:
                    serializer.Serialize(writer, "One");
                    return;
                case PlayerName.Two:
                    serializer.Serialize(writer, "Two");
                    return;
            }
            throw new Exception("Cannot marshal type PlayerName");
        }

        public static readonly PlayerNameConverter Singleton = new PlayerNameConverter();
    }

    internal class DebugBattleActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugBattleActionEnum) || t == typeof(DebugBattleActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "OpponentContinue")
            {
                return DebugBattleActionEnum.OpponentContinue;
            }
            throw new Exception("Cannot unmarshal type DebugBattleActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DebugBattleActionEnum)untypedValue;
            if (value == DebugBattleActionEnum.OpponentContinue)
            {
                serializer.Serialize(writer, "OpponentContinue");
                return;
            }
            throw new Exception("Cannot marshal type DebugBattleActionEnum");
        }

        public static readonly DebugBattleActionEnumConverter Singleton = new DebugBattleActionEnumConverter();
    }

    internal class PlayCardFromVoidConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PlayCardFromVoid) || t == typeof(PlayCardFromVoid?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new PlayCardFromVoid { Integer = integerValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AbilityId>(reader);
                    return new PlayCardFromVoid { AbilityId = objectValue };
            }
            throw new Exception("Cannot unmarshal type PlayCardFromVoid");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PlayCardFromVoid)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.AbilityId != null)
            {
                serializer.Serialize(writer, value.AbilityId);
                return;
            }
            throw new Exception("Cannot marshal type PlayCardFromVoid");
        }

        public static readonly PlayCardFromVoidConverter Singleton = new PlayCardFromVoidConverter();
    }

    internal class CardOrderSelectionTargetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardOrderSelectionTarget) || t == typeof(CardOrderSelectionTarget?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "Void")
                    {
                        return new CardOrderSelectionTarget { Enum = CardOrderSelectionTargetEnum.Void };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<CardOrderSelectionTargetClass>(reader);
                    return new CardOrderSelectionTarget { CardOrderSelectionTargetClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type CardOrderSelectionTarget");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CardOrderSelectionTarget)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == CardOrderSelectionTargetEnum.Void)
                {
                    serializer.Serialize(writer, "Void");
                    return;
                }
            }
            if (value.CardOrderSelectionTargetClass != null)
            {
                serializer.Serialize(writer, value.CardOrderSelectionTargetClass);
                return;
            }
            throw new Exception("Cannot marshal type CardOrderSelectionTarget");
        }

        public static readonly CardOrderSelectionTargetConverter Singleton = new CardOrderSelectionTargetConverter();
    }

    internal class CardOrderSelectionTargetEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardOrderSelectionTargetEnum) || t == typeof(CardOrderSelectionTargetEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Void")
            {
                return CardOrderSelectionTargetEnum.Void;
            }
            throw new Exception("Cannot unmarshal type CardOrderSelectionTargetEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardOrderSelectionTargetEnum)untypedValue;
            if (value == CardOrderSelectionTargetEnum.Void)
            {
                serializer.Serialize(writer, "Void");
                return;
            }
            throw new Exception("Cannot marshal type CardOrderSelectionTargetEnum");
        }

        public static readonly CardOrderSelectionTargetEnumConverter Singleton = new CardOrderSelectionTargetEnumConverter();
    }

    internal class BattleActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleActionEnum) || t == typeof(BattleActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EndTurn":
                    return BattleActionEnum.EndTurn;
                case "PassPriority":
                    return BattleActionEnum.PassPriority;
                case "StartNextTurn":
                    return BattleActionEnum.StartNextTurn;
                case "SubmitDeckCardOrder":
                    return BattleActionEnum.SubmitDeckCardOrder;
                case "SubmitMulligan":
                    return BattleActionEnum.SubmitMulligan;
                case "SubmitVoidCardTargets":
                    return BattleActionEnum.SubmitVoidCardTargets;
            }
            throw new Exception("Cannot unmarshal type BattleActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattleActionEnum)untypedValue;
            switch (value)
            {
                case BattleActionEnum.EndTurn:
                    serializer.Serialize(writer, "EndTurn");
                    return;
                case BattleActionEnum.PassPriority:
                    serializer.Serialize(writer, "PassPriority");
                    return;
                case BattleActionEnum.StartNextTurn:
                    serializer.Serialize(writer, "StartNextTurn");
                    return;
                case BattleActionEnum.SubmitDeckCardOrder:
                    serializer.Serialize(writer, "SubmitDeckCardOrder");
                    return;
                case BattleActionEnum.SubmitMulligan:
                    serializer.Serialize(writer, "SubmitMulligan");
                    return;
                case BattleActionEnum.SubmitVoidCardTargets:
                    serializer.Serialize(writer, "SubmitVoidCardTargets");
                    return;
            }
            throw new Exception("Cannot marshal type BattleActionEnum");
        }

        public static readonly BattleActionEnumConverter Singleton = new BattleActionEnumConverter();
    }

    internal class BattleDisplayActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleDisplayAction) || t == typeof(BattleDisplayAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "CloseCardBrowser":
                            return new BattleDisplayAction { Enum = BattleDisplayActionEnum.CloseCardBrowser };
                        case "CloseCurrentPanel":
                            return new BattleDisplayAction { Enum = BattleDisplayActionEnum.CloseCurrentPanel };
                        case "ToggleStackVisibility":
                            return new BattleDisplayAction { Enum = BattleDisplayActionEnum.ToggleStackVisibility };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BattleDisplayActionClass>(reader);
                    return new BattleDisplayAction { BattleDisplayActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type BattleDisplayAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BattleDisplayAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BattleDisplayActionEnum.CloseCardBrowser:
                        serializer.Serialize(writer, "CloseCardBrowser");
                        return;
                    case BattleDisplayActionEnum.CloseCurrentPanel:
                        serializer.Serialize(writer, "CloseCurrentPanel");
                        return;
                    case BattleDisplayActionEnum.ToggleStackVisibility:
                        serializer.Serialize(writer, "ToggleStackVisibility");
                        return;
                }
            }
            if (value.BattleDisplayActionClass != null)
            {
                serializer.Serialize(writer, value.BattleDisplayActionClass);
                return;
            }
            throw new Exception("Cannot marshal type BattleDisplayAction");
        }

        public static readonly BattleDisplayActionConverter Singleton = new BattleDisplayActionConverter();
    }

    internal class CardBrowserTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CardBrowserType) || t == typeof(CardBrowserType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EnemyDeck":
                    return CardBrowserType.EnemyDeck;
                case "EnemyStatus":
                    return CardBrowserType.EnemyStatus;
                case "EnemyVoid":
                    return CardBrowserType.EnemyVoid;
                case "UserDeck":
                    return CardBrowserType.UserDeck;
                case "UserStatus":
                    return CardBrowserType.UserStatus;
                case "UserVoid":
                    return CardBrowserType.UserVoid;
            }
            throw new Exception("Cannot unmarshal type CardBrowserType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CardBrowserType)untypedValue;
            switch (value)
            {
                case CardBrowserType.EnemyDeck:
                    serializer.Serialize(writer, "EnemyDeck");
                    return;
                case CardBrowserType.EnemyStatus:
                    serializer.Serialize(writer, "EnemyStatus");
                    return;
                case CardBrowserType.EnemyVoid:
                    serializer.Serialize(writer, "EnemyVoid");
                    return;
                case CardBrowserType.UserDeck:
                    serializer.Serialize(writer, "UserDeck");
                    return;
                case CardBrowserType.UserStatus:
                    serializer.Serialize(writer, "UserStatus");
                    return;
                case CardBrowserType.UserVoid:
                    serializer.Serialize(writer, "UserVoid");
                    return;
            }
            throw new Exception("Cannot marshal type CardBrowserType");
        }

        public static readonly CardBrowserTypeConverter Singleton = new CardBrowserTypeConverter();
    }

    internal class PanelAddressConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PanelAddress) || t == typeof(PanelAddress?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "AddCardToHand":
                            return new PanelAddress { Enum = PanelAddressEnum.AddCardToHand };
                        case "Developer":
                            return new PanelAddress { Enum = PanelAddressEnum.Developer };
                        case "PlayOpponentCard":
                            return new PanelAddress { Enum = PanelAddressEnum.PlayOpponentCard };
                        case "SetOpponentAgent":
                            return new PanelAddress { Enum = PanelAddressEnum.SetOpponentAgent };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PanelAddressClass>(reader);
                    return new PanelAddress { PanelAddressClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type PanelAddress");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PanelAddress)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PanelAddressEnum.AddCardToHand:
                        serializer.Serialize(writer, "AddCardToHand");
                        return;
                    case PanelAddressEnum.Developer:
                        serializer.Serialize(writer, "Developer");
                        return;
                    case PanelAddressEnum.PlayOpponentCard:
                        serializer.Serialize(writer, "PlayOpponentCard");
                        return;
                    case PanelAddressEnum.SetOpponentAgent:
                        serializer.Serialize(writer, "SetOpponentAgent");
                        return;
                }
            }
            if (value.PanelAddressClass != null)
            {
                serializer.Serialize(writer, value.PanelAddressClass);
                return;
            }
            throw new Exception("Cannot marshal type PanelAddress");
        }

        public static readonly PanelAddressConverter Singleton = new PanelAddressConverter();
    }

    internal class PanelAddressEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PanelAddressEnum) || t == typeof(PanelAddressEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AddCardToHand":
                    return PanelAddressEnum.AddCardToHand;
                case "Developer":
                    return PanelAddressEnum.Developer;
                case "PlayOpponentCard":
                    return PanelAddressEnum.PlayOpponentCard;
                case "SetOpponentAgent":
                    return PanelAddressEnum.SetOpponentAgent;
            }
            throw new Exception("Cannot unmarshal type PanelAddressEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PanelAddressEnum)untypedValue;
            switch (value)
            {
                case PanelAddressEnum.AddCardToHand:
                    serializer.Serialize(writer, "AddCardToHand");
                    return;
                case PanelAddressEnum.Developer:
                    serializer.Serialize(writer, "Developer");
                    return;
                case PanelAddressEnum.PlayOpponentCard:
                    serializer.Serialize(writer, "PlayOpponentCard");
                    return;
                case PanelAddressEnum.SetOpponentAgent:
                    serializer.Serialize(writer, "SetOpponentAgent");
                    return;
            }
            throw new Exception("Cannot marshal type PanelAddressEnum");
        }

        public static readonly PanelAddressEnumConverter Singleton = new PanelAddressEnumConverter();
    }

    internal class BattleDisplayActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleDisplayActionEnum) || t == typeof(BattleDisplayActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CloseCardBrowser":
                    return BattleDisplayActionEnum.CloseCardBrowser;
                case "CloseCurrentPanel":
                    return BattleDisplayActionEnum.CloseCurrentPanel;
                case "ToggleStackVisibility":
                    return BattleDisplayActionEnum.ToggleStackVisibility;
            }
            throw new Exception("Cannot unmarshal type BattleDisplayActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattleDisplayActionEnum)untypedValue;
            switch (value)
            {
                case BattleDisplayActionEnum.CloseCardBrowser:
                    serializer.Serialize(writer, "CloseCardBrowser");
                    return;
                case BattleDisplayActionEnum.CloseCurrentPanel:
                    serializer.Serialize(writer, "CloseCurrentPanel");
                    return;
                case BattleDisplayActionEnum.ToggleStackVisibility:
                    serializer.Serialize(writer, "ToggleStackVisibility");
                    return;
            }
            throw new Exception("Cannot marshal type BattleDisplayActionEnum");
        }

        public static readonly BattleDisplayActionEnumConverter Singleton = new BattleDisplayActionEnumConverter();
    }

    internal class DebugActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugAction) || t == typeof(DebugAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "ApplyTestScenarioAction":
                            return new DebugAction { Enum = DebugActionEnum.ApplyTestScenarioAction };
                        case "RestartBattle":
                            return new DebugAction { Enum = DebugActionEnum.RestartBattle };
                        case "SetOpponentAsHuman":
                            return new DebugAction { Enum = DebugActionEnum.SetOpponentAsHuman };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DebugActionClass>(reader);
                    return new DebugAction { DebugActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type DebugAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DebugAction)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case DebugActionEnum.ApplyTestScenarioAction:
                        serializer.Serialize(writer, "ApplyTestScenarioAction");
                        return;
                    case DebugActionEnum.RestartBattle:
                        serializer.Serialize(writer, "RestartBattle");
                        return;
                    case DebugActionEnum.SetOpponentAsHuman:
                        serializer.Serialize(writer, "SetOpponentAsHuman");
                        return;
                }
            }
            if (value.DebugActionClass != null)
            {
                serializer.Serialize(writer, value.DebugActionClass);
                return;
            }
            throw new Exception("Cannot marshal type DebugAction");
        }

        public static readonly DebugActionConverter Singleton = new DebugActionConverter();
    }

    internal class TestDeckNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TestDeckName) || t == typeof(TestDeckName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CoreEleven":
                    return TestDeckName.CoreEleven;
                case "StartingFive":
                    return TestDeckName.StartingFive;
            }
            throw new Exception("Cannot unmarshal type TestDeckName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TestDeckName)untypedValue;
            switch (value)
            {
                case TestDeckName.CoreEleven:
                    serializer.Serialize(writer, "CoreEleven");
                    return;
                case TestDeckName.StartingFive:
                    serializer.Serialize(writer, "StartingFive");
                    return;
            }
            throw new Exception("Cannot marshal type TestDeckName");
        }

        public static readonly TestDeckNameConverter Singleton = new TestDeckNameConverter();
    }

    internal class DebugActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DebugActionEnum) || t == typeof(DebugActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ApplyTestScenarioAction":
                    return DebugActionEnum.ApplyTestScenarioAction;
                case "RestartBattle":
                    return DebugActionEnum.RestartBattle;
                case "SetOpponentAsHuman":
                    return DebugActionEnum.SetOpponentAsHuman;
            }
            throw new Exception("Cannot unmarshal type DebugActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DebugActionEnum)untypedValue;
            switch (value)
            {
                case DebugActionEnum.ApplyTestScenarioAction:
                    serializer.Serialize(writer, "ApplyTestScenarioAction");
                    return;
                case DebugActionEnum.RestartBattle:
                    serializer.Serialize(writer, "RestartBattle");
                    return;
                case DebugActionEnum.SetOpponentAsHuman:
                    serializer.Serialize(writer, "SetOpponentAsHuman");
                    return;
            }
            throw new Exception("Cannot marshal type DebugActionEnum");
        }

        public static readonly DebugActionEnumConverter Singleton = new DebugActionEnumConverter();
    }

    internal class GameActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameActionEnum) || t == typeof(GameActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "NoOp")
            {
                return GameActionEnum.NoOp;
            }
            throw new Exception("Cannot unmarshal type GameActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GameActionEnum)untypedValue;
            if (value == GameActionEnum.NoOp)
            {
                serializer.Serialize(writer, "NoOp");
                return;
            }
            throw new Exception("Cannot marshal type GameActionEnum");
        }

        public static readonly GameActionEnumConverter Singleton = new GameActionEnumConverter();
    }

    internal class FlexAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexAlign) || t == typeof(FlexAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Auto":
                    return FlexAlign.Auto;
                case "Center":
                    return FlexAlign.Center;
                case "FlexEnd":
                    return FlexAlign.FlexEnd;
                case "FlexStart":
                    return FlexAlign.FlexStart;
                case "Stretch":
                    return FlexAlign.Stretch;
            }
            throw new Exception("Cannot unmarshal type FlexAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexAlign)untypedValue;
            switch (value)
            {
                case FlexAlign.Auto:
                    serializer.Serialize(writer, "Auto");
                    return;
                case FlexAlign.Center:
                    serializer.Serialize(writer, "Center");
                    return;
                case FlexAlign.FlexEnd:
                    serializer.Serialize(writer, "FlexEnd");
                    return;
                case FlexAlign.FlexStart:
                    serializer.Serialize(writer, "FlexStart");
                    return;
                case FlexAlign.Stretch:
                    serializer.Serialize(writer, "Stretch");
                    return;
            }
            throw new Exception("Cannot marshal type FlexAlign");
        }

        public static readonly FlexAlignConverter Singleton = new FlexAlignConverter();
    }

    internal class DimensionUnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DimensionUnit) || t == typeof(DimensionUnit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Percentage":
                    return DimensionUnit.Percentage;
                case "Pixels":
                    return DimensionUnit.Pixels;
                case "SafeAreaBottomInset":
                    return DimensionUnit.SafeAreaBottomInset;
                case "SafeAreaLeftInset":
                    return DimensionUnit.SafeAreaLeftInset;
                case "SafeAreaRightInset":
                    return DimensionUnit.SafeAreaRightInset;
                case "SafeAreaTopInset":
                    return DimensionUnit.SafeAreaTopInset;
                case "ViewportHeight":
                    return DimensionUnit.ViewportHeight;
                case "ViewportWidth":
                    return DimensionUnit.ViewportWidth;
            }
            throw new Exception("Cannot unmarshal type DimensionUnit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DimensionUnit)untypedValue;
            switch (value)
            {
                case DimensionUnit.Percentage:
                    serializer.Serialize(writer, "Percentage");
                    return;
                case DimensionUnit.Pixels:
                    serializer.Serialize(writer, "Pixels");
                    return;
                case DimensionUnit.SafeAreaBottomInset:
                    serializer.Serialize(writer, "SafeAreaBottomInset");
                    return;
                case DimensionUnit.SafeAreaLeftInset:
                    serializer.Serialize(writer, "SafeAreaLeftInset");
                    return;
                case DimensionUnit.SafeAreaRightInset:
                    serializer.Serialize(writer, "SafeAreaRightInset");
                    return;
                case DimensionUnit.SafeAreaTopInset:
                    serializer.Serialize(writer, "SafeAreaTopInset");
                    return;
                case DimensionUnit.ViewportHeight:
                    serializer.Serialize(writer, "ViewportHeight");
                    return;
                case DimensionUnit.ViewportWidth:
                    serializer.Serialize(writer, "ViewportWidth");
                    return;
            }
            throw new Exception("Cannot marshal type DimensionUnit");
        }

        public static readonly DimensionUnitConverter Singleton = new DimensionUnitConverter();
    }

    internal class FlexDisplayStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDisplayStyle) || t == typeof(FlexDisplayStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Flex":
                    return FlexDisplayStyle.Flex;
                case "None":
                    return FlexDisplayStyle.None;
            }
            throw new Exception("Cannot unmarshal type FlexDisplayStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDisplayStyle)untypedValue;
            switch (value)
            {
                case FlexDisplayStyle.Flex:
                    serializer.Serialize(writer, "Flex");
                    return;
                case FlexDisplayStyle.None:
                    serializer.Serialize(writer, "None");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDisplayStyle");
        }

        public static readonly FlexDisplayStyleConverter Singleton = new FlexDisplayStyleConverter();
    }

    internal class FlexDirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexDirection) || t == typeof(FlexDirection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Column":
                    return FlexDirection.Column;
                case "ColumnReverse":
                    return FlexDirection.ColumnReverse;
                case "Row":
                    return FlexDirection.Row;
                case "RowReverse":
                    return FlexDirection.RowReverse;
            }
            throw new Exception("Cannot unmarshal type FlexDirection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexDirection)untypedValue;
            switch (value)
            {
                case FlexDirection.Column:
                    serializer.Serialize(writer, "Column");
                    return;
                case FlexDirection.ColumnReverse:
                    serializer.Serialize(writer, "ColumnReverse");
                    return;
                case FlexDirection.Row:
                    serializer.Serialize(writer, "Row");
                    return;
                case FlexDirection.RowReverse:
                    serializer.Serialize(writer, "RowReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexDirection");
        }

        public static readonly FlexDirectionConverter Singleton = new FlexDirectionConverter();
    }

    internal class FontStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontStyle) || t == typeof(FontStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Bold":
                    return FontStyle.Bold;
                case "BoldAndItalic":
                    return FontStyle.BoldAndItalic;
                case "Italic":
                    return FontStyle.Italic;
                case "Normal":
                    return FontStyle.Normal;
            }
            throw new Exception("Cannot unmarshal type FontStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontStyle)untypedValue;
            switch (value)
            {
                case FontStyle.Bold:
                    serializer.Serialize(writer, "Bold");
                    return;
                case FontStyle.BoldAndItalic:
                    serializer.Serialize(writer, "BoldAndItalic");
                    return;
                case FontStyle.Italic:
                    serializer.Serialize(writer, "Italic");
                    return;
                case FontStyle.Normal:
                    serializer.Serialize(writer, "Normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontStyle");
        }

        public static readonly FontStyleConverter Singleton = new FontStyleConverter();
    }

    internal class FlexJustifyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexJustify) || t == typeof(FlexJustify?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Center":
                    return FlexJustify.Center;
                case "FlexEnd":
                    return FlexJustify.FlexEnd;
                case "FlexStart":
                    return FlexJustify.FlexStart;
                case "SpaceAround":
                    return FlexJustify.SpaceAround;
                case "SpaceBetween":
                    return FlexJustify.SpaceBetween;
            }
            throw new Exception("Cannot unmarshal type FlexJustify");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexJustify)untypedValue;
            switch (value)
            {
                case FlexJustify.Center:
                    serializer.Serialize(writer, "Center");
                    return;
                case FlexJustify.FlexEnd:
                    serializer.Serialize(writer, "FlexEnd");
                    return;
                case FlexJustify.FlexStart:
                    serializer.Serialize(writer, "FlexStart");
                    return;
                case FlexJustify.SpaceAround:
                    serializer.Serialize(writer, "SpaceAround");
                    return;
                case FlexJustify.SpaceBetween:
                    serializer.Serialize(writer, "SpaceBetween");
                    return;
            }
            throw new Exception("Cannot marshal type FlexJustify");
        }

        public static readonly FlexJustifyConverter Singleton = new FlexJustifyConverter();
    }

    internal class FlexVisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexVisibility) || t == typeof(FlexVisibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Hidden":
                    return FlexVisibility.Hidden;
                case "Visible":
                    return FlexVisibility.Visible;
            }
            throw new Exception("Cannot unmarshal type FlexVisibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexVisibility)untypedValue;
            switch (value)
            {
                case FlexVisibility.Hidden:
                    serializer.Serialize(writer, "Hidden");
                    return;
                case FlexVisibility.Visible:
                    serializer.Serialize(writer, "Visible");
                    return;
            }
            throw new Exception("Cannot marshal type FlexVisibility");
        }

        public static readonly FlexVisibilityConverter Singleton = new FlexVisibilityConverter();
    }

    internal class OverflowClipBoxConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OverflowClipBox) || t == typeof(OverflowClipBox?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ContentBox":
                    return OverflowClipBox.ContentBox;
                case "PaddingBox":
                    return OverflowClipBox.PaddingBox;
            }
            throw new Exception("Cannot unmarshal type OverflowClipBox");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OverflowClipBox)untypedValue;
            switch (value)
            {
                case OverflowClipBox.ContentBox:
                    serializer.Serialize(writer, "ContentBox");
                    return;
                case OverflowClipBox.PaddingBox:
                    serializer.Serialize(writer, "PaddingBox");
                    return;
            }
            throw new Exception("Cannot marshal type OverflowClipBox");
        }

        public static readonly OverflowClipBoxConverter Singleton = new OverflowClipBoxConverter();
    }

    internal class FlexPickingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexPickingMode) || t == typeof(FlexPickingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Ignore":
                    return FlexPickingMode.Ignore;
                case "Position":
                    return FlexPickingMode.Position;
            }
            throw new Exception("Cannot unmarshal type FlexPickingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexPickingMode)untypedValue;
            switch (value)
            {
                case FlexPickingMode.Ignore:
                    serializer.Serialize(writer, "Ignore");
                    return;
                case FlexPickingMode.Position:
                    serializer.Serialize(writer, "Position");
                    return;
            }
            throw new Exception("Cannot marshal type FlexPickingMode");
        }

        public static readonly FlexPickingModeConverter Singleton = new FlexPickingModeConverter();
    }

    internal class FlexPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexPosition) || t == typeof(FlexPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Absolute":
                    return FlexPosition.Absolute;
                case "Relative":
                    return FlexPosition.Relative;
            }
            throw new Exception("Cannot unmarshal type FlexPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexPosition)untypedValue;
            switch (value)
            {
                case FlexPosition.Absolute:
                    serializer.Serialize(writer, "Absolute");
                    return;
                case FlexPosition.Relative:
                    serializer.Serialize(writer, "Relative");
                    return;
            }
            throw new Exception("Cannot marshal type FlexPosition");
        }

        public static readonly FlexPositionConverter Singleton = new FlexPositionConverter();
    }

    internal class TextAlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextAlign) || t == typeof(TextAlign?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "LowerCenter":
                    return TextAlign.LowerCenter;
                case "LowerLeft":
                    return TextAlign.LowerLeft;
                case "LowerRight":
                    return TextAlign.LowerRight;
                case "MiddleCenter":
                    return TextAlign.MiddleCenter;
                case "MiddleLeft":
                    return TextAlign.MiddleLeft;
                case "MiddleRight":
                    return TextAlign.MiddleRight;
                case "UpperCenter":
                    return TextAlign.UpperCenter;
                case "UpperLeft":
                    return TextAlign.UpperLeft;
                case "UpperRight":
                    return TextAlign.UpperRight;
            }
            throw new Exception("Cannot unmarshal type TextAlign");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextAlign)untypedValue;
            switch (value)
            {
                case TextAlign.LowerCenter:
                    serializer.Serialize(writer, "LowerCenter");
                    return;
                case TextAlign.LowerLeft:
                    serializer.Serialize(writer, "LowerLeft");
                    return;
                case TextAlign.LowerRight:
                    serializer.Serialize(writer, "LowerRight");
                    return;
                case TextAlign.MiddleCenter:
                    serializer.Serialize(writer, "MiddleCenter");
                    return;
                case TextAlign.MiddleLeft:
                    serializer.Serialize(writer, "MiddleLeft");
                    return;
                case TextAlign.MiddleRight:
                    serializer.Serialize(writer, "MiddleRight");
                    return;
                case TextAlign.UpperCenter:
                    serializer.Serialize(writer, "UpperCenter");
                    return;
                case TextAlign.UpperLeft:
                    serializer.Serialize(writer, "UpperLeft");
                    return;
                case TextAlign.UpperRight:
                    serializer.Serialize(writer, "UpperRight");
                    return;
            }
            throw new Exception("Cannot marshal type TextAlign");
        }

        public static readonly TextAlignConverter Singleton = new TextAlignConverter();
    }

    internal class TextOverflowConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflow) || t == typeof(TextOverflow?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Clip":
                    return TextOverflow.Clip;
                case "Ellipsis":
                    return TextOverflow.Ellipsis;
            }
            throw new Exception("Cannot unmarshal type TextOverflow");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflow)untypedValue;
            switch (value)
            {
                case TextOverflow.Clip:
                    serializer.Serialize(writer, "Clip");
                    return;
                case TextOverflow.Ellipsis:
                    serializer.Serialize(writer, "Ellipsis");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflow");
        }

        public static readonly TextOverflowConverter Singleton = new TextOverflowConverter();
    }

    internal class TextOverflowPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOverflowPosition) || t == typeof(TextOverflowPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "End":
                    return TextOverflowPosition.End;
                case "Middle":
                    return TextOverflowPosition.Middle;
                case "Start":
                    return TextOverflowPosition.Start;
            }
            throw new Exception("Cannot unmarshal type TextOverflowPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextOverflowPosition)untypedValue;
            switch (value)
            {
                case TextOverflowPosition.End:
                    serializer.Serialize(writer, "End");
                    return;
                case TextOverflowPosition.Middle:
                    serializer.Serialize(writer, "Middle");
                    return;
                case TextOverflowPosition.Start:
                    serializer.Serialize(writer, "Start");
                    return;
            }
            throw new Exception("Cannot marshal type TextOverflowPosition");
        }

        public static readonly TextOverflowPositionConverter Singleton = new TextOverflowPositionConverter();
    }

    internal class EasingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EasingMode) || t == typeof(EasingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Ease":
                    return EasingMode.Ease;
                case "EaseIn":
                    return EasingMode.EaseIn;
                case "EaseInBack":
                    return EasingMode.EaseInBack;
                case "EaseInBounce":
                    return EasingMode.EaseInBounce;
                case "EaseInCirc":
                    return EasingMode.EaseInCirc;
                case "EaseInCubic":
                    return EasingMode.EaseInCubic;
                case "EaseInElastic":
                    return EasingMode.EaseInElastic;
                case "EaseInOut":
                    return EasingMode.EaseInOut;
                case "EaseInOutBack":
                    return EasingMode.EaseInOutBack;
                case "EaseInOutBounce":
                    return EasingMode.EaseInOutBounce;
                case "EaseInOutCirc":
                    return EasingMode.EaseInOutCirc;
                case "EaseInOutCubic":
                    return EasingMode.EaseInOutCubic;
                case "EaseInOutElastic":
                    return EasingMode.EaseInOutElastic;
                case "EaseInOutSine":
                    return EasingMode.EaseInOutSine;
                case "EaseInSine":
                    return EasingMode.EaseInSine;
                case "EaseOut":
                    return EasingMode.EaseOut;
                case "EaseOutBack":
                    return EasingMode.EaseOutBack;
                case "EaseOutBounce":
                    return EasingMode.EaseOutBounce;
                case "EaseOutCirc":
                    return EasingMode.EaseOutCirc;
                case "EaseOutCubic":
                    return EasingMode.EaseOutCubic;
                case "EaseOutElastic":
                    return EasingMode.EaseOutElastic;
                case "EaseOutSine":
                    return EasingMode.EaseOutSine;
                case "Linear":
                    return EasingMode.Linear;
            }
            throw new Exception("Cannot unmarshal type EasingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EasingMode)untypedValue;
            switch (value)
            {
                case EasingMode.Ease:
                    serializer.Serialize(writer, "Ease");
                    return;
                case EasingMode.EaseIn:
                    serializer.Serialize(writer, "EaseIn");
                    return;
                case EasingMode.EaseInBack:
                    serializer.Serialize(writer, "EaseInBack");
                    return;
                case EasingMode.EaseInBounce:
                    serializer.Serialize(writer, "EaseInBounce");
                    return;
                case EasingMode.EaseInCirc:
                    serializer.Serialize(writer, "EaseInCirc");
                    return;
                case EasingMode.EaseInCubic:
                    serializer.Serialize(writer, "EaseInCubic");
                    return;
                case EasingMode.EaseInElastic:
                    serializer.Serialize(writer, "EaseInElastic");
                    return;
                case EasingMode.EaseInOut:
                    serializer.Serialize(writer, "EaseInOut");
                    return;
                case EasingMode.EaseInOutBack:
                    serializer.Serialize(writer, "EaseInOutBack");
                    return;
                case EasingMode.EaseInOutBounce:
                    serializer.Serialize(writer, "EaseInOutBounce");
                    return;
                case EasingMode.EaseInOutCirc:
                    serializer.Serialize(writer, "EaseInOutCirc");
                    return;
                case EasingMode.EaseInOutCubic:
                    serializer.Serialize(writer, "EaseInOutCubic");
                    return;
                case EasingMode.EaseInOutElastic:
                    serializer.Serialize(writer, "EaseInOutElastic");
                    return;
                case EasingMode.EaseInOutSine:
                    serializer.Serialize(writer, "EaseInOutSine");
                    return;
                case EasingMode.EaseInSine:
                    serializer.Serialize(writer, "EaseInSine");
                    return;
                case EasingMode.EaseOut:
                    serializer.Serialize(writer, "EaseOut");
                    return;
                case EasingMode.EaseOutBack:
                    serializer.Serialize(writer, "EaseOutBack");
                    return;
                case EasingMode.EaseOutBounce:
                    serializer.Serialize(writer, "EaseOutBounce");
                    return;
                case EasingMode.EaseOutCirc:
                    serializer.Serialize(writer, "EaseOutCirc");
                    return;
                case EasingMode.EaseOutCubic:
                    serializer.Serialize(writer, "EaseOutCubic");
                    return;
                case EasingMode.EaseOutElastic:
                    serializer.Serialize(writer, "EaseOutElastic");
                    return;
                case EasingMode.EaseOutSine:
                    serializer.Serialize(writer, "EaseOutSine");
                    return;
                case EasingMode.Linear:
                    serializer.Serialize(writer, "Linear");
                    return;
            }
            throw new Exception("Cannot marshal type EasingMode");
        }

        public static readonly EasingModeConverter Singleton = new EasingModeConverter();
    }

    internal class WhiteSpaceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WhiteSpace) || t == typeof(WhiteSpace?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NoWrap":
                    return WhiteSpace.NoWrap;
                case "Normal":
                    return WhiteSpace.Normal;
            }
            throw new Exception("Cannot unmarshal type WhiteSpace");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WhiteSpace)untypedValue;
            switch (value)
            {
                case WhiteSpace.NoWrap:
                    serializer.Serialize(writer, "NoWrap");
                    return;
                case WhiteSpace.Normal:
                    serializer.Serialize(writer, "Normal");
                    return;
            }
            throw new Exception("Cannot marshal type WhiteSpace");
        }

        public static readonly WhiteSpaceConverter Singleton = new WhiteSpaceConverter();
    }

    internal class FlexWrapConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlexWrap) || t == typeof(FlexWrap?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NoWrap":
                    return FlexWrap.NoWrap;
                case "Wrap":
                    return FlexWrap.Wrap;
                case "WrapReverse":
                    return FlexWrap.WrapReverse;
            }
            throw new Exception("Cannot unmarshal type FlexWrap");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlexWrap)untypedValue;
            switch (value)
            {
                case FlexWrap.NoWrap:
                    serializer.Serialize(writer, "NoWrap");
                    return;
                case FlexWrap.Wrap:
                    serializer.Serialize(writer, "Wrap");
                    return;
                case FlexWrap.WrapReverse:
                    serializer.Serialize(writer, "WrapReverse");
                    return;
            }
            throw new Exception("Cannot marshal type FlexWrap");
        }

        public static readonly FlexWrapConverter Singleton = new FlexWrapConverter();
    }

    internal class ScrollBarVisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScrollBarVisibility) || t == typeof(ScrollBarVisibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AlwaysVisible":
                    return ScrollBarVisibility.AlwaysVisible;
                case "Auto":
                    return ScrollBarVisibility.Auto;
                case "Hidden":
                    return ScrollBarVisibility.Hidden;
            }
            throw new Exception("Cannot unmarshal type ScrollBarVisibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScrollBarVisibility)untypedValue;
            switch (value)
            {
                case ScrollBarVisibility.AlwaysVisible:
                    serializer.Serialize(writer, "AlwaysVisible");
                    return;
                case ScrollBarVisibility.Auto:
                    serializer.Serialize(writer, "Auto");
                    return;
                case ScrollBarVisibility.Hidden:
                    serializer.Serialize(writer, "Hidden");
                    return;
            }
            throw new Exception("Cannot marshal type ScrollBarVisibility");
        }

        public static readonly ScrollBarVisibilityConverter Singleton = new ScrollBarVisibilityConverter();
    }

    internal class TouchScrollBehaviorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TouchScrollBehavior) || t == typeof(TouchScrollBehavior?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Clamped":
                    return TouchScrollBehavior.Clamped;
                case "Elastic":
                    return TouchScrollBehavior.Elastic;
                case "Unrestricted":
                    return TouchScrollBehavior.Unrestricted;
            }
            throw new Exception("Cannot unmarshal type TouchScrollBehavior");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TouchScrollBehavior)untypedValue;
            switch (value)
            {
                case TouchScrollBehavior.Clamped:
                    serializer.Serialize(writer, "Clamped");
                    return;
                case TouchScrollBehavior.Elastic:
                    serializer.Serialize(writer, "Elastic");
                    return;
                case TouchScrollBehavior.Unrestricted:
                    serializer.Serialize(writer, "Unrestricted");
                    return;
            }
            throw new Exception("Cannot marshal type TouchScrollBehavior");
        }

        public static readonly TouchScrollBehaviorConverter Singleton = new TouchScrollBehaviorConverter();
    }

    internal class SliderDirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SliderDirection) || t == typeof(SliderDirection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Horizontal":
                    return SliderDirection.Horizontal;
                case "Vertical":
                    return SliderDirection.Vertical;
            }
            throw new Exception("Cannot unmarshal type SliderDirection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SliderDirection)untypedValue;
            switch (value)
            {
                case SliderDirection.Horizontal:
                    serializer.Serialize(writer, "Horizontal");
                    return;
                case SliderDirection.Vertical:
                    serializer.Serialize(writer, "Vertical");
                    return;
            }
            throw new Exception("Cannot marshal type SliderDirection");
        }

        public static readonly SliderDirectionConverter Singleton = new SliderDirectionConverter();
    }

    internal class StudioTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StudioType) || t == typeof(StudioType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EnemyIdentityCard":
                    return StudioType.EnemyIdentityCard;
                case "EnemyStatus":
                    return StudioType.EnemyStatus;
                case "UserIdentityCard":
                    return StudioType.UserIdentityCard;
                case "UserStatus":
                    return StudioType.UserStatus;
            }
            throw new Exception("Cannot unmarshal type StudioType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StudioType)untypedValue;
            switch (value)
            {
                case StudioType.EnemyIdentityCard:
                    serializer.Serialize(writer, "EnemyIdentityCard");
                    return;
                case StudioType.EnemyStatus:
                    serializer.Serialize(writer, "EnemyStatus");
                    return;
                case StudioType.UserIdentityCard:
                    serializer.Serialize(writer, "UserIdentityCard");
                    return;
                case StudioType.UserStatus:
                    serializer.Serialize(writer, "UserStatus");
                    return;
            }
            throw new Exception("Cannot marshal type StudioType");
        }

        public static readonly StudioTypeConverter Singleton = new StudioTypeConverter();
    }

    internal class ArrowStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ArrowStyle) || t == typeof(ArrowStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Blue":
                    return ArrowStyle.Blue;
                case "Green":
                    return ArrowStyle.Green;
                case "Red":
                    return ArrowStyle.Red;
            }
            throw new Exception("Cannot unmarshal type ArrowStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ArrowStyle)untypedValue;
            switch (value)
            {
                case ArrowStyle.Blue:
                    serializer.Serialize(writer, "Blue");
                    return;
                case ArrowStyle.Green:
                    serializer.Serialize(writer, "Green");
                    return;
                case ArrowStyle.Red:
                    serializer.Serialize(writer, "Red");
                    return;
            }
            throw new Exception("Cannot marshal type ArrowStyle");
        }

        public static readonly ArrowStyleConverter Singleton = new ArrowStyleConverter();
    }

    internal class DisplayedTurnIndicatorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayedTurnIndicator) || t == typeof(DisplayedTurnIndicator?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Left":
                    return DisplayedTurnIndicator.Left;
                case "Right":
                    return DisplayedTurnIndicator.Right;
            }
            throw new Exception("Cannot unmarshal type DisplayedTurnIndicator");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayedTurnIndicator)untypedValue;
            switch (value)
            {
                case DisplayedTurnIndicator.Left:
                    serializer.Serialize(writer, "Left");
                    return;
                case DisplayedTurnIndicator.Right:
                    serializer.Serialize(writer, "Right");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayedTurnIndicator");
        }

        public static readonly DisplayedTurnIndicatorConverter Singleton = new DisplayedTurnIndicatorConverter();
    }

    internal class BattlePreviewStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattlePreviewState) || t == typeof(BattlePreviewState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "None":
                            return new BattlePreviewState { Enum = BattlePreviewStateEnum.None };
                        case "Pending":
                            return new BattlePreviewState { Enum = BattlePreviewStateEnum.Pending };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BattlePreviewStateClass>(reader);
                    return new BattlePreviewState { BattlePreviewStateClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type BattlePreviewState");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BattlePreviewState)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BattlePreviewStateEnum.None:
                        serializer.Serialize(writer, "None");
                        return;
                    case BattlePreviewStateEnum.Pending:
                        serializer.Serialize(writer, "Pending");
                        return;
                }
            }
            if (value.BattlePreviewStateClass != null)
            {
                serializer.Serialize(writer, value.BattlePreviewStateClass);
                return;
            }
            throw new Exception("Cannot marshal type BattlePreviewState");
        }

        public static readonly BattlePreviewStateConverter Singleton = new BattlePreviewStateConverter();
    }

    internal class BattlePreviewStateEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattlePreviewStateEnum) || t == typeof(BattlePreviewStateEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "None":
                    return BattlePreviewStateEnum.None;
                case "Pending":
                    return BattlePreviewStateEnum.Pending;
            }
            throw new Exception("Cannot unmarshal type BattlePreviewStateEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattlePreviewStateEnum)untypedValue;
            switch (value)
            {
                case BattlePreviewStateEnum.None:
                    serializer.Serialize(writer, "None");
                    return;
                case BattlePreviewStateEnum.Pending:
                    serializer.Serialize(writer, "Pending");
                    return;
            }
            throw new Exception("Cannot marshal type BattlePreviewStateEnum");
        }

        public static readonly BattlePreviewStateEnumConverter Singleton = new BattlePreviewStateEnumConverter();
    }

    internal class GameActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GameAction) || t == typeof(GameAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "NoOp")
                    {
                        return new GameAction { Enum = GameActionEnum.NoOp };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<GameActionClass>(reader);
                    return new GameAction { GameActionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type GameAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (GameAction)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == GameActionEnum.NoOp)
                {
                    serializer.Serialize(writer, "NoOp");
                    return;
                }
            }
            if (value.GameActionClass != null)
            {
                serializer.Serialize(writer, value.GameActionClass);
                return;
            }
            throw new Exception("Cannot marshal type GameAction");
        }

        public static readonly GameActionConverter Singleton = new GameActionConverter();
    }

    internal class PollResponseTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PollResponseType) || t == typeof(PollResponseType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Final":
                    return PollResponseType.Final;
                case "Incremental":
                    return PollResponseType.Incremental;
                case "None":
                    return PollResponseType.None;
            }
            throw new Exception("Cannot unmarshal type PollResponseType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PollResponseType)untypedValue;
            switch (value)
            {
                case PollResponseType.Final:
                    serializer.Serialize(writer, "Final");
                    return;
                case PollResponseType.Incremental:
                    serializer.Serialize(writer, "Incremental");
                    return;
                case PollResponseType.None:
                    serializer.Serialize(writer, "None");
                    return;
            }
            throw new Exception("Cannot marshal type PollResponseType");
        }

        public static readonly PollResponseTypeConverter Singleton = new PollResponseTypeConverter();
    }
}
