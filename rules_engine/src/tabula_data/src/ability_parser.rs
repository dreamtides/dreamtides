use std::collections::BTreeMap;
use std::fs;
#[cfg(target_os = "android")]
use std::io::Read;
use std::path::Path;

use ability_data::ability::Ability;
use uuid::Uuid;
#[cfg(target_os = "android")]
use zip::ZipArchive;

use crate::tabula_error::TabulaError;

/// Loads pre-parsed abilities from a JSON file.
///
/// The JSON file maps card UUIDs to their parsed ability lists. This file is
/// generated by the parser to avoid parsing abilities at runtime.
pub fn load_parsed_abilities(path: &Path) -> Result<BTreeMap<Uuid, Vec<Ability>>, TabulaError> {
    let contents = read_file_contents(path)?;
    serde_json::from_str(&contents).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Failed to parse abilities JSON: {e}"),
    })
}

/// Reads file contents as a string, handling Android APK paths.
fn read_file_contents(path: &Path) -> Result<String, TabulaError> {
    let path_str = path.to_string_lossy();
    if path_str.starts_with("jar:file:") {
        read_android_asset(&path_str, path)
    } else {
        read_filesystem_file(path)
    }
}

/// Reads a file from the standard filesystem.
fn read_filesystem_file(path: &Path) -> Result<String, TabulaError> {
    fs::read_to_string(path).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Failed to read file: {e}"),
    })
}

/// Reads a file from an Android APK archive.
#[cfg(target_os = "android")]
fn read_android_asset(jar_url: &str, path: &Path) -> Result<String, TabulaError> {
    let without_prefix =
        jar_url.strip_prefix("jar:file:").ok_or_else(|| TabulaError::AbilityParse {
            file: path.to_path_buf(),
            card_name: String::new(),
            message: "Android jar URL missing jar:file: prefix".to_string(),
        })?;
    let bang_index = without_prefix.find("!/").ok_or_else(|| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Malformed Android jar URL: {jar_url}"),
    })?;
    let (apk_path, entry_path_with_slash) = without_prefix.split_at(bang_index);
    let entry_path = &entry_path_with_slash[2..];
    let mut file = std::fs::File::open(apk_path).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Failed to open APK: {e}"),
    })?;
    let mut zip = ZipArchive::new(&mut file).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Failed to read APK zip: {e}"),
    })?;
    let mut zip_file = zip.by_name(entry_path).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("File not found in APK: {e}"),
    })?;
    let mut buf = Vec::new();
    zip_file.read_to_end(&mut buf).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Failed to read file from APK: {e}"),
    })?;
    String::from_utf8(buf).map_err(|e| TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Invalid UTF-8 in file: {e}"),
    })
}

/// On non-Android platforms, jar:file: URLs are not supported.
#[cfg(not(target_os = "android"))]
fn read_android_asset(jar_url: &str, path: &Path) -> Result<String, TabulaError> {
    Err(TabulaError::AbilityParse {
        file: path.to_path_buf(),
        card_name: String::new(),
        message: format!("Android jar:file: URLs not supported on this platform: {jar_url}"),
    })
}
