use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

use anyhow::Result;

use crate::config::Config;
use crate::git;
use crate::state::{State, WorkerStatus};
use crate::tmux::monitor::{ClaudeState, StateDetector};
use crate::tmux::sender::TmuxSender;
use crate::tmux::session;
use crate::worker::{self, WorkerTransition};

static PATROL_RUNNING: AtomicBool = AtomicBool::new(false);

/// Patrol system configuration
pub struct Patrol {
    interval_secs: u64,
    stuck_timeout_mins: u64,
    nudge_interval_mins: u64,
}

/// Report generated by a patrol run
#[derive(Debug, Default)]
pub struct PatrolReport {
    pub sessions_checked: u32,
    pub transitions_applied: Vec<(String, WorkerTransition)>,
    pub rebases_triggered: Vec<String>,
    pub stuck_workers_nudged: Vec<String>,
    pub errors: Vec<String>,
}

impl Patrol {
    pub fn new(config: &Config) -> Self {
        Self {
            interval_secs: config.defaults.patrol_interval_secs as u64,
            stuck_timeout_mins: 30,
            nudge_interval_mins: 5,
        }
    }

    pub fn should_run(&self, last_run: Instant) -> bool {
        last_run.elapsed() >= Duration::from_secs(self.interval_secs)
    }

    pub fn run_patrol(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        if PATROL_RUNNING.swap(true, Ordering::SeqCst) {
            tracing::debug!("Skipping patrol run - another patrol is in progress");
            return Ok(PatrolReport::default());
        }

        let result = self.run_patrol_impl(state, config);

        PATROL_RUNNING.store(false, Ordering::SeqCst);

        result
    }

    fn run_patrol_impl(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        let mut report = PatrolReport::default();

        self.check_session_health(state, config, &mut report)?;
        self.detect_state_transitions(state, config, &mut report)?;
        self.rebase_pending_reviews(state, &mut report)?;
        self.detect_stuck_workers(state, &mut report)?;

        Ok(report)
    }

    fn check_session_health(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            report.sessions_checked += 1;

            let worker = state.get_worker(&worker_name).unwrap();
            let session_id = worker.session_id.clone();

            if !session::session_exists(&session_id) {
                tracing::warn!(
                    "Worker '{}' session '{}' not found - marking offline",
                    worker_name,
                    session_id
                );
                if let Some(w) = state.get_worker_mut(&worker_name)
                    && let Err(e) = worker::apply_transition(w, WorkerTransition::ToOffline)
                {
                    report
                        .errors
                        .push(format!("Failed to mark worker '{}' offline: {}", worker_name, e));
                }
                continue;
            }

            let pane_command = session::get_pane_command(&session_id).unwrap_or_default();
            if session::is_shell(&pane_command) {
                tracing::warn!(
                    "Worker '{}' Claude process crashed - attempting restart",
                    worker_name
                );

                let worker = state.get_worker(&worker_name).unwrap();
                let worktree_path = PathBuf::from(&worker.worktree_path);

                if let Err(e) =
                    self.attempt_restart(&worker_name, &session_id, &worktree_path, config)
                {
                    report
                        .errors
                        .push(format!("Failed to restart worker '{}': {}", worker_name, e));
                    if let Some(w) = state.get_worker_mut(&worker_name)
                        && let Err(e) = worker::apply_transition(w, WorkerTransition::ToError {
                            reason: "Claude crashed".to_string(),
                        })
                    {
                        report.errors.push(format!(
                            "Failed to mark worker '{}' as error: {}",
                            worker_name, e
                        ));
                    }
                }
            }
        }

        Ok(())
    }

    fn attempt_restart(
        &self,
        worker_name: &str,
        session_id: &str,
        _worktree_path: &Path,
        config: &Config,
    ) -> Result<()> {
        let worker_config = config
            .get_worker(worker_name)
            .ok_or_else(|| anyhow::anyhow!("Worker config not found"))?;
        worker::start_claude_in_session(session_id, worker_config)?;
        Ok(())
    }

    fn detect_state_transitions(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            let current_status = worker.status;
            let session_id = worker.session_id.clone();
            let worktree_path = PathBuf::from(&worker.worktree_path);

            let transition = match current_status {
                WorkerStatus::Working => {
                    self.detect_working_transition(&session_id, &worktree_path)?
                }
                WorkerStatus::Rebasing => {
                    self.detect_rebasing_transition(&session_id, &worktree_path)?
                }
                _ => WorkerTransition::None,
            };

            if transition != WorkerTransition::None
                && let Some(w) = state.get_worker_mut(&worker_name)
            {
                worker::apply_transition(w, transition.clone())?;
                report.transitions_applied.push((worker_name.clone(), transition.clone()));

                if matches!(transition, WorkerTransition::ToNeedsReview { .. })
                    && config.defaults.sound_on_review
                {
                    self.play_sound_notification();
                }
            }
        }

        Ok(())
    }

    fn detect_working_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        let sender = TmuxSender::new();
        let detector = StateDetector::new(sender);

        let claude_state = detector.detect(session_id)?;

        if matches!(claude_state, ClaudeState::Ready) {
            if git::has_uncommitted_changes(worktree_path)? {
                return Ok(WorkerTransition::ToNeedsInput);
            }

            let commit_sha = git::get_head_commit(worktree_path)?;
            return Ok(WorkerTransition::ToNeedsReview { commit_sha });
        }

        Ok(WorkerTransition::None)
    }

    fn detect_rebasing_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        if !git::is_rebase_in_progress(worktree_path) {
            let output = session::capture_pane(session_id, 50)?;

            if output.contains("Successfully rebased") || output.contains("git rebase --continue") {
                let commit_sha = git::get_head_commit(worktree_path)?;
                return Ok(WorkerTransition::ToNeedsReview { commit_sha });
            }

            if output.contains("rebase --abort") {
                return Ok(WorkerTransition::ToNeedsReview {
                    commit_sha: git::get_head_commit(worktree_path)?,
                });
            }
        }

        Ok(WorkerTransition::None)
    }

    fn rebase_pending_reviews(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let workers_to_rebase: Vec<String> = state
            .workers
            .iter()
            .filter(|(_, w)| w.status == WorkerStatus::NeedsReview)
            .map(|(name, _)| name.clone())
            .collect();

        for worker_name in workers_to_rebase {
            let worker = state.get_worker(&worker_name).unwrap();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();
            let commit_sha = worker.commit_sha.clone();

            let current_head = git::get_head_commit(&worktree_path)?;

            let llmc_root = crate::config::get_llmc_root();
            let master_sha = git::get_head_commit(&llmc_root)?;

            if current_head == master_sha || commit_sha == Some(current_head.clone()) {
                continue;
            }

            tracing::info!(
                "Master has advanced - rebasing worker '{}' in needs_review",
                worker_name
            );

            match self.trigger_rebase(&worker_name, &worktree_path, &session_id, state) {
                Ok(()) => {
                    report.rebases_triggered.push(worker_name.clone());
                }
                Err(e) => {
                    report.errors.push(format!("Failed to rebase worker '{}': {}", worker_name, e));
                }
            }
        }

        Ok(())
    }

    fn trigger_rebase(
        &self,
        worker_name: &str,
        worktree_path: &Path,
        session_id: &str,
        state: &mut State,
    ) -> Result<()> {
        let llmc_root = crate::config::get_llmc_root();
        git::fetch_origin(&llmc_root)?;

        let rebase_result = git::rebase_onto(worktree_path, "origin/master")?;

        if !rebase_result.success {
            let worker = state.get_worker_mut(worker_name).unwrap();
            worker::apply_transition(worker, WorkerTransition::ToRebasing)?;

            let conflict_prompt = build_conflict_prompt(&rebase_result.conflicts);

            let sender = TmuxSender::new();
            sender.send(session_id, &conflict_prompt)?;
        }

        Ok(())
    }

    #[expect(clippy::integer_division)]
    fn detect_stuck_workers(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();

        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();

            if worker.status != WorkerStatus::Working {
                continue;
            }

            let minutes_inactive = (now - worker.last_activity_unix) / 60;

            if minutes_inactive >= self.stuck_timeout_mins {
                let nudges_sent = ((minutes_inactive - self.stuck_timeout_mins)
                    / self.nudge_interval_mins) as usize;

                if nudges_sent == 0 {
                    self.send_nudge(&worker_name, &worker.session_id, "initial")?;
                    report.stuck_workers_nudged.push(worker_name.clone());
                } else if nudges_sent == 1 {
                    self.send_nudge(&worker_name, &worker.session_id, "warning")?;
                    report.stuck_workers_nudged.push(worker_name.clone());
                } else if nudges_sent >= 2
                    && let Some(w) = state.get_worker_mut(&worker_name)
                {
                    worker::apply_transition(w, WorkerTransition::ToNeedsInput)?;
                    report
                        .transitions_applied
                        .push((worker_name.clone(), WorkerTransition::ToNeedsInput));
                }
            }
        }

        Ok(())
    }

    fn send_nudge(&self, worker_name: &str, session_id: &str, nudge_type: &str) -> Result<()> {
        let message = match nudge_type {
            "initial" => {
                "You've been working for over 30 minutes. Please provide a status update or commit your work."
            }
            "warning" => {
                "You've been working for over 35 minutes without activity. Please complete your current task or ask for help."
            }
            _ => "Please update your status.",
        };

        tracing::info!("Sending {} nudge to worker '{}'", nudge_type, worker_name);

        let sender = TmuxSender::new();
        sender.send(session_id, message)?;

        Ok(())
    }

    fn play_sound_notification(&self) {
        print!("\x07");
    }
}

fn build_conflict_prompt(conflicts: &[String]) -> String {
    let mut prompt = String::from(
        "A rebase onto master has encountered conflicts.\n\
         \n\
         Conflicting files:\n",
    );

    for file in conflicts {
        let conflict_count = count_conflict_markers(file);
        prompt.push_str(&format!("- {} ({} conflict markers)\n", file, conflict_count));
    }

    prompt.push_str(
        "\n\
         Resolution steps:\n\
         1. Examine conflict markers (<<<<<<, =======, >>>>>>>)\n\
         2. Decide how to resolve each conflict\n\
         3. Remove conflict markers\n\
         4. Stage resolved files: git add <file>\n\
         5. Continue rebase: git rebase --continue\n\
         6. Run validation: just review\n\
         \n\
         Notes:\n\
         - View original versions: git show :2:<file> (ours) :3:<file> (theirs)\n\
         - To abort: git rebase --abort\n",
    );

    prompt
}

fn count_conflict_markers(file: &str) -> usize {
    std::fs::read_to_string(file).map(|content| content.matches("<<<<<<<").count()).unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_should_run() {
        let patrol = Patrol { interval_secs: 60, stuck_timeout_mins: 30, nudge_interval_mins: 5 };

        let now = Instant::now();
        assert!(!patrol.should_run(now));

        let past = now - Duration::from_secs(61);
        assert!(patrol.should_run(past));
    }

    #[test]
    fn test_patrol_report_default() {
        let report = PatrolReport::default();
        assert_eq!(report.sessions_checked, 0);
        assert!(report.transitions_applied.is_empty());
        assert!(report.rebases_triggered.is_empty());
        assert!(report.stuck_workers_nudged.is_empty());
        assert!(report.errors.is_empty());
    }

    #[test]
    fn test_build_conflict_prompt() {
        let conflicts = vec!["src/main.rs".to_string(), "src/lib.rs".to_string()];
        let prompt = build_conflict_prompt(&conflicts);

        assert!(prompt.contains("A rebase onto master has encountered conflicts"));
        assert!(prompt.contains("src/main.rs"));
        assert!(prompt.contains("src/lib.rs"));
        assert!(prompt.contains("Resolution steps:"));
        assert!(prompt.contains("git rebase --continue"));
    }
}
