use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

use anyhow::Result;

use crate::config::Config;
use crate::state::{State, WorkerStatus};
use crate::tmux::sender::TmuxSender;
use crate::tmux::session;
use crate::worker::{self, WorkerTransition};
use crate::{git, recovery, sound};

static PATROL_RUNNING: AtomicBool = AtomicBool::new(false);

/// Patrol system configuration
pub struct Patrol {}

/// Report generated by a patrol run
#[derive(Debug, Default)]
pub struct PatrolReport {
    pub sessions_checked: u32,
    pub transitions_applied: Vec<(String, WorkerTransition)>,
    pub rebases_triggered: Vec<String>,
    pub errors: Vec<String>,
}

impl Patrol {
    pub fn new(_config: &Config) -> Self {
        Self {}
    }

    pub fn run_patrol(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        if PATROL_RUNNING.swap(true, Ordering::SeqCst) {
            tracing::debug!("Skipping patrol run - another patrol is in progress");
            return Ok(PatrolReport::default());
        }

        let result = self.run_patrol_impl(state, config);

        PATROL_RUNNING.store(false, Ordering::SeqCst);

        result
    }

    fn run_patrol_impl(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        let mut report = PatrolReport::default();

        self.check_session_health(state, config, &mut report)?;
        self.check_state_consistency(state, &mut report)?;
        self.detect_state_transitions(state, config, &mut report)?;

        let transitioned_workers: std::collections::HashSet<String> =
            report.transitions_applied.iter().map(|(name, _)| name.clone()).collect();

        self.rebase_pending_reviews(state, &transitioned_workers, &mut report)?;

        Ok(report)
    }

    fn check_session_health(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            report.sessions_checked += 1;

            let worker = state.get_worker(&worker_name).unwrap();
            let session_id = worker.session_id.clone();

            if let Some(worker_mut) = state.get_worker_mut(&worker_name)
                && recovery::should_reset_crash_count(
                    worker_mut,
                    SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
                )
            {
                tracing::info!(
                    "Worker {} crash count expired (24h), resetting from {}",
                    worker_name,
                    worker_mut.crash_count
                );
                worker_mut.crash_count = 0;
                worker_mut.last_crash_unix = None;
            }

            if !session::session_exists(&session_id) {
                tracing::warn!(
                    "Worker '{}' session '{}' not found - marking offline",
                    worker_name,
                    session_id
                );
                if let Some(w) = state.get_worker_mut(&worker_name)
                    && let Err(e) = worker::apply_transition(w, WorkerTransition::ToOffline)
                {
                    report
                        .errors
                        .push(format!("Failed to mark worker '{}' offline: {}", worker_name, e));
                }
                continue;
            }

            let pane_command = session::get_pane_command(&session_id).unwrap_or_default();
            if session::is_shell(&pane_command) {
                tracing::warn!(
                    "Worker '{}' Claude process crashed - attempting restart",
                    worker_name
                );

                let worker = state.get_worker(&worker_name).unwrap();
                let worktree_path = PathBuf::from(&worker.worktree_path);

                if let Err(e) =
                    self.attempt_restart(&worker_name, &session_id, &worktree_path, config)
                {
                    report
                        .errors
                        .push(format!("Failed to restart worker '{}': {}", worker_name, e));
                    if let Some(w) = state.get_worker_mut(&worker_name)
                        && let Err(e) = worker::apply_transition(w, WorkerTransition::ToError {
                            reason: "Claude crashed".to_string(),
                        })
                    {
                        report.errors.push(format!(
                            "Failed to mark worker '{}' as error: {}",
                            worker_name, e
                        ));
                    }
                }
            }
        }

        Ok(())
    }

    fn attempt_restart(
        &self,
        worker_name: &str,
        session_id: &str,
        _worktree_path: &Path,
        config: &Config,
    ) -> Result<()> {
        let worker_config = config
            .get_worker(worker_name)
            .ok_or_else(|| anyhow::anyhow!("Worker config not found"))?;
        worker::start_claude_in_session(session_id, worker_config)?;
        Ok(())
    }

    fn check_state_consistency(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let (worker_status, worktree_path) = {
                let Some(worker) = state.get_worker(&worker_name) else { continue };
                (worker.status, worker.worktree_path.clone())
            };

            let worktree_path = std::path::Path::new(&worktree_path);
            if !worktree_path.exists() {
                continue;
            }

            if worker_status == WorkerStatus::Idle {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        tracing::info!(
                            "Worker '{}' is idle but has commits ahead of master, transitioning to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before transitioning to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }

                match git::is_worktree_clean(worktree_path) {
                    Ok(false) => {
                        tracing::warn!(
                            "Worker '{}' is idle but has dirty worktree, marking as error",
                            worker_name
                        );
                        let transition = WorkerTransition::ToError {
                            reason: "Dirty worktree detected during patrol".to_string(),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                    Ok(true) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check worktree cleanliness for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }

            // Check if Error workers have recovered
            if worker_status == WorkerStatus::Error {
                // Check if worker has commits and should be in needs_review
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        tracing::info!(
                            "Worker '{}' in error state has commits ahead of master, recovering to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before recovering to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => {
                        // No commits ahead, check if worktree is clean
                        match git::is_worktree_clean(worktree_path) {
                            Ok(true) => {
                                tracing::info!(
                                    "Worker '{}' in error state has clean worktree, recovering to idle",
                                    worker_name
                                );
                                let transition = WorkerTransition::ToIdle;
                                if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                                    worker::apply_transition(worker_mut, transition.clone())?;
                                    report
                                        .transitions_applied
                                        .push((worker_name.clone(), transition));
                                }
                                continue;
                            }
                            Ok(false) => {
                                // Still dirty, keep in error state
                            }
                            Err(e) => {
                                tracing::warn!(
                                    "Failed to check worktree cleanliness for error worker '{}': {}",
                                    worker_name,
                                    e
                                );
                            }
                        }
                    }
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for error worker '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }

            if worker_status != WorkerStatus::Rebasing && git::is_rebase_in_progress(worktree_path)
            {
                tracing::warn!(
                    "Worker '{}' has orphaned rebase state (status: {:?}), attempting cleanup",
                    worker_name,
                    worker_status
                );

                match git::abort_rebase(worktree_path) {
                    Ok(()) => {
                        tracing::info!(
                            "Successfully cleaned up orphaned rebase state for worker '{}'",
                            worker_name
                        );
                    }
                    Err(e) => {
                        tracing::error!(
                            "Failed to clean up orphaned rebase state for worker '{}': {}",
                            worker_name,
                            e
                        );
                        let transition = WorkerTransition::ToError {
                            reason: format!(
                                "Orphaned rebase state detected and cleanup failed: {}",
                                e
                            ),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                }
            }
        }

        Ok(())
    }

    fn detect_state_transitions(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            let current_status = worker.status;
            let session_id = worker.session_id.clone();
            let worktree_path = PathBuf::from(&worker.worktree_path);

            let transition = match current_status {
                WorkerStatus::Working => {
                    self.detect_working_transition(&session_id, &worktree_path)?
                }
                WorkerStatus::Rebasing => {
                    self.detect_rebasing_transition(&session_id, &worktree_path)?
                }
                _ => WorkerTransition::None,
            };

            if transition != WorkerTransition::None
                && let Some(w) = state.get_worker_mut(&worker_name)
            {
                tracing::info!(
                    "Applying transition for worker '{}': {:?} -> {:?}",
                    worker_name,
                    current_status,
                    transition
                );
                worker::apply_transition(w, transition.clone())?;
                report.transitions_applied.push((worker_name.clone(), transition.clone()));

                if matches!(transition, WorkerTransition::ToNeedsReview { .. }) {
                    let _ = sound::play_bell(config);
                }
            }
        }

        Ok(())
    }

    fn detect_working_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        // Check if worker is stuck at bypass permissions toggle
        if let Ok(output) = session::capture_pane(session_id, 50)
            && Self::is_stuck_at_bypass_toggle(&output)
        {
            tracing::warn!(
                "Worker {} stuck at bypass permissions toggle, auto-dismissing",
                session_id
            );
            Self::dismiss_bypass_toggle(session_id)?;
        }

        let has_commits = git::has_commits_ahead_of(worktree_path, "origin/master")?;
        tracing::debug!(
            "Checking working transition for {}: has_commits={}",
            session_id,
            has_commits
        );

        if has_commits {
            if git::has_uncommitted_changes(worktree_path)? {
                tracing::info!(
                    "Worker {} has commits and uncommitted changes, amending before transitioning to needs_review",
                    session_id
                );
                git::amend_uncommitted_changes(worktree_path)?;
            }

            let commit_sha = git::get_head_commit(worktree_path)?;
            tracing::info!(
                "Worker {} has commits ahead, transitioning to needs_review (sha: {})",
                session_id,
                commit_sha
            );
            return Ok(WorkerTransition::ToNeedsReview { commit_sha });
        }

        Ok(WorkerTransition::None)
    }

    /// Detects if Claude is stuck at the bypass permissions toggle UI
    fn is_stuck_at_bypass_toggle(output: &str) -> bool {
        let lower = output.to_lowercase();
        lower.contains("bypass permissions") && lower.contains("shift+tab to cycle")
    }

    /// Dismisses the bypass permissions toggle by pressing Enter
    fn dismiss_bypass_toggle(session_id: &str) -> Result<()> {
        let sender = TmuxSender::new();
        sender.send_keys_raw(session_id, "Enter")?;
        std::thread::sleep(std::time::Duration::from_millis(500));
        Ok(())
    }

    fn detect_rebasing_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        let rebase_in_progress = git::is_rebase_in_progress(worktree_path);

        if rebase_in_progress {
            tracing::debug!("Worker {} still has rebase in progress", session_id);
            return Ok(WorkerTransition::None);
        }

        // Rebase is complete (one way or another). Check pane output for completion
        // messages to provide better logging, but always transition to needs_review
        // since the rebase is no longer in progress.
        let output = session::capture_pane(session_id, 50)?;

        let rebase_completed = output.contains("Successfully rebased and updated");
        let rebase_aborted =
            output.contains("rebase --abort") && !output.contains("git rebase --abort");

        if rebase_completed {
            tracing::info!("Worker {} completed rebase successfully", session_id);
        } else if rebase_aborted {
            tracing::warn!("Worker {} aborted rebase", session_id);
        } else {
            tracing::info!(
                "Worker {} rebase finished (no completion message in pane, assuming success)",
                session_id
            );
        }

        // Handle any uncommitted changes by amending
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!("Worker {} has uncommitted changes after rebase, amending", session_id);
            git::amend_uncommitted_changes(worktree_path)?;
        }

        let commit_sha = git::get_head_commit(worktree_path)?;
        Ok(WorkerTransition::ToNeedsReview { commit_sha })
    }

    fn rebase_pending_reviews(
        &self,
        state: &mut State,
        transitioned_workers: &std::collections::HashSet<String>,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let workers_to_rebase: Vec<String> = state
            .workers
            .iter()
            .filter(|(_, w)| w.status == WorkerStatus::NeedsReview)
            .map(|(name, _)| name.clone())
            .collect();

        for worker_name in workers_to_rebase {
            if transitioned_workers.contains(&worker_name) {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - just transitioned in this patrol run",
                    worker_name
                );
                continue;
            }

            let worker = state.get_worker(&worker_name).unwrap();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();

            let rebase_in_progress = git::is_rebase_in_progress(&worktree_path);
            tracing::debug!(
                worker = %worker_name,
                rebase_in_progress,
                "Checking if rebase is in progress before triggering rebase"
            );

            if rebase_in_progress {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - rebase already in progress",
                    worker_name
                );
                continue;
            }

            let llmc_root = crate::config::get_llmc_root();
            let master_sha = git::get_head_commit(&llmc_root)?;
            let merge_base = git::get_merge_base(&worktree_path, "HEAD", "origin/master")?;

            if merge_base == master_sha {
                continue;
            }

            tracing::info!(
                "Master has advanced - rebasing worker '{}' in needs_review",
                worker_name
            );

            match self.trigger_rebase(&worker_name, &worktree_path, &session_id, state) {
                Ok(()) => {
                    report.rebases_triggered.push(worker_name.clone());
                }
                Err(e) => {
                    report.errors.push(format!("Failed to rebase worker '{}': {}", worker_name, e));
                }
            }
        }

        Ok(())
    }

    fn trigger_rebase(
        &self,
        worker_name: &str,
        worktree_path: &Path,
        session_id: &str,
        state: &mut State,
    ) -> Result<()> {
        let llmc_root = crate::config::get_llmc_root();
        git::fetch_origin(&llmc_root)?;

        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!(
                "Worker '{}' has uncommitted changes, amending to commit before rebase",
                worker_name
            );
            git::amend_uncommitted_changes(worktree_path)?;
        }

        let rebase_result = git::rebase_onto(worktree_path, "origin/master")?;

        if !rebase_result.success {
            let worker = state.get_worker_mut(worker_name).unwrap();
            worker::apply_transition(worker, WorkerTransition::ToRebasing)?;

            let conflict_prompt =
                build_conflict_prompt(&rebase_result.conflicts, &worker.current_prompt);

            let sender = TmuxSender::new();
            sender.send(session_id, &conflict_prompt)?;
        }

        Ok(())
    }
}

fn build_conflict_prompt(conflicts: &[String], original_task: &str) -> String {
    let mut prompt = String::from(
        "REBASE CONFLICT DETECTED\n\
         \n\
         Master has advanced and your changes need to be rebased. The rebase has encountered conflicts.\n\
         \n",
    );

    prompt.push_str(&format!(
        "IMPORTANT - Your original task:\n\
         \"{}\"\n\
         \n\
         DO NOT restart your task from scratch. Instead, INCORPORATE your existing changes/intent \n\
         into the new repository state. Your goal is to apply the same logical changes you already \n\
         made, but adapted to work with the new state of the files after master's changes.\n\
         \n",
        original_task.lines().take(3).collect::<Vec<_>>().join(" ")
    ));

    prompt.push_str("Conflicting files:\n");

    for file in conflicts {
        let conflict_count = count_conflict_markers(file);
        prompt.push_str(&format!("- {} ({} conflict markers)\n", file, conflict_count));
    }

    prompt.push_str(
        "\n\
         IMPORTANT - Resolution steps (must complete ALL steps):\n\
         1. Read and understand the conflict markers in each file (<<<<<<, =======, >>>>>>>)\n\
         2. Understand what master changed (their version) and what you changed (our version)\n\
         3. Decide how to INCORPORATE YOUR CHANGES into the new state - do NOT just accept theirs\n\
         4. Edit files to remove ALL conflict markers and apply your intended changes\n\
         5. Stage ALL resolved files: git add <file>\n\
         6. Continue the rebase: git rebase --continue\n\
         7. Verify success: Look for \"Successfully rebased and updated\" message\n\
         8. Run validation: just review\n\
         9. IMPORTANT: If validation modified any files, amend them: git add -A && git commit --amend --no-edit\n\
         \n\
         Helpful commands:\n\
         - View our version: git show :2:<file>\n\
         - View their version: git show :3:<file>\n\
         - Check remaining conflicts: git diff --name-only --diff-filter=U\n\
         - If you need to start over: git rebase --abort\n\
         \n\
         CRITICAL: You MUST run 'git rebase --continue' after staging files.\n\
         Do NOT commit manually. The rebase process handles commits automatically.\n",
    );

    prompt
}

fn count_conflict_markers(file: &str) -> usize {
    std::fs::read_to_string(file).map(|content| content.matches("<<<<<<<").count()).unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_patrol_report_default() {
        let report = PatrolReport::default();
        assert_eq!(report.sessions_checked, 0);
        assert!(report.transitions_applied.is_empty());
        assert!(report.rebases_triggered.is_empty());
        assert!(report.errors.is_empty());
    }

    #[test]
    fn test_build_conflict_prompt() {
        let conflicts = vec!["src/main.rs".to_string(), "src/lib.rs".to_string()];
        let original_task = "Fix the authentication bug in the login system";
        let prompt = build_conflict_prompt(&conflicts, original_task);

        assert!(prompt.contains("REBASE CONFLICT DETECTED"));
        assert!(prompt.contains("src/main.rs"));
        assert!(prompt.contains("src/lib.rs"));
        assert!(prompt.contains("IMPORTANT - Resolution steps (must complete ALL steps):"));
        assert!(prompt.contains("Your original task:"));
        assert!(prompt.contains("Fix the authentication bug"));
        assert!(prompt.contains("git rebase --continue"));
        assert!(prompt.contains("Successfully rebased and updated"));
    }
}
