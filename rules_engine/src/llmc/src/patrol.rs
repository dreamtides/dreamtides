#![allow(dead_code)]

use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

use anyhow::Result;

use crate::config::Config;
use crate::state::{State, WorkerStatus};
use crate::tmux::sender::TmuxSender;
use crate::tmux::session;
use crate::worker::{self, WorkerTransition};
use crate::{git, recovery, sound};

static PATROL_RUNNING: AtomicBool = AtomicBool::new(false);

/// Patrol system configuration
pub struct Patrol {
    interval_secs: u64,
    stuck_timeout_mins: u64,
    nudge_interval_mins: u64,
}

/// Report generated by a patrol run
#[derive(Debug, Default)]
pub struct PatrolReport {
    pub sessions_checked: u32,
    pub transitions_applied: Vec<(String, WorkerTransition)>,
    pub rebases_triggered: Vec<String>,
    pub stuck_workers_nudged: Vec<String>,
    pub errors: Vec<String>,
}

impl Patrol {
    pub fn new(config: &Config) -> Self {
        Self {
            interval_secs: config.defaults.patrol_interval_secs as u64,
            stuck_timeout_mins: 30,
            nudge_interval_mins: 5,
        }
    }

    pub fn should_run(&self, last_run: Instant) -> bool {
        last_run.elapsed() >= Duration::from_secs(self.interval_secs)
    }

    pub fn run_patrol(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        if PATROL_RUNNING.swap(true, Ordering::SeqCst) {
            tracing::debug!("Skipping patrol run - another patrol is in progress");
            return Ok(PatrolReport::default());
        }

        let result = self.run_patrol_impl(state, config);

        PATROL_RUNNING.store(false, Ordering::SeqCst);

        result
    }

    fn run_patrol_impl(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        let mut report = PatrolReport::default();

        self.check_session_health(state, config, &mut report)?;
        self.check_state_consistency(state, &mut report)?;
        self.detect_state_transitions(state, config, &mut report)?;

        let transitioned_workers: std::collections::HashSet<String> =
            report.transitions_applied.iter().map(|(name, _)| name.clone()).collect();

        self.rebase_pending_reviews(state, &transitioned_workers, &mut report)?;
        self.detect_stuck_workers(state, &mut report)?;

        Ok(report)
    }

    fn check_session_health(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            report.sessions_checked += 1;

            let worker = state.get_worker(&worker_name).unwrap();
            let session_id = worker.session_id.clone();

            if let Some(worker_mut) = state.get_worker_mut(&worker_name)
                && recovery::should_reset_crash_count(
                    worker_mut,
                    SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
                )
            {
                tracing::info!(
                    "Worker {} crash count expired (24h), resetting from {}",
                    worker_name,
                    worker_mut.crash_count
                );
                worker_mut.crash_count = 0;
                worker_mut.last_crash_unix = None;
            }

            if !session::session_exists(&session_id) {
                tracing::warn!(
                    "Worker '{}' session '{}' not found - marking offline",
                    worker_name,
                    session_id
                );
                if let Some(w) = state.get_worker_mut(&worker_name)
                    && let Err(e) = worker::apply_transition(w, WorkerTransition::ToOffline)
                {
                    report
                        .errors
                        .push(format!("Failed to mark worker '{}' offline: {}", worker_name, e));
                }
                continue;
            }

            let pane_command = session::get_pane_command(&session_id).unwrap_or_default();
            if session::is_shell(&pane_command) {
                tracing::warn!(
                    "Worker '{}' Claude process crashed - attempting restart",
                    worker_name
                );

                let worker = state.get_worker(&worker_name).unwrap();
                let worktree_path = PathBuf::from(&worker.worktree_path);

                if let Err(e) =
                    self.attempt_restart(&worker_name, &session_id, &worktree_path, config)
                {
                    report
                        .errors
                        .push(format!("Failed to restart worker '{}': {}", worker_name, e));
                    if let Some(w) = state.get_worker_mut(&worker_name)
                        && let Err(e) = worker::apply_transition(w, WorkerTransition::ToError {
                            reason: "Claude crashed".to_string(),
                        })
                    {
                        report.errors.push(format!(
                            "Failed to mark worker '{}' as error: {}",
                            worker_name, e
                        ));
                    }
                }
            }
        }

        Ok(())
    }

    fn attempt_restart(
        &self,
        worker_name: &str,
        session_id: &str,
        _worktree_path: &Path,
        config: &Config,
    ) -> Result<()> {
        let worker_config = config
            .get_worker(worker_name)
            .ok_or_else(|| anyhow::anyhow!("Worker config not found"))?;
        worker::start_claude_in_session(session_id, worker_config)?;
        Ok(())
    }

    fn check_state_consistency(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let (worker_status, worktree_path) = {
                let Some(worker) = state.get_worker(&worker_name) else { continue };
                (worker.status, worker.worktree_path.clone())
            };

            let worktree_path = std::path::Path::new(&worktree_path);
            if !worktree_path.exists() {
                continue;
            }

            if worker_status == WorkerStatus::Idle {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        tracing::info!(
                            "Worker '{}' is idle but has commits ahead of master, transitioning to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before transitioning to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }

                match git::is_worktree_clean(worktree_path) {
                    Ok(false) => {
                        tracing::warn!(
                            "Worker '{}' is idle but has dirty worktree, marking as error",
                            worker_name
                        );
                        let transition = WorkerTransition::ToError {
                            reason: "Dirty worktree detected during patrol".to_string(),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                    Ok(true) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check worktree cleanliness for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }

            if worker_status != WorkerStatus::Rebasing && git::is_rebase_in_progress(worktree_path)
            {
                tracing::warn!(
                    "Worker '{}' has orphaned rebase state (status: {:?}), attempting cleanup",
                    worker_name,
                    worker_status
                );

                match git::abort_rebase(worktree_path) {
                    Ok(()) => {
                        tracing::info!(
                            "Successfully cleaned up orphaned rebase state for worker '{}'",
                            worker_name
                        );
                    }
                    Err(e) => {
                        tracing::error!(
                            "Failed to clean up orphaned rebase state for worker '{}': {}",
                            worker_name,
                            e
                        );
                        let transition = WorkerTransition::ToError {
                            reason: format!(
                                "Orphaned rebase state detected and cleanup failed: {}",
                                e
                            ),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                }
            }
        }

        Ok(())
    }

    fn detect_state_transitions(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            let current_status = worker.status;
            let session_id = worker.session_id.clone();
            let worktree_path = PathBuf::from(&worker.worktree_path);

            let transition = match current_status {
                WorkerStatus::Working => {
                    self.detect_working_transition(&session_id, &worktree_path)?
                }
                WorkerStatus::Rebasing => {
                    self.detect_rebasing_transition(&session_id, &worktree_path)?
                }
                _ => WorkerTransition::None,
            };

            if transition != WorkerTransition::None
                && let Some(w) = state.get_worker_mut(&worker_name)
            {
                tracing::info!(
                    "Applying transition for worker '{}': {:?} -> {:?}",
                    worker_name,
                    current_status,
                    transition
                );
                worker::apply_transition(w, transition.clone())?;
                report.transitions_applied.push((worker_name.clone(), transition.clone()));

                if matches!(transition, WorkerTransition::ToNeedsReview { .. }) {
                    let _ = sound::play_bell(config);
                }
            }
        }

        Ok(())
    }

    fn detect_working_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        let has_commits = git::has_commits_ahead_of(worktree_path, "origin/master")?;
        tracing::debug!(
            "Checking working transition for {}: has_commits={}",
            session_id,
            has_commits
        );

        if has_commits {
            if git::has_uncommitted_changes(worktree_path)? {
                tracing::info!(
                    "Worker {} has commits and uncommitted changes, amending before transitioning to needs_review",
                    session_id
                );
                git::amend_uncommitted_changes(worktree_path)?;
            }

            let commit_sha = git::get_head_commit(worktree_path)?;
            tracing::info!(
                "Worker {} has commits ahead, transitioning to needs_review (sha: {})",
                session_id,
                commit_sha
            );
            return Ok(WorkerTransition::ToNeedsReview { commit_sha });
        }

        Ok(WorkerTransition::None)
    }

    fn detect_rebasing_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        let rebase_in_progress = git::is_rebase_in_progress(worktree_path);

        if rebase_in_progress {
            tracing::debug!("Worker {} still has rebase in progress", session_id);
            return Ok(WorkerTransition::None);
        }

        let output = session::capture_pane(session_id, 50)?;

        let rebase_completed = output.contains("Successfully rebased and updated");
        let rebase_aborted =
            output.contains("rebase --abort") && !output.contains("git rebase --abort");

        if rebase_completed {
            tracing::info!("Worker {} completed rebase successfully", session_id);
            if git::has_uncommitted_changes(worktree_path)? {
                tracing::info!(
                    "Worker {} has uncommitted changes after rebase, amending",
                    session_id
                );
                git::amend_uncommitted_changes(worktree_path)?;
            }
            let commit_sha = git::get_head_commit(worktree_path)?;
            return Ok(WorkerTransition::ToNeedsReview { commit_sha });
        }

        if rebase_aborted {
            tracing::warn!("Worker {} aborted rebase", session_id);
            if git::has_uncommitted_changes(worktree_path)? {
                tracing::info!(
                    "Worker {} has uncommitted changes after abort, amending",
                    session_id
                );
                git::amend_uncommitted_changes(worktree_path)?;
            }
            return Ok(WorkerTransition::ToNeedsReview {
                commit_sha: git::get_head_commit(worktree_path)?,
            });
        }

        Ok(WorkerTransition::None)
    }

    fn rebase_pending_reviews(
        &self,
        state: &mut State,
        transitioned_workers: &std::collections::HashSet<String>,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let workers_to_rebase: Vec<String> = state
            .workers
            .iter()
            .filter(|(_, w)| w.status == WorkerStatus::NeedsReview)
            .map(|(name, _)| name.clone())
            .collect();

        for worker_name in workers_to_rebase {
            if transitioned_workers.contains(&worker_name) {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - just transitioned in this patrol run",
                    worker_name
                );
                continue;
            }

            let worker = state.get_worker(&worker_name).unwrap();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();

            if git::is_rebase_in_progress(&worktree_path) {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - rebase already in progress",
                    worker_name
                );
                continue;
            }

            let llmc_root = crate::config::get_llmc_root();
            let master_sha = git::get_head_commit(&llmc_root)?;
            let merge_base = git::get_merge_base(&worktree_path, "HEAD", "origin/master")?;

            if merge_base == master_sha {
                continue;
            }

            tracing::info!(
                "Master has advanced - rebasing worker '{}' in needs_review",
                worker_name
            );

            match self.trigger_rebase(&worker_name, &worktree_path, &session_id, state) {
                Ok(()) => {
                    report.rebases_triggered.push(worker_name.clone());
                }
                Err(e) => {
                    report.errors.push(format!("Failed to rebase worker '{}': {}", worker_name, e));
                }
            }
        }

        Ok(())
    }

    fn trigger_rebase(
        &self,
        worker_name: &str,
        worktree_path: &Path,
        session_id: &str,
        state: &mut State,
    ) -> Result<()> {
        let llmc_root = crate::config::get_llmc_root();
        git::fetch_origin(&llmc_root)?;

        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!(
                "Worker '{}' has uncommitted changes, amending to commit before rebase",
                worker_name
            );
            git::amend_uncommitted_changes(worktree_path)?;
        }

        let rebase_result = git::rebase_onto(worktree_path, "origin/master")?;

        if !rebase_result.success {
            let worker = state.get_worker_mut(worker_name).unwrap();
            worker::apply_transition(worker, WorkerTransition::ToRebasing)?;

            let conflict_prompt = build_conflict_prompt(&rebase_result.conflicts);

            let sender = TmuxSender::new();
            sender.send(session_id, &conflict_prompt)?;
        }

        Ok(())
    }

    #[expect(clippy::integer_division)]
    fn detect_stuck_workers(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();

        let worker_names: Vec<String> = state.workers.keys().cloned().collect();

        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();

            if worker.status != WorkerStatus::Working {
                continue;
            }

            let minutes_inactive = (now - worker.last_activity_unix) / 60;

            if minutes_inactive >= self.stuck_timeout_mins {
                let nudges_sent = ((minutes_inactive - self.stuck_timeout_mins)
                    / self.nudge_interval_mins) as usize;

                if nudges_sent == 0 {
                    self.send_nudge(&worker_name, &worker.session_id, "initial")?;
                    report.stuck_workers_nudged.push(worker_name.clone());
                } else if nudges_sent == 1 {
                    self.send_nudge(&worker_name, &worker.session_id, "warning")?;
                    report.stuck_workers_nudged.push(worker_name.clone());
                }
            }
        }

        Ok(())
    }

    fn send_nudge(&self, worker_name: &str, session_id: &str, nudge_type: &str) -> Result<()> {
        let message = match nudge_type {
            "initial" => {
                "You've been working for over 30 minutes. Please provide a status update or commit your work."
            }
            "warning" => {
                "You've been working for over 35 minutes without activity. Please complete your current task or ask for help."
            }
            _ => "Please update your status.",
        };

        tracing::info!("Sending {} nudge to worker '{}'", nudge_type, worker_name);

        let sender = TmuxSender::new();
        sender.send(session_id, message)?;

        Ok(())
    }
}

fn build_conflict_prompt(conflicts: &[String]) -> String {
    let mut prompt = String::from(
        "REBASE CONFLICT DETECTED\n\
         \n\
         Master has advanced and your changes need to be rebased. The rebase has encountered conflicts.\n\
         \n\
         Conflicting files:\n",
    );

    for file in conflicts {
        let conflict_count = count_conflict_markers(file);
        prompt.push_str(&format!("- {} ({} conflict markers)\n", file, conflict_count));
    }

    prompt.push_str(
        "\n\
         IMPORTANT - Resolution steps (must complete ALL steps):\n\
         1. Read and understand the conflict markers in each file (<<<<<<, =======, >>>>>>>)\n\
         2. Decide how to resolve each conflict (keep ours, keep theirs, or merge)\n\
         3. Edit files to remove ALL conflict markers and keep the correct code\n\
         4. Stage ALL resolved files: git add <file>\n\
         5. Continue the rebase: git rebase --continue\n\
         6. Verify success: Look for \"Successfully rebased and updated\" message\n\
         7. Run validation: just review\n\
         \n\
         Helpful commands:\n\
         - View our version: git show :2:<file>\n\
         - View their version: git show :3:<file>\n\
         - Check remaining conflicts: git diff --name-only --diff-filter=U\n\
         - If you need to start over: git rebase --abort\n\
         \n\
         CRITICAL: You MUST run 'git rebase --continue' after staging files.\n\
         Do NOT commit manually. The rebase process handles commits automatically.\n",
    );

    prompt
}

fn count_conflict_markers(file: &str) -> usize {
    std::fs::read_to_string(file).map(|content| content.matches("<<<<<<<").count()).unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_should_run() {
        let patrol = Patrol { interval_secs: 60, stuck_timeout_mins: 30, nudge_interval_mins: 5 };

        let now = Instant::now();
        assert!(!patrol.should_run(now));

        let past = now - Duration::from_secs(61);
        assert!(patrol.should_run(past));
    }

    #[test]
    fn test_patrol_report_default() {
        let report = PatrolReport::default();
        assert_eq!(report.sessions_checked, 0);
        assert!(report.transitions_applied.is_empty());
        assert!(report.rebases_triggered.is_empty());
        assert!(report.stuck_workers_nudged.is_empty());
        assert!(report.errors.is_empty());
    }

    #[test]
    fn test_build_conflict_prompt() {
        let conflicts = vec!["src/main.rs".to_string(), "src/lib.rs".to_string()];
        let prompt = build_conflict_prompt(&conflicts);

        assert!(prompt.contains("REBASE CONFLICT DETECTED"));
        assert!(prompt.contains("src/main.rs"));
        assert!(prompt.contains("src/lib.rs"));
        assert!(prompt.contains("IMPORTANT - Resolution steps (must complete ALL steps):"));
        assert!(prompt.contains("git rebase --continue"));
        assert!(prompt.contains("Successfully rebased and updated"));
    }
}
