use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

use anyhow::Result;

use crate::config::{Config, SelfReviewConfig};
use crate::ipc::messages::HookEvent;
use crate::state::{self, State, WorkerStatus};
use crate::tmux::sender::TmuxSender;
use crate::worker::{self, WorkerTransition};
use crate::{git, recovery, sound};

static PATROL_RUNNING: AtomicBool = AtomicBool::new(false);

/// Patrol system configuration
pub struct Patrol {}

/// Report generated by a patrol run
#[derive(Debug, Default)]
pub struct PatrolReport {
    pub sessions_checked: u32,
    pub transitions_applied: Vec<(String, WorkerTransition)>,
    pub rebases_triggered: Vec<String>,
    pub errors: Vec<String>,
}

/// Handles a hook event from Claude Code, applying state transitions as needed.
///
/// This function processes SessionStart, SessionEnd, and Stop events to detect
/// when workers come online, crash/shutdown, or complete their current task.
pub fn handle_hook_event(event: &HookEvent, state: &mut State, config: &Config) -> Result<()> {
    match event {
        HookEvent::SessionStart { worker, session_id, timestamp } => {
            handle_session_start(worker, session_id, *timestamp, state)?;
        }
        HookEvent::SessionEnd { worker, reason, timestamp } => {
            handle_session_end(worker, reason, *timestamp, state, config)?;
        }
        HookEvent::Stop { worker, timestamp, .. } => {
            handle_stop(worker, *timestamp, state, config)?;
        }
    }
    Ok(())
}

impl Patrol {
    pub fn new(_config: &Config) -> Self {
        Self {}
    }

    pub fn run_patrol(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        if PATROL_RUNNING.swap(true, Ordering::SeqCst) {
            tracing::debug!("Skipping patrol run - another patrol is in progress");
            return Ok(PatrolReport::default());
        }
        let result = self.run_patrol_impl(state, config);
        PATROL_RUNNING.store(false, Ordering::SeqCst);
        result
    }

    fn run_patrol_impl(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        let mut report = PatrolReport::default();
        self.check_session_health(state, &mut report)?;
        self.check_state_consistency(state, &mut report)?;
        self.detect_state_transitions(state, &mut report)?;
        if !report.transitions_applied.is_empty() {
            let state_path = state::get_state_path();
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state after {} transitions (self-review may not trigger): {}",
                    report.transitions_applied.len(),
                    e
                );
            } else {
                tracing::debug!(
                    "Saved state after {} transitions",
                    report.transitions_applied.len()
                );
            }
        }
        self.send_pending_self_review_prompts(state, config)?;
        let transitioned_workers: std::collections::HashSet<String> =
            report.transitions_applied.iter().map(|(name, _)| name.clone()).collect();
        self.rebase_pending_reviews(state, &transitioned_workers, &mut report)?;
        Ok(report)
    }

    fn check_session_health(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            report.sessions_checked += 1;
            if let Some(worker_mut) = state.get_worker_mut(&worker_name)
                && recovery::should_reset_crash_count(
                    worker_mut,
                    SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
                )
            {
                tracing::info!(
                    "Worker {} crash count expired (24h), resetting from {}",
                    worker_name,
                    worker_mut.crash_count
                );
                worker_mut.crash_count = 0;
                worker_mut.last_crash_unix = None;
            }
        }
        Ok(())
    }

    fn check_state_consistency(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let (worker_status, worktree_path) = {
                let Some(worker) = state.get_worker(&worker_name) else { continue };
                (worker.status, worker.worktree_path.clone())
            };
            let worktree_path = std::path::Path::new(&worktree_path);
            if !worktree_path.exists() {
                continue;
            }
            if worker_status == WorkerStatus::Idle {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        let is_linear = git::is_ancestor(worktree_path, "origin/master", "HEAD")
                            .unwrap_or(false);
                        if !is_linear {
                            tracing::info!(
                                "Worker '{}' is idle with diverged history (origin/master not an ancestor of HEAD), resetting to origin/master",
                                worker_name
                            );
                            match git::reset_to_ref(worktree_path, "origin/master") {
                                Ok(()) => {
                                    tracing::info!(
                                        "Successfully reset idle worker '{}' to origin/master",
                                        worker_name
                                    );
                                }
                                Err(e) => {
                                    tracing::warn!(
                                        "Failed to reset idle worker '{}' to origin/master: {}",
                                        worker_name,
                                        e
                                    );
                                }
                            }
                            continue;
                        }
                        tracing::info!(
                            "Worker '{}' is idle but has commits ahead of master, transitioning to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before transitioning to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
                match git::is_worktree_clean(worktree_path) {
                    Ok(false) => {
                        tracing::warn!(
                            "Worker '{}' is idle but has dirty worktree, marking as error",
                            worker_name
                        );
                        let transition = WorkerTransition::ToError {
                            reason: "Dirty worktree detected during patrol".to_string(),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                    Ok(true) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check worktree cleanliness for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
            if worker_status == WorkerStatus::Error {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        tracing::info!(
                            "Worker '{}' in error state has commits ahead of master, recovering to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before recovering to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => match git::is_worktree_clean(worktree_path) {
                        Ok(true) => {
                            tracing::info!(
                                "Worker '{}' in error state has clean worktree, recovering to idle",
                                worker_name
                            );
                            let transition = WorkerTransition::ToIdle;
                            if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                                worker::apply_transition(worker_mut, transition.clone())?;
                                report.transitions_applied.push((worker_name.clone(), transition));
                            }
                            continue;
                        }
                        Ok(false) => {}
                        Err(e) => {
                            tracing::warn!(
                                "Failed to check worktree cleanliness for error worker '{}': {}",
                                worker_name,
                                e
                            );
                        }
                    },
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for error worker '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
            // Fallback: detect Working/Rejected workers with commits where Stop hook may
            // have failed
            if matches!(worker_status, WorkerStatus::Working | WorkerStatus::Rejected) {
                let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                let last_activity =
                    state.get_worker(&worker_name).map(|w| w.last_activity_unix).unwrap_or(now);
                let elapsed_secs = now.saturating_sub(last_activity);
                const FALLBACK_DELAY_SECS: u64 = 300;

                if elapsed_secs >= FALLBACK_DELAY_SECS {
                    match git::has_commits_ahead_of(worktree_path, "origin/master") {
                        Ok(true) => {
                            tracing::warn!(
                                "Worker '{}' in {:?} state has commits ahead of master for {}s (Stop hook may have failed), recovering to needs_review",
                                worker_name,
                                worker_status,
                                elapsed_secs
                            );
                            if git::has_uncommitted_changes(worktree_path)? {
                                tracing::info!(
                                    "Worker '{}' has uncommitted changes, amending before recovering to needs_review",
                                    worker_name
                                );
                                git::amend_uncommitted_changes(worktree_path)?;
                            }
                            let commit_sha = git::get_head_commit(worktree_path)?;
                            let transition = WorkerTransition::ToNeedsReview { commit_sha };
                            if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                                let self_review_enabled = worker_mut.self_review;
                                worker::apply_transition(worker_mut, transition.clone())?;
                                report.transitions_applied.push((worker_name.clone(), transition));
                                if self_review_enabled {
                                    worker_mut.pending_self_review = true;
                                } else {
                                    worker_mut.on_complete_sent_unix = Some(now);
                                }
                            }
                            continue;
                        }
                        Ok(false) => {}
                        Err(e) => {
                            tracing::warn!(
                                "Failed to check commits ahead for working worker '{}': {}",
                                worker_name,
                                e
                            );
                        }
                    }
                }
            }
            if worker_status != WorkerStatus::Rebasing && git::is_rebase_in_progress(worktree_path)
            {
                tracing::warn!(
                    "Worker '{}' has orphaned rebase state (status: {:?}), attempting cleanup",
                    worker_name,
                    worker_status
                );
                match git::abort_rebase(worktree_path) {
                    Ok(()) => {
                        tracing::info!(
                            "Successfully cleaned up orphaned rebase state for worker '{}'",
                            worker_name
                        );
                    }
                    Err(e) => {
                        tracing::error!(
                            "Failed to clean up orphaned rebase state for worker '{}': {}",
                            worker_name,
                            e
                        );
                        let transition = WorkerTransition::ToError {
                            reason: format!(
                                "Orphaned rebase state detected and cleanup failed: {}",
                                e
                            ),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                }
            }
        }
        Ok(())
    }

    fn detect_state_transitions(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            let current_status = worker.status;
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let self_review_enabled = worker.self_review;
            let transition = match current_status {
                WorkerStatus::Rebasing => {
                    self.detect_rebasing_transition(&worker_name, &worktree_path)?
                }
                _ => WorkerTransition::None,
            };
            if transition != WorkerTransition::None
                && let Some(w) = state.get_worker_mut(&worker_name)
            {
                tracing::info!(
                    "Applying transition for worker '{}': {:?} -> {:?}",
                    worker_name,
                    current_status,
                    transition
                );
                worker::apply_transition(w, transition.clone())?;
                report.transitions_applied.push((worker_name.clone(), transition.clone()));
                if matches!(transition, WorkerTransition::ToNeedsReview { .. }) {
                    if self_review_enabled {
                        w.pending_self_review = true;
                        tracing::info!(
                            "Worker '{}' has self_review enabled, queuing self-review",
                            worker_name
                        );
                    } else {
                        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                        w.on_complete_sent_unix = Some(now);
                        tracing::info!(
                            "Worker '{}' does not have self_review enabled, skipping self-review",
                            worker_name
                        );
                    }
                }
            }
        }
        Ok(())
    }

    fn send_pending_self_review_prompts(&self, state: &mut State, config: &Config) -> Result<()> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let delay_secs: u64 = 10;
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            if worker.status != WorkerStatus::NeedsReview {
                continue;
            }
            if !worker.pending_self_review {
                continue;
            }
            if worker.on_complete_sent_unix.is_some() {
                continue;
            }
            let Some(self_review_config) = get_self_review_config(config) else {
                tracing::warn!(
                    "Worker '{}' has pending_self_review but no self_review config in defaults",
                    worker_name
                );
                continue;
            };
            let elapsed = now.saturating_sub(worker.last_activity_unix);
            if elapsed < delay_secs {
                tracing::debug!(
                    worker = % worker_name, elapsed_secs = elapsed, delay_secs,
                    last_activity_unix = worker.last_activity_unix, now_unix = now,
                    "Waiting for self-review delay"
                );
                continue;
            }
            tracing::info!(
                "Worker '{}' eligible for self-review ({}s after completion)",
                worker_name,
                elapsed
            );
            let original_prompt = worker.current_prompt.clone();
            let session_id = worker.session_id.clone();
            if let Some(w) = state.get_worker_mut(&worker_name) {
                w.on_complete_sent_unix = Some(now);
            }
            let state_path = state::get_state_path();
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state before sending self-review to '{}': {}",
                    worker_name,
                    e
                );
                continue;
            }
            tracing::info!(
                "State saved with on_complete_sent_unix={} for worker '{}', now sending prompt",
                now,
                worker_name
            );
            if let Err(e) =
                send_self_review_prompt(&session_id, self_review_config, &original_prompt)
            {
                tracing::error!(
                    "Failed to send self-review prompt to worker '{}': {}",
                    worker_name,
                    e
                );
            } else if let Some(w) = state.get_worker_mut(&worker_name) {
                w.pending_self_review = false;
                if let Err(e) = worker::apply_transition(w, WorkerTransition::ToReviewing) {
                    tracing::error!(
                        "Failed to transition worker '{}' to Reviewing: {}",
                        worker_name,
                        e
                    );
                } else {
                    tracing::info!("Worker '{}' transitioned to Reviewing state", worker_name);
                    let state_path = state::get_state_path();
                    if let Err(e) = state.save(&state_path) {
                        tracing::error!(
                            "Failed to save state after transitioning '{}' to Reviewing: {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
        }
        Ok(())
    }

    fn detect_rebasing_transition(
        &self,
        worker_name: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        if git::is_rebase_in_progress(worktree_path) {
            tracing::debug!("Worker {} still has rebase in progress", worker_name);
            return Ok(WorkerTransition::None);
        }
        tracing::info!("Worker {} rebase finished", worker_name);
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!("Worker {} has uncommitted changes after rebase, amending", worker_name);
            git::amend_uncommitted_changes(worktree_path)?;
        }
        let commit_sha = git::get_head_commit(worktree_path)?;
        Ok(WorkerTransition::ToNeedsReview { commit_sha })
    }

    fn rebase_pending_reviews(
        &self,
        state: &mut State,
        transitioned_workers: &std::collections::HashSet<String>,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let workers_to_check: Vec<String> = state
            .workers
            .iter()
            .filter(|(_, w)| w.status == WorkerStatus::NeedsReview)
            .map(|(name, _)| name.clone())
            .collect();
        for worker_name in workers_to_check {
            if transitioned_workers.contains(&worker_name) {
                tracing::debug!(
                    "Skipping rebase check for worker '{}' - just transitioned in this patrol run",
                    worker_name
                );
                continue;
            }
            let worker = state.get_worker(&worker_name).unwrap();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();
            let rebase_in_progress = git::is_rebase_in_progress(&worktree_path);
            tracing::debug!(
                worker = % worker_name, rebase_in_progress,
                "Checking if rebase is in progress before triggering rebase"
            );
            if rebase_in_progress {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - rebase already in progress",
                    worker_name
                );
                continue;
            }
            let has_commits_ahead = git::has_commits_ahead_of(&worktree_path, "origin/master")?;
            let worker_head = git::get_head_commit(&worktree_path)?;
            let origin_master_sha = git::get_head_commit_of_ref(&worktree_path, "origin/master")?;
            if !has_commits_ahead {
                let expected_sha = worker.commit_sha.as_deref().unwrap_or("<none>");
                tracing::info!(
                    worker = % worker_name, worker_head = % worker_head, origin_master =
                    % origin_master_sha, expected_commit_sha = % expected_sha,
                    heads_match = (worker_head == origin_master_sha),
                    "Worker is in needs_review but has no commits ahead of origin/master - work was already merged, resetting to idle"
                );
                let worker_mut = state.get_worker_mut(&worker_name).unwrap();
                worker::apply_transition(worker_mut, WorkerTransition::ToIdle)?;
                report.transitions_applied.push((worker_name.clone(), WorkerTransition::ToIdle));
                continue;
            }
            let merge_base = git::get_merge_base(&worktree_path, "HEAD", "origin/master")?;
            tracing::debug!(
                worker = % worker_name, worker_head = % worker_head, origin_master = %
                origin_master_sha, merge_base = % merge_base,
                "Checking if rebase is needed"
            );
            if merge_base == origin_master_sha {
                tracing::debug!("Worker '{}' is already rebased onto origin/master", worker_name);
                continue;
            }
            tracing::info!(
                worker = % worker_name, merge_base = % merge_base, origin_master = %
                origin_master_sha,
                "Master has advanced - rebasing worker in needs_review"
            );
            match self.trigger_rebase(&worker_name, &worktree_path, &session_id, state) {
                Ok(()) => {
                    report.rebases_triggered.push(worker_name.clone());
                }
                Err(e) => {
                    report.errors.push(format!("Failed to rebase worker '{}': {}", worker_name, e));
                }
            }
        }
        Ok(())
    }

    fn trigger_rebase(
        &self,
        worker_name: &str,
        worktree_path: &Path,
        session_id: &str,
        state: &mut State,
    ) -> Result<()> {
        let llmc_root = crate::config::get_llmc_root();
        git::fetch_origin(&llmc_root)?;
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!(
                "Worker '{}' has uncommitted changes, amending to commit before rebase",
                worker_name
            );
            git::amend_uncommitted_changes(worktree_path)?;
        }
        let rebase_result = git::rebase_onto(worktree_path, "origin/master")?;
        if !rebase_result.success {
            let worker = state.get_worker_mut(worker_name).unwrap();
            worker::apply_transition(worker, WorkerTransition::ToRebasing)?;
            let conflict_prompt =
                build_conflict_prompt(&rebase_result.conflicts, &worker.current_prompt);
            let sender = TmuxSender::new();
            sender.send(session_id, &conflict_prompt)?;
        }
        Ok(())
    }
}

fn handle_session_start(
    worker_name: &str,
    session_id: &str,
    _timestamp: u64,
    state: &mut State,
) -> Result<()> {
    let Some(worker) = state.get_worker(worker_name) else {
        tracing::warn!(
            "SessionStart hook received for unknown worker '{}' (session: {})",
            worker_name,
            session_id
        );
        return Ok(());
    };

    if worker.status == WorkerStatus::Offline {
        tracing::info!(
            worker = %worker_name,
            session_id = %session_id,
            "Worker ready via SessionStart hook, transitioning to Idle"
        );
        if let Some(w) = state.get_worker_mut(worker_name)
            && let Err(e) = worker::apply_transition(w, WorkerTransition::ToIdle)
        {
            tracing::error!(
                "Failed to transition worker '{}' to Idle from SessionStart hook: {}",
                worker_name,
                e
            );
        }
    } else {
        // This is expected after /clear - the session restarts but the worker is still
        // Working. Log at info level to help track these events for debugging.
        tracing::info!(
            worker = %worker_name,
            session_id = %session_id,
            current_status = ?worker.status,
            has_prompt = !worker.current_prompt.is_empty(),
            "SessionStart hook received but worker is not Offline, preserving current state"
        );
    }

    Ok(())
}

fn handle_session_end(
    worker_name: &str,
    reason: &str,
    timestamp: u64,
    state: &mut State,
    _config: &Config,
) -> Result<()> {
    let Some(worker) = state.get_worker(worker_name) else {
        tracing::warn!(
            "SessionEnd hook received for unknown worker '{}' (reason: {})",
            worker_name,
            reason
        );
        return Ok(());
    };

    if worker.status == WorkerStatus::Offline {
        tracing::debug!(
            worker = %worker_name,
            "SessionEnd hook received but worker is already Offline, ignoring"
        );
        return Ok(());
    }

    // "clear" happens when /clear is sent - not a real session end, Claude restarts
    // immediately. "logout" is a normal exit (e.g., user typed /exit).
    // Any other reason (e.g., "error", "crash") is treated as an unexpected crash.
    if reason == "clear" {
        tracing::debug!(
            worker = %worker_name,
            current_status = ?worker.status,
            "SessionEnd hook with reason='clear' ignored - /clear causes immediate session restart"
        );
        return Ok(());
    }

    let is_crash = reason != "logout";

    tracing::info!(
        worker = %worker_name,
        reason = %reason,
        is_crash = is_crash,
        "Worker offline via SessionEnd hook"
    );

    if let Some(w) = state.get_worker_mut(worker_name) {
        if let Err(e) = worker::apply_transition(w, WorkerTransition::ToOffline) {
            tracing::error!(
                "Failed to transition worker '{}' to Offline from SessionEnd hook: {}",
                worker_name,
                e
            );
            return Ok(());
        }

        if is_crash {
            w.crash_count = w.crash_count.saturating_add(1);
            w.last_crash_unix = Some(timestamp);
            tracing::warn!(
                worker = %worker_name,
                crash_count = w.crash_count,
                reason = %reason,
                "Worker crashed (non-logout SessionEnd)"
            );
        }
    }

    Ok(())
}

fn handle_stop(
    worker_name: &str,
    _timestamp: u64,
    state: &mut State,
    config: &Config,
) -> Result<()> {
    let Some(worker) = state.get_worker(worker_name) else {
        tracing::warn!("Stop hook received for unknown worker '{}'", worker_name);
        return Ok(());
    };
    let current_status = worker.status;
    let worktree_path = PathBuf::from(&worker.worktree_path);
    let self_review_enabled = worker.self_review;
    let stored_sha = worker.commit_sha.clone();
    match current_status {
        WorkerStatus::Working | WorkerStatus::Rejected => {
            let has_commits = match git::has_commits_ahead_of(&worktree_path, "origin/master") {
                Ok(v) => v,
                Err(e) => {
                    tracing::warn!(
                        worker = %worker_name,
                        error = %e,
                        "Stop hook: failed to check commits ahead of origin/master"
                    );
                    return Ok(());
                }
            };
            if !has_commits {
                tracing::debug!(
                    worker = %worker_name,
                    "Stop hook: no commits ahead of origin/master, worker still thinking"
                );
                return Ok(());
            }
            if git::has_uncommitted_changes(&worktree_path)? {
                tracing::info!(
                    worker = %worker_name,
                    "Stop hook: worker has uncommitted changes, amending to existing commit"
                );
                git::amend_uncommitted_changes(&worktree_path)?;
            }
            let commit_sha = git::get_head_commit(&worktree_path)?;
            let commit_msg = git::get_commit_message(&worktree_path, &commit_sha)
                .unwrap_or_else(|_| "<unknown>".to_string());
            let first_line = commit_msg.lines().next().unwrap_or("<empty>");
            tracing::info!(
                worker = %worker_name,
                commit_sha = %commit_sha,
                commit_msg = %first_line,
                "Stop hook: transitioning worker to NeedsReview"
            );
            let transition = WorkerTransition::ToNeedsReview { commit_sha };
            if let Some(w) = state.get_worker_mut(worker_name) {
                worker::apply_transition(w, transition)?;
                if self_review_enabled {
                    w.pending_self_review = true;
                    tracing::info!(
                        worker = %worker_name,
                        "Stop hook: queued self-review for next maintenance tick"
                    );
                } else {
                    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                    w.on_complete_sent_unix = Some(now);
                    tracing::info!(
                        worker = %worker_name,
                        "Stop hook: self_review disabled, skipping self-review"
                    );
                }
                let _ = sound::play_bell(config);
            }
        }
        WorkerStatus::Reviewing => {
            let current_sha = match git::get_head_commit(&worktree_path) {
                Ok(sha) => sha,
                Err(e) => {
                    tracing::warn!(
                        "Stop hook: failed to get HEAD for Reviewing worker '{}': {}",
                        worker_name,
                        e
                    );
                    return Ok(());
                }
            };
            let sha_changed = stored_sha.as_ref() != Some(&current_sha);
            if sha_changed {
                tracing::info!(
                    worker = %worker_name,
                    old_sha = ?stored_sha,
                    new_sha = %current_sha,
                    "Stop hook: Reviewing worker amended commit, transitioning to NeedsReview"
                );
            } else {
                tracing::info!(
                    worker = %worker_name,
                    "Stop hook: self-review complete, transitioning to NeedsReview"
                );
            }
            let transition = WorkerTransition::ToNeedsReview { commit_sha: current_sha };
            if let Some(w) = state.get_worker_mut(worker_name) {
                if let Err(e) = worker::apply_transition(w, transition) {
                    tracing::error!(
                        "Stop hook: failed to transition Reviewing worker '{}' to NeedsReview: {}",
                        worker_name,
                        e
                    );
                } else {
                    let _ = sound::play_bell(config);
                }
            }
        }
        _ => {
            tracing::debug!(
                worker = %worker_name,
                status = ?current_status,
                "Stop hook: ignoring for worker not in Working/Rejected/Reviewing state"
            );
        }
    }
    Ok(())
}

fn build_conflict_prompt(conflicts: &[String], original_task: &str) -> String {
    let mut prompt = String::from(
        "REBASE CONFLICT DETECTED\n\
         \n\
         Master has advanced and your changes need to be rebased. The rebase has encountered conflicts.\n\
         \n",
    );
    prompt
        .push_str(
            &format!(
                "IMPORTANT - Your original task:\n\
         \"{}\"\n\
         \n\
         DO NOT restart your task from scratch. Instead, INCORPORATE your existing changes/intent \n\
         into the new repository state. Your goal is to apply the same logical changes you already \n\
         made, but adapted to work with the new state of the files after master's changes.\n\
         \n",
                original_task.lines().take(3).collect::< Vec < _ >> ().join(" ")
            ),
        );
    prompt.push_str("Conflicting files:\n");
    for file in conflicts {
        prompt.push_str(&format!("- {}\n", file));
    }
    prompt
        .push_str(
            "\n\
         IMPORTANT - Resolution steps (must complete ALL steps):\n\
         1. Read and understand the conflict markers in each file (<<<<<<, =======, >>>>>>>)\n\
         2. Understand what master changed (their version) and what you changed (our version)\n\
         3. Decide how to INCORPORATE YOUR CHANGES into the new state - do NOT just accept theirs\n\
         4. Edit files to remove ALL conflict markers and apply your intended changes\n\
         5. Stage ALL resolved files: git add <file>\n\
         6. Continue the rebase: git rebase --continue\n\
         7. Verify success: Look for \"Successfully rebased and updated\" message\n\
         8. Run validation: just review\n\
         9. IMPORTANT: If validation modified any files, amend them: git add -A && git commit --amend --no-edit\n\
         \n\
         Helpful commands:\n\
         - View our version: git show :2:<file>\n\
         - View their version: git show :3:<file>\n\
         - Check remaining conflicts: git diff --name-only --diff-filter=U\n\
         - If you need to start over: git rebase --abort\n\
         \n\
         CRITICAL: You MUST run 'git rebase --continue' after staging files.\n\
         Do NOT commit manually. The rebase process handles commits automatically.\n",
        );
    prompt
}

fn get_self_review_config(config: &Config) -> Option<&SelfReviewConfig> {
    config.defaults.self_review.as_ref()
}

fn send_self_review_prompt(
    session_id: &str,
    self_review_config: &SelfReviewConfig,
    original_prompt: &str,
) -> Result<()> {
    let sender = TmuxSender::new();
    if self_review_config.clear {
        tracing::info!("Sending /clear before self-review prompt to session '{}'", session_id);
        sender.send(session_id, "/clear")?;
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    let mut prompt = self_review_config.prompt.clone();
    if self_review_config.include_original && !original_prompt.is_empty() {
        prompt.push_str("\n\n--- Original Prompt ---\n\n");
        prompt.push_str(original_prompt);
    }
    tracing::info!("Sending self-review prompt to session '{}'", session_id);
    sender.send(session_id, &prompt)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use crate::config::{DefaultsConfig, RepoConfig};
    use crate::patrol::*;
    use crate::state::WorkerRecord;

    fn create_test_worker(name: &str) -> WorkerRecord {
        WorkerRecord {
            name: name.to_string(),
            worktree_path: format!("/tmp/llmc/.worktrees/{}", name),
            branch: format!("llmc/{}", name),
            status: WorkerStatus::Idle,
            current_prompt: String::new(),
            prompt_cmd: None,
            created_at_unix: 1000000000,
            last_activity_unix: 1000000000,
            commit_sha: None,
            session_id: format!("llmc-{}", name),
            crash_count: 0,
            last_crash_unix: None,
            on_complete_sent_unix: None,
            self_review: false,
            pending_self_review: false,
        }
    }

    fn create_test_config() -> Config {
        Config {
            defaults: DefaultsConfig {
                model: "opus".to_string(),
                skip_permissions: true,
                allowed_tools: vec![],
                patrol_interval_secs: 60,
                sound_on_review: false,
                self_review: None,
            },
            repo: RepoConfig { source: "/test".to_string() },
            workers: HashMap::new(),
        }
    }

    #[test]
    fn test_handle_stop_unknown_worker() {
        let mut state = State::new();
        let config = create_test_config();
        let result = handle_stop("unknown_worker", 12345, &mut state, &config);
        assert!(result.is_ok());
    }

    #[test]
    fn test_handle_stop_idle_worker_ignored() {
        let mut state = State::new();
        let worker = create_test_worker("adam");
        state.add_worker(worker);
        let config = create_test_config();
        let result = handle_stop("adam", 12345, &mut state, &config);
        assert!(result.is_ok());
        assert_eq!(state.get_worker("adam").unwrap().status, WorkerStatus::Idle);
    }

    #[test]
    fn test_patrol_report_default() {
        let report = PatrolReport::default();
        assert_eq!(report.sessions_checked, 0);
        assert!(report.transitions_applied.is_empty());
        assert!(report.rebases_triggered.is_empty());
        assert!(report.errors.is_empty());
    }
    #[test]
    fn test_build_conflict_prompt() {
        let conflicts = vec!["src/main.rs".to_string(), "src/lib.rs".to_string()];
        let original_task = "Fix the authentication bug in the login system";
        let prompt = build_conflict_prompt(&conflicts, original_task);
        assert!(prompt.contains("REBASE CONFLICT DETECTED"));
        assert!(prompt.contains("src/main.rs"));
        assert!(prompt.contains("src/lib.rs"));
        assert!(prompt.contains("IMPORTANT - Resolution steps (must complete ALL steps):"));
        assert!(prompt.contains("Your original task:"));
        assert!(prompt.contains("Fix the authentication bug"));
        assert!(prompt.contains("git rebase --continue"));
        assert!(prompt.contains("Successfully rebased and updated"));
    }
}
