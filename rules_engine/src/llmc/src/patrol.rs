use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

use anyhow::Result;
use lattice::cli::color_theme;

use crate::config::{Config, SelfReviewConfig};
use crate::ipc::messages::HookEvent;
use crate::state::{self, State, WorkerStatus};
use crate::tmux::sender::TmuxSender;
use crate::tmux::session;
use crate::worker::{self, WorkerTransition};
use crate::{git, recovery, sound, transcript_reader};

const OVERSEER_WORKER_NAME: &str = "overseer";

static PATROL_RUNNING: AtomicBool = AtomicBool::new(false);

pub const DIRTY_WORKTREE_ERROR: &str = "Dirty worktree detected during patrol";

/// Patrol system configuration
pub struct Patrol {}

/// Report generated by a patrol run
#[derive(Debug, Default)]
pub struct PatrolReport {
    pub sessions_checked: u32,
    pub transitions_applied: Vec<(String, WorkerTransition)>,
    pub rebases_triggered: Vec<String>,
    pub errors: Vec<String>,
}

/// Handles a hook event from Claude Code, applying state transitions as needed.
///
/// This function processes SessionStart, SessionEnd, and Stop events to detect
/// when workers come online, crash/shutdown, or complete their current task.
pub fn handle_hook_event(event: &HookEvent, state: &mut State, config: &Config) -> Result<()> {
    match event {
        HookEvent::SessionStart { worker, session_id, timestamp } => {
            handle_session_start(worker, session_id, *timestamp, state)?;
        }
        HookEvent::SessionEnd { worker, reason, timestamp, transcript_path } => {
            handle_session_end(
                worker,
                reason,
                *timestamp,
                transcript_path.as_deref(),
                state,
                config,
            )?;
        }
        HookEvent::Stop { worker, timestamp, .. } => {
            handle_stop(worker, *timestamp, state, config)?;
        }
    }
    Ok(())
}

pub fn handle_stop(
    worker_name: &str,
    _timestamp: u64,
    state: &mut State,
    config: &Config,
) -> Result<()> {
    if is_overseer_worker(worker_name) {
        tracing::debug!(
            worker = %worker_name,
            "Stop hook from overseer session, ignoring"
        );
        return Ok(());
    }

    let Some(worker) = state.get_worker(worker_name) else {
        tracing::error!(
            worker = %worker_name,
            "Stop hook received for unknown worker - this indicates state file corruption or \
             misconfigured hooks. Run 'llmc doctor --repair' to diagnose."
        );
        return Ok(());
    };
    let current_status = worker.status;
    let worktree_path = PathBuf::from(&worker.worktree_path);
    let self_review_enabled = worker.self_review;
    let stored_sha = worker.commit_sha.clone();
    match current_status {
        WorkerStatus::Working | WorkerStatus::Rejected => {
            let has_commits = match git::has_commits_ahead_of(&worktree_path, "origin/master") {
                Ok(v) => v,
                Err(e) => {
                    tracing::error!(
                        worker = %worker_name,
                        error = %e,
                        "Stop hook: failed to check commits - task completion detection may have \
                         failed. Worker may be stuck in Working state. Check worktree integrity."
                    );
                    return Ok(());
                }
            };
            let has_uncommitted = git::has_uncommitted_changes(&worktree_path)?;
            if !has_commits && !has_uncommitted {
                tracing::info!(
                    worker = %worker_name,
                    "Stop hook: task completed without commits (e.g., review-only task), transitioning to NoChanges"
                );
                let transition = WorkerTransition::ToNoChanges;
                if let Some(w) = state.get_worker_mut(worker_name) {
                    worker::apply_transition(w, transition)?;
                    w.pending_self_review = false;
                }
                let _ = sound::play_bell(config);
                return Ok(());
            }
            if has_uncommitted {
                if has_commits {
                    tracing::info!(
                        worker = %worker_name,
                        "Stop hook: worker has uncommitted changes, amending to existing commit"
                    );
                    git::amend_uncommitted_changes(&worktree_path)?;
                } else {
                    tracing::info!(
                        worker = %worker_name,
                        "Stop hook: worker has uncommitted changes but no commit, creating commit"
                    );
                    git::create_uncommitted_changes_commit(&worktree_path)?;
                }
            }
            let commit_sha = git::get_head_commit(&worktree_path)?;
            let commit_msg = git::get_commit_message(&worktree_path, &commit_sha)
                .unwrap_or_else(|_| "<unknown>".to_string());
            let first_line = commit_msg.lines().next().unwrap_or("<empty>");
            tracing::info!(
                worker = %worker_name,
                commit_sha = %commit_sha,
                commit_msg = %first_line,
                "Stop hook: transitioning worker to NeedsReview"
            );
            let transition = WorkerTransition::ToNeedsReview { commit_sha };
            if let Some(w) = state.get_worker_mut(worker_name) {
                worker::apply_transition(w, transition)?;
                w.commits_first_detected_unix = None;
                if self_review_enabled {
                    w.pending_self_review = true;
                    tracing::info!(
                        worker = %worker_name,
                        "Stop hook: queued self-review for next maintenance tick"
                    );
                } else {
                    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                    w.on_complete_sent_unix = Some(now);
                    tracing::info!(
                        worker = %worker_name,
                        "Stop hook: self_review disabled, skipping self-review"
                    );
                }
                let _ = sound::play_bell(config);
            }
        }
        WorkerStatus::Reviewing => {
            let current_sha = match git::get_head_commit(&worktree_path) {
                Ok(sha) => sha,
                Err(e) => {
                    tracing::error!(
                        worker = %worker_name,
                        error = %e,
                        worktree = %worktree_path.display(),
                        "Stop hook: failed to get HEAD for Reviewing worker - git repository may \
                         be corrupted. Run 'llmc reset {}' to recover.",
                        worker_name
                    );
                    return Ok(());
                }
            };
            let sha_changed = stored_sha.as_ref() != Some(&current_sha);
            if sha_changed {
                tracing::info!(
                    worker = %worker_name,
                    old_sha = ?stored_sha,
                    new_sha = %current_sha,
                    "Stop hook: Reviewing worker amended commit, transitioning to NeedsReview"
                );
            } else {
                tracing::info!(
                    worker = %worker_name,
                    "Stop hook: self-review complete, transitioning to NeedsReview"
                );
            }
            let transition = WorkerTransition::ToNeedsReview { commit_sha: current_sha };
            if let Some(w) = state.get_worker_mut(worker_name) {
                if let Err(e) = worker::apply_transition(w, transition) {
                    tracing::error!(
                        "Stop hook: failed to transition Reviewing worker '{}' to NeedsReview: {}",
                        worker_name,
                        e
                    );
                } else {
                    w.commits_first_detected_unix = None;
                    w.pending_self_review = false;
                    let _ = sound::play_bell(config);
                }
            }
        }
        _ => {
            tracing::debug!(
                worker = %worker_name,
                status = ?current_status,
                "Stop hook: ignoring for worker not in Working/Rejected/Reviewing state"
            );
        }
    }
    Ok(())
}

pub fn build_conflict_prompt(conflicts: &[String], original_task: &str) -> String {
    let mut prompt = String::from(
        "REBASE CONFLICT DETECTED\n\
         \n\
         Master has advanced and your changes need to be rebased. The rebase has encountered conflicts.\n\
         \n",
    );
    prompt
        .push_str(
            &format!(
                "IMPORTANT - Your original task:\n\
         \"{}\"\n\
         \n\
         DO NOT restart your task from scratch. Instead, INCORPORATE your existing changes/intent \n\
         into the new repository state. Your goal is to apply the same logical changes you already \n\
         made, but adapted to work with the new state of the files after master's changes.\n\
         \n",
                original_task.lines().take(3).collect::< Vec < _ >> ().join(" ")
            ),
        );
    prompt.push_str("Conflicting files:\n");
    for file in conflicts {
        prompt.push_str(&format!("- {}\n", file));
    }
    prompt
        .push_str(
            "\n\
         IMPORTANT - Resolution steps (must complete ALL steps):\n\
         1. Read and understand the conflict markers in each file (<<<<<<, =======, >>>>>>>)\n\
         2. Understand what master changed (their version) and what you changed (our version)\n\
         3. Decide how to INCORPORATE YOUR CHANGES into the new state - do NOT just accept theirs\n\
         4. Edit files to remove ALL conflict markers and apply your intended changes\n\
         5. Stage ALL resolved files: git add <file>\n\
         6. Continue the rebase: git rebase --continue\n\
         7. Verify success: Look for \"Successfully rebased and updated\" message\n\
         8. Run validation: just review\n\
         9. IMPORTANT: If validation modified any files, amend them: git add -A && git commit --amend --no-edit\n\
         \n\
         Helpful commands:\n\
         - View our version: git show :2:<file>\n\
         - View their version: git show :3:<file>\n\
         - Check remaining conflicts: git diff --name-only --diff-filter=U\n\
         - If you need to start over: git rebase --abort\n\
         \n\
         CRITICAL: You MUST run 'git rebase --continue' after staging files.\n\
         Do NOT commit manually. The rebase process handles commits automatically.\n",
        );
    prompt
}

fn is_overseer_worker(worker_name: &str) -> bool {
    worker_name == OVERSEER_WORKER_NAME
}

impl Patrol {
    pub fn new(_config: &Config) -> Self {
        Self {}
    }

    pub fn run_patrol(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        if PATROL_RUNNING.swap(true, Ordering::SeqCst) {
            tracing::debug!("Skipping patrol run - another patrol is in progress");
            return Ok(PatrolReport::default());
        }
        let result = self.run_patrol_impl(state, config);
        PATROL_RUNNING.store(false, Ordering::SeqCst);
        result
    }

    fn run_patrol_impl(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        let mut report = PatrolReport::default();
        self.check_session_health(state, &mut report)?;
        self.check_state_consistency(state, &mut report)?;
        self.detect_state_transitions(state, &mut report)?;
        if !report.transitions_applied.is_empty() {
            let state_path = state::get_state_path();
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state after {} transitions (self-review may not trigger): {}",
                    report.transitions_applied.len(),
                    e
                );
            } else {
                tracing::debug!(
                    "Saved state after {} transitions",
                    report.transitions_applied.len()
                );
            }
        }
        self.send_pending_self_review_prompts(state, config)?;
        self.send_pending_rebase_prompts(state)?;
        let transitioned_workers: std::collections::HashSet<String> =
            report.transitions_applied.iter().map(|(name, _)| name.clone()).collect();
        self.rebase_pending_reviews(state, &transitioned_workers, &mut report)?;
        if !report.rebases_triggered.is_empty() {
            let state_path = state::get_state_path();
            tracing::info!(
                rebases = ?report.rebases_triggered,
                "Saving state after rebases triggered"
            );
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state after {} rebases triggered: {}",
                    report.rebases_triggered.len(),
                    e
                );
            } else {
                tracing::info!(
                    "Saved state after {} rebases triggered",
                    report.rebases_triggered.len()
                );
            }
        }
        Ok(report)
    }

    fn check_session_health(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            report.sessions_checked += 1;
            if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                if recovery::should_reset_crash_count(worker_mut, now) {
                    tracing::info!(
                        "Worker {} crash count expired (24h), resetting from {}",
                        worker_name,
                        worker_mut.crash_count
                    );
                    worker_mut.crash_count = 0;
                    worker_mut.last_crash_unix = None;
                }
                if recovery::should_reset_api_error_count(worker_mut, now) {
                    tracing::info!(
                        "Worker {} API error count expired (24h), resetting from {}",
                        worker_name,
                        worker_mut.api_error_count
                    );
                    worker_mut.api_error_count = 0;
                    worker_mut.last_api_error_unix = None;
                }
            }
        }
        Ok(())
    }

    fn check_state_consistency(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let (worker_status, worktree_path) = {
                let Some(worker) = state.get_worker(&worker_name) else { continue };
                (worker.status, worker.worktree_path.clone())
            };
            let worktree_path = std::path::Path::new(&worktree_path);
            if !worktree_path.exists() {
                continue;
            }
            if worker_status == WorkerStatus::Idle {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        let is_linear = git::is_ancestor(worktree_path, "origin/master", "HEAD")
                            .unwrap_or(false);
                        if !is_linear {
                            // Before resetting, check if there's a rebase in progress
                            // which would indicate the worker was rebasing when daemon restarted
                            if git::is_rebase_in_progress(worktree_path) {
                                tracing::info!(
                                    worker = %worker_name,
                                    "Idle worker has diverged history with active rebase - \
                                     restoring Rebasing state from before daemon restart"
                                );
                                if let Some(w) = state.get_worker_mut(&worker_name) {
                                    if let Err(e) =
                                        worker::apply_transition(w, WorkerTransition::ToRebasing)
                                    {
                                        tracing::error!(
                                            "Failed to transition worker '{}' to Rebasing: {}",
                                            worker_name,
                                            e
                                        );
                                    } else {
                                        report.transitions_applied.push((
                                            worker_name.clone(),
                                            WorkerTransition::ToRebasing,
                                        ));
                                    }
                                }
                                continue;
                            }
                            tracing::info!(
                                "Worker '{}' is idle with diverged history (origin/master not an ancestor of HEAD), resetting to origin/master",
                                worker_name
                            );
                            match git::reset_to_ref(worktree_path, "origin/master") {
                                Ok(()) => {
                                    tracing::info!(
                                        "Successfully reset idle worker '{}' to origin/master",
                                        worker_name
                                    );
                                }
                                Err(e) => {
                                    tracing::error!(
                                        worker = %worker_name,
                                        error = %e,
                                        "Failed to reset idle worker to origin/master. Worker may \
                                         have stale commits. Run 'llmc reset {}' to manually recover.",
                                        worker_name
                                    );
                                }
                            }
                            continue;
                        }
                        tracing::info!(
                            "Worker '{}' is idle but has commits ahead of master, transitioning to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before transitioning to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => {}
                    Err(e) => {
                        tracing::error!(
                            worker = %worker_name,
                            error = %e,
                            "Failed to check commits ahead of master - worker state may be stale. \
                             Completed work could go undetected. Check worktree at {}",
                            worktree_path.display()
                        );
                    }
                }
                match git::is_worktree_clean(worktree_path) {
                    Ok(false) => {
                        tracing::error!(
                            worker = %worker_name,
                            worktree = %worktree_path.display(),
                            "Worker is idle but has dirty worktree - possible uncommitted work. \
                             Marking as error. Run 'llmc reset {}' to recover (will discard changes), \
                             or manually commit/discard changes and run 'llmc doctor --repair'.",
                            worker_name
                        );
                        let transition =
                            WorkerTransition::ToError { reason: DIRTY_WORKTREE_ERROR.to_string() };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                    Ok(true) => {}
                    Err(e) => {
                        tracing::error!(
                            worker = %worker_name,
                            error = %e,
                            worktree = %worktree_path.display(),
                            "Failed to check worktree cleanliness - git status command failed. \
                             Check if worktree exists and git repository is intact."
                        );
                    }
                }
            }
            if worker_status == WorkerStatus::Error {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        tracing::info!(
                            "Worker '{}' in error state has commits ahead of master, recovering to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before recovering to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => match git::is_worktree_clean(worktree_path) {
                        Ok(true) => {
                            let error_reason = state
                                .get_worker(&worker_name)
                                .and_then(|w| w.error_reason.as_deref());
                            if error_reason == Some(DIRTY_WORKTREE_ERROR) {
                                tracing::info!(
                                    "Worker '{}' was in error due to dirty worktree, worktree is now clean. \
                                     Uncommitted changes may have been lost. Use 'llmc reset {}' to recover.",
                                    worker_name,
                                    worker_name
                                );
                            } else {
                                tracing::info!(
                                    "Worker '{}' in error state has clean worktree, recovering to idle",
                                    worker_name
                                );
                                let transition = WorkerTransition::ToIdle;
                                if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                                    worker::apply_transition(worker_mut, transition.clone())?;
                                    report
                                        .transitions_applied
                                        .push((worker_name.clone(), transition));
                                }
                                continue;
                            }
                        }
                        Ok(false) => {}
                        Err(e) => {
                            tracing::error!(
                                worker = %worker_name,
                                error = %e,
                                worktree = %worktree_path.display(),
                                "Failed to check worktree cleanliness for error worker - \
                                 cannot determine recovery path. Check git repository integrity."
                            );
                        }
                    },
                    Err(e) => {
                        tracing::error!(
                            worker = %worker_name,
                            error = %e,
                            worktree = %worktree_path.display(),
                            "Failed to check commits ahead for error worker - \
                             cannot determine recovery path. Check git repository integrity."
                        );
                    }
                }
            }
            // Fallback: detect Working/Rejected workers with commits where Stop hook may
            // have failed. We track when commits were FIRST DETECTED (not when work
            // started) to avoid false positives when workers commit early and continue.
            if matches!(worker_status, WorkerStatus::Working | WorkerStatus::Rejected) {
                let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                const FALLBACK_DELAY_SECS: u64 = 300;

                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        let commits_first_detected = state
                            .get_worker(&worker_name)
                            .and_then(|w| w.commits_first_detected_unix);

                        if commits_first_detected.is_none() {
                            tracing::info!(
                                worker = %worker_name,
                                status = ?worker_status,
                                "Commits first detected ahead of master, starting fallback timer"
                            );
                            if let Some(w) = state.get_worker_mut(&worker_name) {
                                w.commits_first_detected_unix = Some(now);
                            }
                        } else if let Some(first_detected) = commits_first_detected {
                            let elapsed_since_commits = now.saturating_sub(first_detected);
                            if elapsed_since_commits >= FALLBACK_DELAY_SECS {
                                let hook_config_path =
                                    worktree_path.join(".claude").join("settings.json");
                                let hook_config_missing = !hook_config_path.exists();
                                tracing::info!(
                                    worker = %worker_name,
                                    status = ?worker_status,
                                    elapsed_since_commits_secs = elapsed_since_commits,
                                    hook_config_missing = hook_config_missing,
                                    "FALLBACK RECOVERY: Stop hook didn't fire - commits detected {}s ago. \
                                     {}. Recovering worker to needs_review state.",
                                    elapsed_since_commits,
                                    if hook_config_missing {
                                        "Hook config is MISSING - this is likely the cause"
                                    } else {
                                        "Hook config exists but hook may have timed out or failed"
                                    }
                                );
                                if git::has_uncommitted_changes(worktree_path)? {
                                    tracing::info!(
                                        worker = %worker_name,
                                        "Worker has uncommitted changes, amending before recovering to needs_review"
                                    );
                                    git::amend_uncommitted_changes(worktree_path)?;
                                }
                                let commit_sha = git::get_head_commit(worktree_path)?;
                                let transition = WorkerTransition::ToNeedsReview {
                                    commit_sha: commit_sha.clone(),
                                };
                                if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                                    let self_review_enabled = worker_mut.self_review;
                                    worker::apply_transition(worker_mut, transition.clone())?;
                                    worker_mut.commits_first_detected_unix = None;
                                    report
                                        .transitions_applied
                                        .push((worker_name.clone(), transition));
                                    if self_review_enabled {
                                        worker_mut.pending_self_review = true;
                                    } else {
                                        worker_mut.on_complete_sent_unix = Some(now);
                                    }
                                }
                                continue;
                            } else {
                                let hook_config_path =
                                    worktree_path.join(".claude").join("settings.json");
                                let hook_config_exists = hook_config_path.exists();
                                if !hook_config_exists {
                                    tracing::error!(
                                        worker = %worker_name,
                                        elapsed_since_commits_secs = elapsed_since_commits,
                                        remaining_secs = FALLBACK_DELAY_SECS - elapsed_since_commits,
                                        hook_config_path = %hook_config_path.display(),
                                        "Stop hook likely not configured - .claude/settings.json missing! \
                                         Waiting for fallback timeout (restart 'llmc up' to regenerate hook config)"
                                    );
                                } else {
                                    tracing::info!(
                                        worker = %worker_name,
                                        elapsed_since_commits_secs = elapsed_since_commits,
                                        remaining_secs = FALLBACK_DELAY_SECS - elapsed_since_commits,
                                        "Waiting for Stop hook or fallback timeout"
                                    );
                                }
                            }
                        }
                    }
                    Ok(false) => {
                        if let Some(w) = state.get_worker_mut(&worker_name)
                            && w.commits_first_detected_unix.is_some()
                        {
                            tracing::debug!(
                                worker = %worker_name,
                                "No commits ahead of master, clearing commits_first_detected_unix"
                            );
                            w.commits_first_detected_unix = None;
                        }
                    }
                    Err(e) => {
                        tracing::error!(
                            worker = %worker_name,
                            error = %e,
                            worktree = %worktree_path.display(),
                            "Failed to check commits ahead of origin/master - worker completion \
                             may not be detected. Check git repository integrity."
                        );
                    }
                }
            }
            if worker_status != WorkerStatus::Rebasing && git::is_rebase_in_progress(worktree_path)
            {
                tracing::info!(
                    worker = %worker_name,
                    status = ?worker_status,
                    "Orphaned rebase state detected, attempting automatic cleanup"
                );
                match git::abort_rebase(worktree_path) {
                    Ok(()) => {
                        tracing::info!(
                            "Successfully cleaned up orphaned rebase state for worker '{}'",
                            worker_name
                        );
                    }
                    Err(e) => {
                        tracing::error!(
                            "Failed to clean up orphaned rebase state for worker '{}': {}",
                            worker_name,
                            e
                        );
                        let transition = WorkerTransition::ToError {
                            reason: format!(
                                "Orphaned rebase state detected and cleanup failed: {}",
                                e
                            ),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                }
            }
        }
        Ok(())
    }

    fn detect_state_transitions(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            let current_status = worker.status;
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();
            let transition = match current_status {
                WorkerStatus::Rebasing => {
                    self.detect_rebasing_transition(&worker_name, &worktree_path)?
                }
                WorkerStatus::Offline => self.detect_offline_transition(&worker_name, &session_id),
                _ => WorkerTransition::None,
            };
            if transition != WorkerTransition::None
                && let Some(w) = state.get_worker_mut(&worker_name)
            {
                tracing::info!(
                    "Applying transition for worker '{}': {:?} -> {:?}",
                    worker_name,
                    current_status,
                    transition
                );
                worker::apply_transition(w, transition.clone())?;
                report.transitions_applied.push((worker_name.clone(), transition.clone()));
                if matches!(transition, WorkerTransition::ToNeedsReview { .. })
                    && current_status == WorkerStatus::Rebasing
                {
                    // Worker is transitioning from Rebasing -> NeedsReview.
                    // Self-review (if enabled) was already completed before the rebase started,
                    // so we mark self-review as complete and don't re-queue it.
                    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                    w.on_complete_sent_unix = Some(now);
                    println!(
                        "{}",
                        color_theme::success(format!(
                            "[{}] ✓ Rebase conflict resolved",
                            worker_name
                        ))
                    );
                    tracing::info!(
                        "Worker '{}' rebase complete, ready for human review",
                        worker_name
                    );
                }
                if transition == WorkerTransition::ToIdle && current_status == WorkerStatus::Offline
                {
                    // Worker transitioning from Offline -> Idle via patrol fallback.
                    // This happens when SessionStart hook fails to fire but session exists.
                    println!(
                        "{}",
                        color_theme::success(format!(
                            "[{}] ✓ Worker ready (via patrol fallback)",
                            worker_name
                        ))
                    );
                }
            }
        }
        Ok(())
    }

    fn send_pending_self_review_prompts(&self, state: &mut State, config: &Config) -> Result<()> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let delay_secs: u64 = 10;
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            if worker.status != WorkerStatus::NeedsReview {
                continue;
            }
            if !worker.pending_self_review {
                continue;
            }
            if worker.on_complete_sent_unix.is_some() {
                continue;
            }
            let Some(self_review_config) = get_self_review_config(config) else {
                tracing::error!(
                    worker = %worker_name,
                    "Worker has pending_self_review but [defaults.self_review] section is \
                     missing from config.toml. Add self_review config or disable self_review \
                     for this worker."
                );
                continue;
            };
            let elapsed = now.saturating_sub(worker.last_activity_unix);
            if elapsed < delay_secs {
                tracing::debug!(
                    worker = % worker_name, elapsed_secs = elapsed, delay_secs,
                    last_activity_unix = worker.last_activity_unix, now_unix = now,
                    "Waiting for self-review delay"
                );
                continue;
            }
            tracing::info!(
                "Worker '{}' eligible for self-review ({}s after completion)",
                worker_name,
                elapsed
            );
            let original_prompt = worker.current_prompt.clone();
            let session_id = worker.session_id.clone();
            if let Some(w) = state.get_worker_mut(&worker_name) {
                w.on_complete_sent_unix = Some(now);
            }
            let state_path = state::get_state_path();
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state before sending self-review to '{}': {}",
                    worker_name,
                    e
                );
                continue;
            }
            tracing::info!(
                "State saved with on_complete_sent_unix={} for worker '{}', now sending prompt",
                now,
                worker_name
            );
            if let Err(e) =
                send_self_review_prompt(&session_id, self_review_config, &original_prompt)
            {
                tracing::error!(
                    "Failed to send self-review prompt to worker '{}': {}",
                    worker_name,
                    e
                );
            } else if let Some(w) = state.get_worker_mut(&worker_name) {
                w.pending_self_review = false;
                if let Err(e) = worker::apply_transition(w, WorkerTransition::ToReviewing) {
                    tracing::error!(
                        "Failed to transition worker '{}' to Reviewing: {}",
                        worker_name,
                        e
                    );
                } else {
                    tracing::info!("Worker '{}' transitioned to Reviewing state", worker_name);
                    let state_path = state::get_state_path();
                    if let Err(e) = state.save(&state_path) {
                        tracing::error!(
                            "Failed to save state after transitioning '{}' to Reviewing: {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
        }
        Ok(())
    }

    fn send_pending_rebase_prompts(&self, state: &mut State) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            if worker.status != WorkerStatus::Rebasing {
                continue;
            }
            if !worker.pending_rebase_prompt {
                continue;
            }
            let worktree_path = PathBuf::from(&worker.worktree_path);
            if !git::is_rebase_in_progress(&worktree_path) {
                tracing::info!(
                    worker = %worker_name,
                    "Worker has pending rebase prompt but rebase is no longer in progress, clearing flag"
                );
                if let Some(w) = state.get_worker_mut(&worker_name) {
                    w.pending_rebase_prompt = false;
                }
                continue;
            }
            let conflicts = match git::get_conflicted_files(&worktree_path) {
                Ok(c) => c,
                Err(e) => {
                    tracing::info!(
                        worker = %worker_name,
                        error = %e,
                        "Failed to get conflicted files, will retry next patrol"
                    );
                    continue;
                }
            };
            let original_prompt = worker.current_prompt.clone();
            let session_id = worker.session_id.clone();
            tracing::info!(
                worker = %worker_name,
                conflicts = ?conflicts,
                "Sending rebase conflict prompt to worker after daemon restart"
            );
            let conflict_prompt = build_conflict_prompt(&conflicts, &original_prompt);
            let sender = TmuxSender::new();
            if let Err(e) = sender.send(&session_id, &conflict_prompt) {
                tracing::error!(
                    worker = %worker_name,
                    error = %e,
                    "Failed to send rebase conflict prompt"
                );
            } else {
                tracing::info!(
                    worker = %worker_name,
                    "Rebase conflict prompt sent successfully"
                );
                if let Some(w) = state.get_worker_mut(&worker_name) {
                    w.pending_rebase_prompt = false;
                }
                let state_path = state::get_state_path();
                if let Err(e) = state.save(&state_path) {
                    tracing::error!(
                        "Failed to save state after sending rebase prompt to '{}': {}",
                        worker_name,
                        e
                    );
                }
            }
        }
        Ok(())
    }

    fn detect_rebasing_transition(
        &self,
        worker_name: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        if git::is_rebase_in_progress(worktree_path) {
            tracing::debug!("Worker {} still has rebase in progress", worker_name);
            return Ok(WorkerTransition::None);
        }
        tracing::info!("Worker {} rebase finished", worker_name);
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!("Worker {} has uncommitted changes after rebase, amending", worker_name);
            git::amend_uncommitted_changes(worktree_path)?;
        }
        let commit_sha = git::get_head_commit(worktree_path)?;
        Ok(WorkerTransition::ToNeedsReview { commit_sha })
    }

    /// Detects if an offline worker's session is actually running.
    ///
    /// This is a fallback mechanism for when SessionStart hooks fail to fire.
    /// If the tmux session exists, we transition the worker to Idle.
    fn detect_offline_transition(&self, worker_name: &str, session_id: &str) -> WorkerTransition {
        if session::session_exists(session_id) {
            tracing::info!(
                worker = %worker_name,
                session_id = %session_id,
                "Patrol detected running session for offline worker (SessionStart hook fallback)"
            );
            WorkerTransition::ToIdle
        } else {
            WorkerTransition::None
        }
    }

    fn rebase_pending_reviews(
        &self,
        state: &mut State,
        transitioned_workers: &std::collections::HashSet<String>,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let workers_to_check: Vec<String> = state
            .workers
            .iter()
            .filter(|(_, w)| w.status == WorkerStatus::NeedsReview)
            .map(|(name, _)| name.clone())
            .collect();
        for worker_name in workers_to_check {
            if transitioned_workers.contains(&worker_name) {
                tracing::debug!(
                    "Skipping rebase check for worker '{}' - just transitioned in this patrol run",
                    worker_name
                );
                continue;
            }
            let worker = state.get_worker(&worker_name).unwrap();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();
            let rebase_in_progress = git::is_rebase_in_progress(&worktree_path);
            tracing::debug!(
                worker = % worker_name, rebase_in_progress,
                "Checking if rebase is in progress before triggering rebase"
            );
            if rebase_in_progress {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - rebase already in progress",
                    worker_name
                );
                continue;
            }
            let has_commits_ahead = git::has_commits_ahead_of(&worktree_path, "origin/master")?;
            let worker_head = git::get_head_commit(&worktree_path)?;
            let origin_master_sha = git::get_head_commit_of_ref(&worktree_path, "origin/master")?;
            if !has_commits_ahead {
                let expected_sha = worker.commit_sha.as_deref().unwrap_or("<none>");
                tracing::info!(
                    worker = % worker_name, worker_head = % worker_head, origin_master =
                    % origin_master_sha, expected_commit_sha = % expected_sha,
                    heads_match = (worker_head == origin_master_sha),
                    "Worker is in needs_review but has no commits ahead of origin/master - work was already merged, resetting to idle"
                );
                let worker_mut = state.get_worker_mut(&worker_name).unwrap();
                worker::apply_transition(worker_mut, WorkerTransition::ToIdle)?;
                report.transitions_applied.push((worker_name.clone(), WorkerTransition::ToIdle));
                continue;
            }
            let merge_base = git::get_merge_base(&worktree_path, "HEAD", "origin/master")?;
            tracing::debug!(
                worker = % worker_name, worker_head = % worker_head, origin_master = %
                origin_master_sha, merge_base = % merge_base,
                "Checking if rebase is needed"
            );
            if merge_base == origin_master_sha {
                tracing::debug!("Worker '{}' is already rebased onto origin/master", worker_name);
                continue;
            }
            tracing::info!(
                worker = % worker_name, merge_base = % merge_base, origin_master = %
                origin_master_sha,
                "Master has advanced - rebasing worker in needs_review"
            );
            match self.trigger_rebase(&worker_name, &worktree_path, &session_id, state) {
                Ok(()) => {
                    report.rebases_triggered.push(worker_name.clone());
                }
                Err(e) => {
                    report.errors.push(format!("Failed to rebase worker '{}': {}", worker_name, e));
                }
            }
        }
        Ok(())
    }

    fn trigger_rebase(
        &self,
        worker_name: &str,
        worktree_path: &Path,
        session_id: &str,
        state: &mut State,
    ) -> Result<()> {
        let llmc_root = crate::config::get_llmc_root();
        git::fetch_origin(&llmc_root)?;
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!(
                "Worker '{}' has uncommitted changes, amending to commit before rebase",
                worker_name
            );
            git::amend_uncommitted_changes(worktree_path)?;
        }
        let rebase_result = git::rebase_onto(worktree_path, "origin/master")?;
        if !rebase_result.success {
            let worker = state.get_worker_mut(worker_name).unwrap();
            worker::apply_transition(worker, WorkerTransition::ToRebasing)?;
            let conflict_prompt =
                build_conflict_prompt(&rebase_result.conflicts, &worker.current_prompt);
            let sender = TmuxSender::new();
            sender.send(session_id, &conflict_prompt)?;
        }
        Ok(())
    }
}

fn handle_session_start(
    worker_name: &str,
    session_id: &str,
    _timestamp: u64,
    state: &mut State,
) -> Result<()> {
    if is_overseer_worker(worker_name) {
        tracing::debug!(
            worker = %worker_name,
            session_id = %session_id,
            "SessionStart hook from overseer session, ignoring"
        );
        return Ok(());
    }

    let Some(worker) = state.get_worker(worker_name) else {
        tracing::error!(
            worker = %worker_name,
            session_id = %session_id,
            "SessionStart hook received for unknown worker - state file may be corrupted \
             or hooks are misconfigured. Run 'llmc doctor --repair' to diagnose."
        );
        return Ok(());
    };

    let has_pending_task = worker.pending_task_prompt.is_some();

    if worker.status == WorkerStatus::Offline {
        tracing::info!(
            worker = %worker_name,
            session_id = %session_id,
            "Worker ready via SessionStart hook, transitioning to Idle"
        );
        if let Some(w) = state.get_worker_mut(worker_name)
            && let Err(e) = worker::apply_transition(w, WorkerTransition::ToIdle)
        {
            tracing::error!(
                "Failed to transition worker '{}' to Idle from SessionStart hook: {}",
                worker_name,
                e
            );
        }
    } else if has_pending_task {
        let pending_prompt = worker.pending_task_prompt.clone().expect("Checked above");
        let tmux_session = crate::config::get_worker_session_name(worker_name);
        tracing::info!(
            worker = %worker_name,
            claude_session_id = %session_id,
            tmux_session = %tmux_session,
            prompt_len = pending_prompt.len(),
            "SessionStart after /clear: sending pending task prompt to TMUX session"
        );
        let tmux_sender = TmuxSender::new();
        if let Err(e) = tmux_sender.send(&tmux_session, &pending_prompt) {
            tracing::error!(
                worker = %worker_name,
                tmux_session = %tmux_session,
                error = %e,
                "Failed to send pending task prompt after SessionStart"
            );
            return Err(e);
        }
        if let Some(w) = state.get_worker_mut(worker_name) {
            w.current_prompt = pending_prompt;
            w.pending_task_prompt = None;
            if let Err(e) = worker::apply_transition(w, WorkerTransition::ToWorking {
                prompt: w.current_prompt.clone(),
                prompt_cmd: None,
            }) {
                tracing::error!(
                    "Failed to transition worker '{}' to Working after sending pending prompt: {}",
                    worker_name,
                    e
                );
            }
        }
    } else {
        tracing::info!(
            worker = %worker_name,
            session_id = %session_id,
            current_status = ?worker.status,
            has_prompt = !worker.current_prompt.is_empty(),
            "SessionStart hook received but worker is not Offline, preserving current state"
        );
    }

    Ok(())
}

fn handle_session_end(
    worker_name: &str,
    reason: &str,
    timestamp: u64,
    transcript_path: Option<&str>,
    state: &mut State,
    _config: &Config,
) -> Result<()> {
    if is_overseer_worker(worker_name) {
        tracing::debug!(
            worker = %worker_name,
            reason = %reason,
            "SessionEnd hook from overseer session, ignoring"
        );
        return Ok(());
    }

    let Some(worker) = state.get_worker(worker_name) else {
        tracing::error!(
            worker = %worker_name,
            reason = %reason,
            "SessionEnd hook received for unknown worker - state file may be corrupted \
             or hooks are misconfigured. Run 'llmc doctor --repair' to diagnose."
        );
        return Ok(());
    };

    if worker.status == WorkerStatus::Offline {
        tracing::debug!(
            worker = %worker_name,
            "SessionEnd hook received but worker is already Offline, ignoring"
        );
        return Ok(());
    }

    // "clear" happens when /clear is sent - not a real session end, Claude restarts
    // immediately. "logout" is a normal exit (e.g., user typed /exit).
    // Any other reason (e.g., "error", "crash") is treated as an unexpected crash.
    if reason == "clear" {
        tracing::debug!(
            worker = %worker_name,
            current_status = ?worker.status,
            "SessionEnd hook with reason='clear' ignored - /clear causes immediate session restart"
        );
        return Ok(());
    }

    let is_crash = reason != "logout";

    // Check transcript for API errors (500s, rate limits, etc.)
    let api_error_info = transcript_path.and_then(|path| {
        let path = Path::new(path);
        match transcript_reader::scan_transcript_for_api_errors(path, 50) {
            Ok(info) => {
                if info.has_errors() {
                    tracing::info!(
                        worker = %worker_name,
                        error_count = info.error_count,
                        has_500_error = info.has_500_error,
                        has_rate_limit = info.has_rate_limit_error,
                        last_error = ?info.last_error_message,
                        "Detected API errors in transcript"
                    );
                }
                Some(info)
            }
            Err(e) => {
                tracing::debug!(
                    worker = %worker_name,
                    error = %e,
                    transcript_path = %path.display(),
                    "Failed to scan transcript for API errors"
                );
                None
            }
        }
    });

    let is_api_error = api_error_info
        .as_ref()
        .map(|info| info.has_500_error || info.has_rate_limit_error)
        .unwrap_or(false);

    tracing::info!(
        worker = %worker_name,
        reason = %reason,
        is_crash = is_crash,
        is_api_error = is_api_error,
        "Worker offline via SessionEnd hook"
    );

    if let Some(w) = state.get_worker_mut(worker_name) {
        if let Err(e) = worker::apply_transition(w, WorkerTransition::ToOffline) {
            tracing::error!(
                "Failed to transition worker '{}' to Offline from SessionEnd hook: {}",
                worker_name,
                e
            );
            return Ok(());
        }

        if is_api_error {
            // Track API errors separately - they get different backoff treatment
            w.api_error_count = w.api_error_count.saturating_add(1);
            w.last_api_error_unix = Some(timestamp);
            tracing::warn!(
                worker = %worker_name,
                api_error_count = w.api_error_count,
                reason = %reason,
                "Worker session ended due to API error. Will retry with API-specific backoff. \
                 Claude servers may be experiencing issues."
            );
        } else if is_crash {
            w.crash_count = w.crash_count.saturating_add(1);
            w.last_crash_unix = Some(timestamp);
            tracing::error!(
                worker = %worker_name,
                crash_count = w.crash_count,
                reason = %reason,
                "Worker crashed (non-logout SessionEnd). Will auto-restart with exponential \
                 backoff. Use 'llmc attach {}' to inspect or 'llmc reset {}' to force reset.",
                worker_name,
                worker_name
            );
        }
    }

    Ok(())
}

fn get_self_review_config(config: &Config) -> Option<&SelfReviewConfig> {
    config.defaults.self_review.as_ref()
}

fn send_self_review_prompt(
    session_id: &str,
    self_review_config: &SelfReviewConfig,
    original_prompt: &str,
) -> Result<()> {
    let sender = TmuxSender::new();
    if self_review_config.clear {
        tracing::info!("Sending /clear before self-review prompt to session '{}'", session_id);
        sender.send(session_id, "/clear")?;
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    let mut prompt = self_review_config.prompt.clone();
    if self_review_config.include_original && !original_prompt.is_empty() {
        prompt.push_str("\n\n--- Original Prompt ---\n\n");
        prompt.push_str(original_prompt);
    }
    tracing::info!("Sending self-review prompt to session '{}'", session_id);
    sender.send(session_id, &prompt)?;
    Ok(())
}
