use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

use anyhow::Result;

use crate::config::{Config, SelfReviewConfig};
use crate::state::{self, State, WorkerStatus};
use crate::tmux::sender::TmuxSender;
use crate::tmux::session;
use crate::worker::{self, WorkerTransition};
use crate::{git, recovery, sound};
static PATROL_RUNNING: AtomicBool = AtomicBool::new(false);
/// Patrol system configuration
pub struct Patrol {}
/// Report generated by a patrol run
#[derive(Debug, Default)]
pub struct PatrolReport {
    pub sessions_checked: u32,
    pub transitions_applied: Vec<(String, WorkerTransition)>,
    pub rebases_triggered: Vec<String>,
    pub errors: Vec<String>,
}
impl Patrol {
    pub fn new(_config: &Config) -> Self {
        Self {}
    }

    pub fn run_patrol(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        if PATROL_RUNNING.swap(true, Ordering::SeqCst) {
            tracing::debug!("Skipping patrol run - another patrol is in progress");
            return Ok(PatrolReport::default());
        }
        let result = self.run_patrol_impl(state, config);
        PATROL_RUNNING.store(false, Ordering::SeqCst);
        result
    }

    fn run_patrol_impl(&self, state: &mut State, config: &Config) -> Result<PatrolReport> {
        let mut report = PatrolReport::default();
        self.check_session_health(state, config, &mut report)?;
        self.check_state_consistency(state, &mut report)?;
        self.detect_state_transitions(state, config, &mut report)?;
        if !report.transitions_applied.is_empty() {
            let state_path = state::get_state_path();
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state after {} transitions (self-review may not trigger): {}",
                    report.transitions_applied.len(),
                    e
                );
            } else {
                tracing::debug!(
                    "Saved state after {} transitions",
                    report.transitions_applied.len()
                );
            }
        }
        self.send_pending_self_review_prompts(state, config)?;
        self.detect_reviewing_amendments(state, &mut report)?;
        let transitioned_workers: std::collections::HashSet<String> =
            report.transitions_applied.iter().map(|(name, _)| name.clone()).collect();
        self.rebase_pending_reviews(state, &transitioned_workers, &mut report)?;
        Ok(report)
    }

    fn check_session_health(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            report.sessions_checked += 1;
            let worker = state.get_worker(&worker_name).unwrap();
            let session_id = worker.session_id.clone();
            if let Some(worker_mut) = state.get_worker_mut(&worker_name)
                && recovery::should_reset_crash_count(
                    worker_mut,
                    SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
                )
            {
                tracing::info!(
                    "Worker {} crash count expired (24h), resetting from {}",
                    worker_name,
                    worker_mut.crash_count
                );
                worker_mut.crash_count = 0;
                worker_mut.last_crash_unix = None;
            }
            if !session::session_exists(&session_id) {
                tracing::warn!(
                    "Worker '{}' session '{}' not found - marking offline",
                    worker_name,
                    session_id
                );
                if let Some(w) = state.get_worker_mut(&worker_name)
                    && let Err(e) = worker::apply_transition(w, WorkerTransition::ToOffline)
                {
                    report
                        .errors
                        .push(format!("Failed to mark worker '{}' offline: {}", worker_name, e));
                }
                continue;
            }
            let pane_command = session::get_pane_command(&session_id).unwrap_or_default();
            if session::is_shell(&pane_command) {
                tracing::warn!(
                    "Worker '{}' Claude process crashed - attempting restart",
                    worker_name
                );
                let worker = state.get_worker(&worker_name).unwrap();
                let worktree_path = PathBuf::from(&worker.worktree_path);
                if let Err(e) =
                    self.attempt_restart(&worker_name, &session_id, &worktree_path, config)
                {
                    report
                        .errors
                        .push(format!("Failed to restart worker '{}': {}", worker_name, e));
                    if let Some(w) = state.get_worker_mut(&worker_name)
                        && let Err(e) = worker::apply_transition(w, WorkerTransition::ToError {
                            reason: "Claude crashed".to_string(),
                        })
                    {
                        report.errors.push(format!(
                            "Failed to mark worker '{}' as error: {}",
                            worker_name, e
                        ));
                    }
                }
            }
        }
        Ok(())
    }

    fn attempt_restart(
        &self,
        worker_name: &str,
        session_id: &str,
        _worktree_path: &Path,
        config: &Config,
    ) -> Result<()> {
        let worker_config = config
            .get_worker(worker_name)
            .ok_or_else(|| anyhow::anyhow!("Worker config not found"))?;
        worker::start_claude_in_session(session_id, worker_config)?;
        Ok(())
    }

    fn check_state_consistency(&self, state: &mut State, report: &mut PatrolReport) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let (worker_status, worktree_path) = {
                let Some(worker) = state.get_worker(&worker_name) else { continue };
                (worker.status, worker.worktree_path.clone())
            };
            let worktree_path = std::path::Path::new(&worktree_path);
            if !worktree_path.exists() {
                continue;
            }
            if worker_status == WorkerStatus::Idle {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        let is_linear = git::is_ancestor(worktree_path, "origin/master", "HEAD")
                            .unwrap_or(false);
                        if !is_linear {
                            tracing::info!(
                                "Worker '{}' is idle with diverged history (origin/master not an ancestor of HEAD), resetting to origin/master",
                                worker_name
                            );
                            match git::reset_to_ref(worktree_path, "origin/master") {
                                Ok(()) => {
                                    tracing::info!(
                                        "Successfully reset idle worker '{}' to origin/master",
                                        worker_name
                                    );
                                }
                                Err(e) => {
                                    tracing::warn!(
                                        "Failed to reset idle worker '{}' to origin/master: {}",
                                        worker_name,
                                        e
                                    );
                                }
                            }
                            continue;
                        }
                        tracing::info!(
                            "Worker '{}' is idle but has commits ahead of master, transitioning to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before transitioning to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
                match git::is_worktree_clean(worktree_path) {
                    Ok(false) => {
                        tracing::warn!(
                            "Worker '{}' is idle but has dirty worktree, marking as error",
                            worker_name
                        );
                        let transition = WorkerTransition::ToError {
                            reason: "Dirty worktree detected during patrol".to_string(),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                    Ok(true) => {}
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check worktree cleanliness for '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
            if worker_status == WorkerStatus::Error {
                match git::has_commits_ahead_of(worktree_path, "origin/master") {
                    Ok(true) => {
                        tracing::info!(
                            "Worker '{}' in error state has commits ahead of master, recovering to needs_review",
                            worker_name
                        );
                        if git::has_uncommitted_changes(worktree_path)? {
                            tracing::info!(
                                "Worker '{}' has uncommitted changes, amending before recovering to needs_review",
                                worker_name
                            );
                            git::amend_uncommitted_changes(worktree_path)?;
                        }
                        let commit_sha = git::get_head_commit(worktree_path)?;
                        let transition = WorkerTransition::ToNeedsReview { commit_sha };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                        continue;
                    }
                    Ok(false) => match git::is_worktree_clean(worktree_path) {
                        Ok(true) => {
                            tracing::info!(
                                "Worker '{}' in error state has clean worktree, recovering to idle",
                                worker_name
                            );
                            let transition = WorkerTransition::ToIdle;
                            if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                                worker::apply_transition(worker_mut, transition.clone())?;
                                report.transitions_applied.push((worker_name.clone(), transition));
                            }
                            continue;
                        }
                        Ok(false) => {}
                        Err(e) => {
                            tracing::warn!(
                                "Failed to check worktree cleanliness for error worker '{}': {}",
                                worker_name,
                                e
                            );
                        }
                    },
                    Err(e) => {
                        tracing::warn!(
                            "Failed to check commits ahead for error worker '{}': {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
            if worker_status != WorkerStatus::Rebasing && git::is_rebase_in_progress(worktree_path)
            {
                tracing::warn!(
                    "Worker '{}' has orphaned rebase state (status: {:?}), attempting cleanup",
                    worker_name,
                    worker_status
                );
                match git::abort_rebase(worktree_path) {
                    Ok(()) => {
                        tracing::info!(
                            "Successfully cleaned up orphaned rebase state for worker '{}'",
                            worker_name
                        );
                    }
                    Err(e) => {
                        tracing::error!(
                            "Failed to clean up orphaned rebase state for worker '{}': {}",
                            worker_name,
                            e
                        );
                        let transition = WorkerTransition::ToError {
                            reason: format!(
                                "Orphaned rebase state detected and cleanup failed: {}",
                                e
                            ),
                        };
                        if let Some(worker_mut) = state.get_worker_mut(&worker_name) {
                            worker::apply_transition(worker_mut, transition.clone())?;
                            report.transitions_applied.push((worker_name.clone(), transition));
                        }
                    }
                }
            }
        }
        Ok(())
    }

    fn detect_state_transitions(
        &self,
        state: &mut State,
        config: &Config,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            let current_status = worker.status;
            let session_id = worker.session_id.clone();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let self_review_enabled = worker.self_review;
            let transition = match current_status {
                WorkerStatus::Working => {
                    self.detect_working_transition(&session_id, &worktree_path)?
                }
                WorkerStatus::Rebasing => {
                    self.detect_rebasing_transition(&session_id, &worktree_path)?
                }
                _ => WorkerTransition::None,
            };
            if transition != WorkerTransition::None
                && let Some(w) = state.get_worker_mut(&worker_name)
            {
                tracing::info!(
                    "Applying transition for worker '{}': {:?} -> {:?}",
                    worker_name,
                    current_status,
                    transition
                );
                worker::apply_transition(w, transition.clone())?;
                report.transitions_applied.push((worker_name.clone(), transition.clone()));
                if matches!(transition, WorkerTransition::ToNeedsReview { .. }) {
                    if !self_review_enabled {
                        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
                        w.on_complete_sent_unix = Some(now);
                        tracing::info!(
                            "Worker '{}' does not have self_review enabled, skipping self-review",
                            worker_name
                        );
                    }
                    let _ = sound::play_bell(config);
                }
            }
        }
        Ok(())
    }

    fn send_pending_self_review_prompts(&self, state: &mut State, config: &Config) -> Result<()> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let delay_secs: u64 = 10;
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            if worker.status != WorkerStatus::NeedsReview {
                continue;
            }
            if !worker.self_review {
                continue;
            }
            if worker.on_complete_sent_unix.is_some() {
                continue;
            }
            let Some(self_review_config) = get_self_review_config(config) else {
                tracing::warn!(
                    "Worker '{}' has self_review enabled but no self_review config in defaults",
                    worker_name
                );
                continue;
            };
            let elapsed = now.saturating_sub(worker.last_activity_unix);
            if elapsed < delay_secs {
                tracing::debug!(
                    worker = % worker_name, elapsed_secs = elapsed, delay_secs,
                    last_activity_unix = worker.last_activity_unix, now_unix = now,
                    "Waiting for self-review delay"
                );
                continue;
            }
            tracing::info!(
                "Worker '{}' eligible for self-review ({}s after completion)",
                worker_name,
                elapsed
            );
            let original_prompt = worker.current_prompt.clone();
            let session_id = worker.session_id.clone();
            if let Some(w) = state.get_worker_mut(&worker_name) {
                w.on_complete_sent_unix = Some(now);
            }
            let state_path = state::get_state_path();
            if let Err(e) = state.save(&state_path) {
                tracing::error!(
                    "Failed to save state before sending self-review to '{}': {}",
                    worker_name,
                    e
                );
                continue;
            }
            tracing::info!(
                "State saved with on_complete_sent_unix={} for worker '{}', now sending prompt",
                now,
                worker_name
            );
            if let Err(e) =
                send_self_review_prompt(&session_id, self_review_config, &original_prompt)
            {
                tracing::error!(
                    "Failed to send self-review prompt to worker '{}': {}",
                    worker_name,
                    e
                );
            } else if let Some(w) = state.get_worker_mut(&worker_name) {
                if let Err(e) = worker::apply_transition(w, WorkerTransition::ToReviewing) {
                    tracing::error!(
                        "Failed to transition worker '{}' to Reviewing: {}",
                        worker_name,
                        e
                    );
                } else {
                    tracing::info!("Worker '{}' transitioned to Reviewing state", worker_name);
                    let state_path = state::get_state_path();
                    if let Err(e) = state.save(&state_path) {
                        tracing::error!(
                            "Failed to save state after transitioning '{}' to Reviewing: {}",
                            worker_name,
                            e
                        );
                    }
                }
            }
        }
        Ok(())
    }

    fn detect_reviewing_amendments(
        &self,
        state: &mut State,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let worker_names: Vec<String> = state.workers.keys().cloned().collect();
        for worker_name in worker_names {
            let worker = state.get_worker(&worker_name).unwrap();
            if worker.status != WorkerStatus::Reviewing {
                continue;
            }
            let Some(stored_sha) = &worker.commit_sha else {
                tracing::warn!(
                    "Worker '{}' in Reviewing state has no stored commit_sha",
                    worker_name
                );
                continue;
            };
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let current_sha = match git::get_head_commit(&worktree_path) {
                Ok(sha) => sha,
                Err(e) => {
                    tracing::warn!("Failed to get HEAD commit for worker '{}': {}", worker_name, e);
                    continue;
                }
            };
            if &current_sha != stored_sha {
                tracing::info!(
                    "Worker '{}' commit SHA changed from {} to {} - transitioning back to NeedsReview",
                    worker_name,
                    &stored_sha[..7.min(stored_sha.len())],
                    &current_sha[..7.min(current_sha.len())]
                );
                let transition = WorkerTransition::ToNeedsReview { commit_sha: current_sha };
                if let Some(w) = state.get_worker_mut(&worker_name) {
                    if let Err(e) = worker::apply_transition(w, transition.clone()) {
                        report.errors.push(format!(
                            "Failed to transition worker '{}' from Reviewing to NeedsReview: {}",
                            worker_name, e
                        ));
                    } else {
                        report.transitions_applied.push((worker_name.clone(), transition));
                        let _ = sound::play_bell(&crate::config::Config::load(
                            &crate::config::get_config_path(),
                        )?);
                    }
                }
            }
        }
        Ok(())
    }

    fn detect_working_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        let has_commits = git::has_commits_ahead_of(worktree_path, "origin/master")?;
        tracing::debug!(
            "Checking working transition for {}: has_commits={}",
            session_id,
            has_commits
        );
        if has_commits {
            let commit_sha = git::get_head_commit(worktree_path)?;
            let commit_msg = git::get_commit_message(worktree_path, &commit_sha)
                .unwrap_or_else(|_| "<unknown>".to_string());
            let first_line = commit_msg.lines().next().unwrap_or("<empty>");
            if git::has_uncommitted_changes(worktree_path)? {
                tracing::info!(
                    worker = % session_id, commit_sha = % commit_sha, commit_msg = %
                    first_line,
                    "Worker has commits and uncommitted changes, amending before transitioning to needs_review"
                );
                git::amend_uncommitted_changes(worktree_path)?;
            }
            tracing::info!(
                worker = % session_id, commit_sha = % commit_sha, commit_msg = %
                first_line,
                "Worker has commits ahead of origin/master, transitioning to needs_review"
            );
            return Ok(WorkerTransition::ToNeedsReview { commit_sha });
        }
        Ok(WorkerTransition::None)
    }

    fn detect_rebasing_transition(
        &self,
        session_id: &str,
        worktree_path: &Path,
    ) -> Result<WorkerTransition> {
        let rebase_in_progress = git::is_rebase_in_progress(worktree_path);
        if rebase_in_progress {
            tracing::debug!("Worker {} still has rebase in progress", session_id);
            return Ok(WorkerTransition::None);
        }
        let output = session::capture_pane(session_id, 50)?;
        let rebase_completed = output.contains("Successfully rebased and updated");
        let rebase_aborted =
            output.contains("rebase --abort") && !output.contains("git rebase --abort");
        if rebase_completed {
            tracing::info!("Worker {} completed rebase successfully", session_id);
        } else if rebase_aborted {
            tracing::warn!("Worker {} aborted rebase", session_id);
        } else {
            tracing::info!(
                "Worker {} rebase finished (no completion message in pane, assuming success)",
                session_id
            );
        }
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!("Worker {} has uncommitted changes after rebase, amending", session_id);
            git::amend_uncommitted_changes(worktree_path)?;
        }
        let commit_sha = git::get_head_commit(worktree_path)?;
        Ok(WorkerTransition::ToNeedsReview { commit_sha })
    }

    fn rebase_pending_reviews(
        &self,
        state: &mut State,
        transitioned_workers: &std::collections::HashSet<String>,
        report: &mut PatrolReport,
    ) -> Result<()> {
        let workers_to_check: Vec<String> = state
            .workers
            .iter()
            .filter(|(_, w)| w.status == WorkerStatus::NeedsReview)
            .map(|(name, _)| name.clone())
            .collect();
        for worker_name in workers_to_check {
            if transitioned_workers.contains(&worker_name) {
                tracing::debug!(
                    "Skipping rebase check for worker '{}' - just transitioned in this patrol run",
                    worker_name
                );
                continue;
            }
            let worker = state.get_worker(&worker_name).unwrap();
            let worktree_path = PathBuf::from(&worker.worktree_path);
            let session_id = worker.session_id.clone();
            let rebase_in_progress = git::is_rebase_in_progress(&worktree_path);
            tracing::debug!(
                worker = % worker_name, rebase_in_progress,
                "Checking if rebase is in progress before triggering rebase"
            );
            if rebase_in_progress {
                tracing::debug!(
                    "Skipping rebase for worker '{}' - rebase already in progress",
                    worker_name
                );
                continue;
            }
            let has_commits_ahead = git::has_commits_ahead_of(&worktree_path, "origin/master")?;
            let worker_head = git::get_head_commit(&worktree_path)?;
            let origin_master_sha = git::get_head_commit_of_ref(&worktree_path, "origin/master")?;
            if !has_commits_ahead {
                let expected_sha = worker.commit_sha.as_deref().unwrap_or("<none>");
                tracing::info!(
                    worker = % worker_name, worker_head = % worker_head, origin_master =
                    % origin_master_sha, expected_commit_sha = % expected_sha,
                    heads_match = (worker_head == origin_master_sha),
                    "Worker is in needs_review but has no commits ahead of origin/master - work was already merged, resetting to idle"
                );
                let worker_mut = state.get_worker_mut(&worker_name).unwrap();
                worker::apply_transition(worker_mut, WorkerTransition::ToIdle)?;
                report.transitions_applied.push((worker_name.clone(), WorkerTransition::ToIdle));
                continue;
            }
            let merge_base = git::get_merge_base(&worktree_path, "HEAD", "origin/master")?;
            tracing::debug!(
                worker = % worker_name, worker_head = % worker_head, origin_master = %
                origin_master_sha, merge_base = % merge_base,
                "Checking if rebase is needed"
            );
            if merge_base == origin_master_sha {
                tracing::debug!("Worker '{}' is already rebased onto origin/master", worker_name);
                continue;
            }
            tracing::info!(
                worker = % worker_name, merge_base = % merge_base, origin_master = %
                origin_master_sha,
                "Master has advanced - rebasing worker in needs_review"
            );
            match self.trigger_rebase(&worker_name, &worktree_path, &session_id, state) {
                Ok(()) => {
                    report.rebases_triggered.push(worker_name.clone());
                }
                Err(e) => {
                    report.errors.push(format!("Failed to rebase worker '{}': {}", worker_name, e));
                }
            }
        }
        Ok(())
    }

    fn trigger_rebase(
        &self,
        worker_name: &str,
        worktree_path: &Path,
        session_id: &str,
        state: &mut State,
    ) -> Result<()> {
        let llmc_root = crate::config::get_llmc_root();
        git::fetch_origin(&llmc_root)?;
        if git::has_uncommitted_changes(worktree_path)? {
            tracing::info!(
                "Worker '{}' has uncommitted changes, amending to commit before rebase",
                worker_name
            );
            git::amend_uncommitted_changes(worktree_path)?;
        }
        let rebase_result = git::rebase_onto(worktree_path, "origin/master")?;
        if !rebase_result.success {
            let worker = state.get_worker_mut(worker_name).unwrap();
            worker::apply_transition(worker, WorkerTransition::ToRebasing)?;
            let conflict_prompt =
                build_conflict_prompt(&rebase_result.conflicts, &worker.current_prompt);
            let sender = TmuxSender::new();
            sender.send(session_id, &conflict_prompt)?;
        }
        Ok(())
    }
}
fn build_conflict_prompt(conflicts: &[String], original_task: &str) -> String {
    let mut prompt = String::from(
        "REBASE CONFLICT DETECTED\n\
         \n\
         Master has advanced and your changes need to be rebased. The rebase has encountered conflicts.\n\
         \n",
    );
    prompt
        .push_str(
            &format!(
                "IMPORTANT - Your original task:\n\
         \"{}\"\n\
         \n\
         DO NOT restart your task from scratch. Instead, INCORPORATE your existing changes/intent \n\
         into the new repository state. Your goal is to apply the same logical changes you already \n\
         made, but adapted to work with the new state of the files after master's changes.\n\
         \n",
                original_task.lines().take(3).collect::< Vec < _ >> ().join(" ")
            ),
        );
    prompt.push_str("Conflicting files:\n");
    for file in conflicts {
        let conflict_count = count_conflict_markers(file);
        prompt.push_str(&format!("- {} ({} conflict markers)\n", file, conflict_count));
    }
    prompt
        .push_str(
            "\n\
         IMPORTANT - Resolution steps (must complete ALL steps):\n\
         1. Read and understand the conflict markers in each file (<<<<<<, =======, >>>>>>>)\n\
         2. Understand what master changed (their version) and what you changed (our version)\n\
         3. Decide how to INCORPORATE YOUR CHANGES into the new state - do NOT just accept theirs\n\
         4. Edit files to remove ALL conflict markers and apply your intended changes\n\
         5. Stage ALL resolved files: git add <file>\n\
         6. Continue the rebase: git rebase --continue\n\
         7. Verify success: Look for \"Successfully rebased and updated\" message\n\
         8. Run validation: just review\n\
         9. IMPORTANT: If validation modified any files, amend them: git add -A && git commit --amend --no-edit\n\
         \n\
         Helpful commands:\n\
         - View our version: git show :2:<file>\n\
         - View their version: git show :3:<file>\n\
         - Check remaining conflicts: git diff --name-only --diff-filter=U\n\
         - If you need to start over: git rebase --abort\n\
         \n\
         CRITICAL: You MUST run 'git rebase --continue' after staging files.\n\
         Do NOT commit manually. The rebase process handles commits automatically.\n",
        );
    prompt
}
fn count_conflict_markers(file: &str) -> usize {
    std::fs::read_to_string(file).map(|content| content.matches("<<<<<<<").count()).unwrap_or(0)
}
fn get_self_review_config(config: &Config) -> Option<&SelfReviewConfig> {
    config.defaults.self_review.as_ref()
}
fn send_self_review_prompt(
    session_id: &str,
    self_review_config: &SelfReviewConfig,
    original_prompt: &str,
) -> Result<()> {
    let sender = TmuxSender::new();
    if self_review_config.clear {
        tracing::info!("Sending /clear before self-review prompt to session '{}'", session_id);
        sender.send(session_id, "/clear")?;
        std::thread::sleep(std::time::Duration::from_secs(2));
    }
    let mut prompt = self_review_config.prompt.clone();
    if self_review_config.include_original && !original_prompt.is_empty() {
        prompt.push_str("\n\n--- Original Prompt ---\n\n");
        prompt.push_str(original_prompt);
    }
    tracing::info!("Sending self-review prompt to session '{}'", session_id);
    sender.send(session_id, &prompt)?;
    Ok(())
}
#[cfg(test)]
mod tests {
    use crate::patrol::*;
    #[test]
    fn test_patrol_report_default() {
        let report = PatrolReport::default();
        assert_eq!(report.sessions_checked, 0);
        assert!(report.transitions_applied.is_empty());
        assert!(report.rebases_triggered.is_empty());
        assert!(report.errors.is_empty());
    }
    #[test]
    fn test_build_conflict_prompt() {
        let conflicts = vec!["src/main.rs".to_string(), "src/lib.rs".to_string()];
        let original_task = "Fix the authentication bug in the login system";
        let prompt = build_conflict_prompt(&conflicts, original_task);
        assert!(prompt.contains("REBASE CONFLICT DETECTED"));
        assert!(prompt.contains("src/main.rs"));
        assert!(prompt.contains("src/lib.rs"));
        assert!(prompt.contains("IMPORTANT - Resolution steps (must complete ALL steps):"));
        assert!(prompt.contains("Your original task:"));
        assert!(prompt.contains("Fix the authentication bug"));
        assert!(prompt.contains("git rebase --continue"));
        assert!(prompt.contains("Successfully rebased and updated"));
    }
}
