use core_data::numerics::{Energy, Points, Spark};
use serde::{Deserialize, Serialize};
use strum::{Display, EnumDiscriminants};

use crate::collection_expression::CollectionExpression;
use crate::cost::Cost;
use crate::predicate::{CardPredicate, Predicate};
use crate::quantity_expression_data::QuantityExpression;
use crate::triggered_ability::TriggeredAbility;

/// Effects are the primary way in which cards modify the game state. This can
/// be as part of the resolution of an event card, or via the effect text of a
/// triggered or activated ability on a character card.
#[derive(Debug, Clone, Serialize, Deserialize, EnumDiscriminants)]
#[strum_discriminants(derive(Display))]
pub enum StandardEffect {
    AbandonAndGainEnergyForSpark { target: Predicate, energy_per_spark: Energy },
    AbandonAtEndOfTurn { target: Predicate },
    BanishCardsFromEnemyVoid { count: u32 },
    BanishCharacter { target: Predicate },
    BanishCharacterUntilLeavesPlay { target: Predicate, until_leaves: Predicate },
    BanishCollection { target: Predicate, count: CollectionExpression },
    BanishEnemyVoid,
    BanishUntilNextMain { target: Predicate },
    BanishWhenLeavesPlay { target: Predicate },
    CardsInVoidGainReclaimThisTurn { count: CollectionExpression, predicate: CardPredicate },
    Copy { target: Predicate },
    CopyNextPlayed { matching: Predicate, times: Option<u32> },
    Counterspell { target: Predicate },
    CounterspellUnlessPaysCost { target: Predicate, cost: Cost },
    CreateTriggerUntilEndOfTurn { trigger: Box<TriggeredAbility> },
    DisableActivatedAbilitiesWhileInPlay { target: Predicate },
    DiscardCardFromEnemyHand { predicate: CardPredicate },
    DiscardCardFromEnemyHandThenTheyDraw { predicate: CardPredicate },
    DiscardCards { count: u32 },
    Discover { predicate: CardPredicate },
    DiscoverAndThenMaterialize { predicate: CardPredicate },
    DissolveCharacter { target: Predicate },
    DissolveCharactersCount { target: Predicate, count: CollectionExpression },
    DissolveCharactersQuantity { target: Predicate, quantity: QuantityExpression },
    DoubleYourEnergy,
    DrawCards { count: u32 },
    DrawCardsForEach { count: u32, for_each: QuantityExpression },
    DrawMatchingCard { predicate: CardPredicate },
    EachMatchingGainsSparkForEach { each: CardPredicate, gains: Spark, for_each: CardPredicate },
    EachMatchingGainsSparkUntilNextMain { each: CardPredicate, gains: Spark },
    EachPlayerAbandonsCharacters { matching: CardPredicate, count: u32 },
    EachPlayerDiscardCards { count: u32 },
    EnemyGainsPoints { count: u32 },
    EnemyGainsPointsEqualToItsSpark,
    EnemyLosesPoints { count: u32 },
    Foresee { count: u32 },
    GainControl { target: Predicate },
    GainEnergy { gains: Energy },
    GainEnergyForEach { gains: Energy, for_each: Predicate },
    GainPoints { gains: Points },
    GainPointsForEach { gain: Points, for_count: QuantityExpression },
    GainsAegisThisTurn { target: Predicate },
    GainsReclaimUntilEndOfTurn { target: Predicate, cost: Option<Energy> },
    GainsSpark { target: Predicate, gains: Spark },
    GainsSparkForQuantity { target: Predicate, gains: Spark, for_quantity: QuantityExpression },
    GainsSparkUntilYourNextMainForEach { target: Predicate, gains: Spark, for_each: Predicate },
    GainTwiceThatMuchEnergyInstead,
    Kindle { amount: Spark },
    LosePoints { loses: Points },
    MaterializeCharacter { target: Predicate },
    MaterializeCharacterAtEndOfTurn { target: Predicate },
    MaterializeCharacterFromVoid { target: CardPredicate },
    MaterializeRandomFromDeck { count: u32, predicate: CardPredicate },
    MaterializeSilentCopy { target: Predicate, count: u32, quantity: QuantityExpression },
    NoEffect,
    OpponentPaysCost { cost: Cost },
    PayCost { cost: Cost },
    PreventDissolveThisTurn { target: Predicate },
    PutCardsFromVoidOnTopOfDeck { count: u32, matching: CardPredicate },
    PutCardsFromYourDeckIntoVoid { count: u32 },
    PutOnTopOfEnemyDeck { target: Predicate },
    ReturnCharactersToHandDrawCardForEach { count: CollectionExpression },
    ReturnFromYourVoidToHand { target: Predicate },
    ReturnFromYourVoidToPlay { target: Predicate },
    ReturnToHand { target: Predicate },
    ReturnUpToCountFromYourVoidToHand { target: Predicate, count: u32 },
    ShuffleHandAndDeckAndDraw { count: u32 },
    SparkBecomes { collection: CollectionExpression, matching: CardPredicate, spark: Spark },
    SpendAllEnergyDissolveEnemy,
    SpendAllEnergyDrawAndDiscard,
    TakeExtraTurn,
    ThenMaterializeIt,
    TriggerJudgmentAbility { matching: Predicate, collection: CollectionExpression },
    YouWinTheGame,
}
