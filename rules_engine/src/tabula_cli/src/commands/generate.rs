use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use convert_case::{Case, Casing};
use tabula_data::toml_loader::{self, CardListsFile, TestCardsFile, TestDreamwellFile};

/// Generates code from TOML/FTL source files into the tabula_generated crate.
pub fn generate(output_dir: Option<PathBuf>) -> Result<()> {
    let output = output_dir.unwrap_or_else(default_output_dir);
    fs::create_dir_all(&output)?;
    let tabula_dir = tabula_source_dir();
    generate_test_card(&tabula_dir, &output)?;
    generate_string_ids(&tabula_dir, &output)?;
    generate_card_lists(&tabula_dir, &output)?;
    println!("Code generation complete. Output: {}", output.display());
    Ok(())
}

/// Returns the default output directory for generated code.
fn default_output_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("parent dir")
        .join("tabula_generated/src")
}

/// Returns the path to the Tabula source files.
fn tabula_source_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("parent dir")
        .parent()
        .expect("grandparent dir")
        .parent()
        .expect("great-grandparent dir")
        .join("client/Assets/StreamingAssets/Tabula")
}

/// Generates test_card.rs from test-cards.toml and test-dreamwell.toml.
fn generate_test_card(tabula_dir: &Path, output_dir: &Path) -> Result<()> {
    let test_cards_path = tabula_dir.join("test-cards.toml");
    let test_dreamwell_path = tabula_dir.join("test-dreamwell.toml");
    let test_cards: TestCardsFile = toml_loader::load_toml(&test_cards_path)
        .map_err(|e| anyhow::anyhow!("Failed to load test-cards.toml: {e:?}"))?;
    let test_dreamwell: TestDreamwellFile = toml_loader::load_toml(&test_dreamwell_path)
        .map_err(|e| anyhow::anyhow!("Failed to load test-dreamwell.toml: {e:?}"))?;
    let mut out = String::new();
    out.push_str("//! This file is generated by `tabula generate`. Do not edit manually.\n\n");
    out.push_str("use core_data::identifiers::{BaseCardId, DreamwellCardId};\n");
    out.push_str("use uuid::uuid;\n");
    let mut seen_names: HashSet<String> = HashSet::new();
    let mut base_const_names: Vec<String> = Vec::new();
    for raw in &test_cards.test_cards {
        let Some(id) = raw.id else { continue };
        let Some(name) = &raw.name else { continue };
        let const_name = cleaned_to_case(name, Case::UpperSnake);
        if seen_names.contains(&const_name) {
            continue;
        }
        seen_names.insert(const_name.clone());
        base_const_names.push(const_name.clone());
        if let Some(rules_text) = &raw.rules_text {
            let trimmed = rules_text.trim();
            if !trimmed.is_empty() {
                out.push_str(&format!("/// {}\n", trimmed.replace('\n', " ")));
            }
        }
        out.push_str(&format!(
            "pub const {const_name}: BaseCardId = BaseCardId(uuid!(\"{id}\"));\n"
        ));
    }
    let mut dreamwell_const_names: Vec<String> = Vec::new();
    for raw in &test_dreamwell.test_dreamwell {
        let Some(id) = raw.id else { continue };
        let Some(name) = &raw.name else { continue };
        let const_name = cleaned_to_case(name, Case::UpperSnake);
        if seen_names.contains(&const_name) {
            continue;
        }
        seen_names.insert(const_name.clone());
        dreamwell_const_names.push(const_name.clone());
        if let Some(rules_text) = &raw.rules_text {
            let trimmed = rules_text.trim();
            if !trimmed.is_empty() {
                out.push_str(&format!("/// {}\n", trimmed.replace('\n', " ")));
            }
        }
        out.push_str(&format!(
            "pub const {const_name}: DreamwellCardId = DreamwellCardId(uuid!(\"{id}\"));\n"
        ));
    }
    if !base_const_names.is_empty() {
        out.push_str("\npub const ALL_TEST_CARD_IDS: &[BaseCardId] = &[\n");
        for name in &base_const_names {
            out.push_str(&format!("    {name},\n"));
        }
        out.push_str("];\n");
    }
    if !dreamwell_const_names.is_empty() {
        out.push_str("\npub const ALL_TEST_DREAMWELL_CARD_IDS: &[DreamwellCardId] = &[\n");
        for name in &dreamwell_const_names {
            out.push_str(&format!("    {name},\n"));
        }
        out.push_str("];\n");
    }
    let output_path = output_dir.join("test_card.rs");
    fs::write(&output_path, out).context("Failed to write test_card.rs")?;
    println!("Generated: {}", output_path.display());
    Ok(())
}

/// Generates string_id.rs from strings.ftl.
fn generate_string_ids(tabula_dir: &Path, output_dir: &Path) -> Result<()> {
    let strings_path = tabula_dir.join("strings.ftl");
    let contents = fs::read_to_string(&strings_path).context("Failed to read strings.ftl")?;
    let mut variant_to_message: HashMap<String, String> = HashMap::new();
    let mut insertion_order: Vec<String> = Vec::new();
    for line in contents.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        if line.starts_with('-') {
            continue;
        }
        if let Some((message_id, _)) = line.split_once('=') {
            let message_id = message_id.trim();
            if message_id.is_empty() || message_id.contains(' ') || message_id.contains('{') {
                continue;
            }
            let variant_name = cleaned_to_case(message_id, Case::Pascal);
            let is_lowercase = message_id.chars().next().is_some_and(char::is_lowercase);
            if let Some(existing) = variant_to_message.get(&variant_name) {
                let existing_is_lowercase = existing.chars().next().is_some_and(char::is_lowercase);
                if is_lowercase && !existing_is_lowercase {
                    variant_to_message.insert(variant_name, message_id.to_string());
                }
            } else {
                insertion_order.push(variant_name.clone());
                variant_to_message.insert(variant_name, message_id.to_string());
            }
        }
    }
    let mut out = String::new();
    out.push_str("//! This file is generated by `tabula generate`. Do not edit manually.\n\n");
    out.push_str("use schemars::JsonSchema;\n");
    out.push_str("use serde::{Deserialize, Serialize};\n");

    // Generate enum
    out.push_str("\n/// Identifies a localized string from the Fluent FTL files.\n");
    out.push_str(
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, JsonSchema)]\n",
    );
    out.push_str("pub enum StringId {\n");
    for variant_name in &insertion_order {
        out.push_str(&format!("    {variant_name},\n"));
    }
    out.push_str("}\n");

    // Generate as_str method
    out.push_str("\nimpl StringId {\n");
    out.push_str("    /// Returns the Fluent message identifier for this string.\n");
    out.push_str("    pub fn as_str(self) -> &'static str {\n");
    out.push_str("        match self {\n");
    for variant_name in &insertion_order {
        let message_id = &variant_to_message[variant_name];
        out.push_str(&format!("            StringId::{variant_name} => \"{message_id}\",\n"));
    }
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    let output_path = output_dir.join("string_id.rs");
    fs::write(&output_path, out).context("Failed to write string_id.rs")?;
    println!("Generated: {}", output_path.display());
    Ok(())
}

/// Converts a string to the specified case, replacing non-alphanumeric
/// characters with spaces first.
fn cleaned_to_case(input: &str, case: Case) -> String {
    input
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { ' ' })
        .collect::<String>()
        .to_case(case)
}

/// Generates card_lists.rs from card-lists.toml.
fn generate_card_lists(tabula_dir: &Path, output_dir: &Path) -> Result<()> {
    let card_lists_path = tabula_dir.join("card-lists.toml");
    let card_lists: CardListsFile = toml_loader::load_toml(&card_lists_path)
        .map_err(|e| anyhow::anyhow!("Failed to load card-lists.toml: {e:?}"))?;

    // Group cards by type, then by list name
    // lists_by_type: { "BaseCardId" -> { "Core 11" -> [ids...] } }
    let mut lists_by_type: HashMap<String, HashMap<String, Vec<String>>> = HashMap::new();
    // Track insertion order per type
    let mut list_order_by_type: HashMap<String, Vec<String>> = HashMap::new();
    // Track type insertion order
    let mut type_order: Vec<String> = Vec::new();

    for row in &card_lists.card_lists {
        let list_type = row.list_type.clone();
        let list_name = row.list_name.clone();
        if !lists_by_type.contains_key(&list_type) {
            type_order.push(list_type.clone());
            lists_by_type.insert(list_type.clone(), HashMap::new());
            list_order_by_type.insert(list_type.clone(), Vec::new());
        }
        let lists = lists_by_type.get_mut(&list_type).expect("type exists");
        let order = list_order_by_type.get_mut(&list_type).expect("type exists");
        if !lists.contains_key(&list_name) {
            order.push(list_name.clone());
        }
        let entry = lists.entry(list_name).or_default();
        for _ in 0..row.copies {
            entry.push(row.card_id.clone());
        }
    }

    let mut out = String::new();
    out.push_str("//! This file is generated by `tabula generate`. Do not edit manually.\n\n");

    // Generate imports based on types found
    let type_names: Vec<&str> = type_order.iter().map(|s| s.as_str()).collect();
    if !type_names.is_empty() {
        out.push_str(&format!("use core_data::identifiers::{{{}}};\n", type_names.join(", ")));
    }
    out.push_str("use schemars::JsonSchema;\n");
    out.push_str("use serde::{Deserialize, Serialize};\n");
    out.push_str("use uuid::uuid;\n");

    // For each type, generate const arrays, enum, and function
    for list_type in &type_order {
        let lists = &lists_by_type[list_type];
        let order = &list_order_by_type[list_type];
        let mut const_names: Vec<String> = Vec::new();

        // Generate const arrays
        for list_name in order {
            let const_name = cleaned_to_case(list_name, Case::UpperSnake);
            const_names.push(const_name.clone());
            let ids = &lists[list_name];
            out.push_str(&format!("\npub const {const_name}: &[{list_type}] = &[\n"));
            for id in ids {
                out.push_str(&format!("    {list_type}(uuid!(\"{id}\")),\n"));
            }
            out.push_str("];\n");
        }

        // Generate enum
        let enum_name = format!("{list_type}List");
        let type_snake = cleaned_to_case(list_type, Case::Snake);
        out.push_str(&format!("\n/// Identifies a predefined list of {type_snake} cards.\n"));
        out.push_str("#[derive(Clone, Debug, Serialize, Deserialize, JsonSchema)]\n");
        out.push_str(&format!("pub enum {enum_name} {{\n"));
        for const_name in &const_names {
            let variant_name = cleaned_to_case(const_name, Case::Pascal);
            out.push_str(&format!("    {variant_name},\n"));
        }
        out.push_str("}\n");

        // Generate function
        let fn_name = format!("{type_snake}_list");
        out.push_str(&format!("\n/// Returns the card IDs for the given {type_snake} list.\n"));
        out.push_str(&format!(
            "pub fn {fn_name}(list: {enum_name}) -> &'static [{list_type}] {{\n"
        ));
        out.push_str("    match list {\n");
        for const_name in &const_names {
            let variant_name = cleaned_to_case(const_name, Case::Pascal);
            out.push_str(&format!("        {enum_name}::{variant_name} => {const_name},\n"));
        }
        out.push_str("    }\n");
        out.push_str("}\n");
    }

    let output_path = output_dir.join("card_lists.rs");
    fs::write(&output_path, out).context("Failed to write card_lists.rs")?;
    println!("Generated: {}", output_path.display());
    Ok(())
}
