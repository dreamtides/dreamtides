use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use convert_case::{Case, Casing};
use tabula_data_v2::toml_loader::{self, TestCardsFile, TestDreamwellFile};

/// Generates code from TOML/FTL source files into the tabula_generated crate.
pub fn generate(output_dir: Option<PathBuf>) -> Result<()> {
    let output = output_dir.unwrap_or_else(default_output_dir);
    fs::create_dir_all(&output)?;
    let tabula_dir = tabula_source_dir();
    generate_test_cards(&tabula_dir, &output)?;
    generate_string_ids(&tabula_dir, &output)?;
    println!("Code generation complete. Output: {}", output.display());
    Ok(())
}

/// Returns the default output directory for generated code.
fn default_output_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("parent dir")
        .join("tabula_generated/src")
}

/// Returns the path to the Tabula source files.
fn tabula_source_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("parent dir")
        .parent()
        .expect("grandparent dir")
        .parent()
        .expect("great-grandparent dir")
        .join("client/Assets/StreamingAssets/Tabula")
}

/// Generates test_cards.rs from test-cards.toml and test-dreamwell.toml.
fn generate_test_cards(tabula_dir: &Path, output_dir: &Path) -> Result<()> {
    let test_cards_path = tabula_dir.join("test-cards.toml");
    let test_dreamwell_path = tabula_dir.join("test-dreamwell.toml");
    let test_cards: TestCardsFile = toml_loader::load_toml(&test_cards_path)
        .map_err(|e| anyhow::anyhow!("Failed to load test-cards.toml: {e:?}"))?;
    let test_dreamwell: TestDreamwellFile = toml_loader::load_toml(&test_dreamwell_path)
        .map_err(|e| anyhow::anyhow!("Failed to load test-dreamwell.toml: {e:?}"))?;
    let mut out = String::new();
    out.push_str("// This file is generated by `tabula generate`. Do not edit manually.\n\n");
    out.push_str("use core_data::identifiers::{BaseCardId, DreamwellCardId};\n");
    out.push_str("use uuid::uuid;\n\n");
    let mut seen_names: HashSet<String> = HashSet::new();
    let mut base_const_names: Vec<String> = Vec::new();
    for raw in &test_cards.test_cards {
        let Some(id) = raw.id else { continue };
        let Some(name) = &raw.name else { continue };
        let const_name = cleaned_to_case(name, Case::UpperSnake);
        if seen_names.contains(&const_name) {
            continue;
        }
        seen_names.insert(const_name.clone());
        base_const_names.push(const_name.clone());
        if let Some(rules_text) = &raw.rules_text {
            let trimmed = rules_text.trim();
            if !trimmed.is_empty() {
                out.push_str(&format!("/// {}\n", trimmed.replace('\n', " ")));
            }
        }
        let const_decl =
            format!("pub const {const_name}: BaseCardId = BaseCardId(uuid!(\"{id}\"));");
        if const_decl.len() > 100 {
            out.push_str(&format!(
                "pub const {const_name}: BaseCardId =\n    BaseCardId(uuid!(\"{id}\"));\n\n"
            ));
        } else {
            out.push_str(&format!("{const_decl}\n\n"));
        }
    }
    let mut dreamwell_const_names: Vec<String> = Vec::new();
    for raw in &test_dreamwell.test_dreamwell {
        let Some(id) = raw.id else { continue };
        let Some(name) = &raw.name else { continue };
        let const_name = cleaned_to_case(name, Case::UpperSnake);
        if seen_names.contains(&const_name) {
            continue;
        }
        seen_names.insert(const_name.clone());
        dreamwell_const_names.push(const_name.clone());
        if let Some(rules_text) = &raw.rules_text {
            let trimmed = rules_text.trim();
            if !trimmed.is_empty() {
                out.push_str(&format!("/// {}\n", trimmed.replace('\n', " ")));
            }
        }
        let const_decl =
            format!("pub const {const_name}: DreamwellCardId = DreamwellCardId(uuid!(\"{id}\"));");
        if const_decl.len() > 100 {
            out.push_str(
                &format!(
                    "pub const {const_name}: DreamwellCardId =\n    DreamwellCardId(uuid!(\"{id}\"));\n\n"
                ),
            );
        } else {
            out.push_str(&format!("{const_decl}\n\n"));
        }
    }
    if !base_const_names.is_empty() {
        out.push_str("pub const ALL_TEST_CARD_IDS: &[BaseCardId] = &[\n");
        for name in &base_const_names {
            out.push_str(&format!("    {name},\n"));
        }
        out.push_str("];\n\n");
    }
    if !dreamwell_const_names.is_empty() {
        out.push_str("pub const ALL_TEST_DREAMWELL_CARD_IDS: &[DreamwellCardId] = &[\n");
        for name in &dreamwell_const_names {
            out.push_str(&format!("    {name},\n"));
        }
        out.push_str("];\n");
    }
    let output_path = output_dir.join("test_cards.rs");
    fs::write(&output_path, out).context("Failed to write test_cards.rs")?;
    println!("Generated: {}", output_path.display());
    Ok(())
}

/// Generates string_id.rs from strings.ftl.
fn generate_string_ids(tabula_dir: &Path, output_dir: &Path) -> Result<()> {
    let strings_path = tabula_dir.join("strings.ftl");
    let contents = fs::read_to_string(&strings_path).context("Failed to read strings.ftl")?;
    let mut const_to_message: HashMap<String, String> = HashMap::new();
    let mut insertion_order: Vec<String> = Vec::new();
    for line in contents.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        if line.starts_with('-') {
            continue;
        }
        if let Some((message_id, _)) = line.split_once('=') {
            let message_id = message_id.trim();
            if message_id.is_empty() || message_id.contains(' ') || message_id.contains('{') {
                continue;
            }
            let const_name = cleaned_to_case(message_id, Case::UpperSnake);
            let is_lowercase = message_id.chars().next().is_some_and(char::is_lowercase);
            if let Some(existing) = const_to_message.get(&const_name) {
                let existing_is_lowercase = existing.chars().next().is_some_and(char::is_lowercase);
                if is_lowercase && !existing_is_lowercase {
                    const_to_message.insert(const_name, message_id.to_string());
                }
            } else {
                insertion_order.push(const_name.clone());
                const_to_message.insert(const_name, message_id.to_string());
            }
        }
    }
    let mut out = String::new();
    out.push_str("// This file is generated by `tabula generate`. Do not edit manually.\n\n");
    for const_name in &insertion_order {
        let message_id = &const_to_message[const_name];
        out.push_str(&format!("pub const {const_name}: StringId = StringId(\"{message_id}\");\n"));
    }
    out.push_str("\n/// Identifies a localized string from the Fluent FTL files.\n");
    out.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    out.push_str("pub struct StringId(pub &'static str);\n");
    let output_path = output_dir.join("string_id.rs");
    fs::write(&output_path, out).context("Failed to write string_id.rs")?;
    println!("Generated: {}", output_path.display());
    Ok(())
}

/// Converts a string to the specified case, replacing non-alphanumeric
/// characters with spaces first.
fn cleaned_to_case(input: &str, case: Case) -> String {
    input
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { ' ' })
        .collect::<String>()
        .to_case(case)
}
