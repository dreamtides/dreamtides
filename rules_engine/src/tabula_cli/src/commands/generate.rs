use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use convert_case::{Case, Casing};
use parser::ability_directory_parser;
use tabula_data::toml_loader::{self, CardListsFile, TestCardsFile, TestDreamwellFile};

/// Generates code from TOML source files into the tabula_generated crate.
pub fn generate(output_dir: Option<PathBuf>) -> Result<()> {
    let output = output_dir.unwrap_or_else(default_output_dir);
    fs::create_dir_all(&output)?;
    let tabula_dir = tabula_source_dir();

    let test_card_content = generate_test_card_string(&tabula_dir)?;
    let output_path = output.join("test_card.rs");
    fs::write(&output_path, test_card_content).context("Failed to write test_card.rs")?;
    println!("Generated: {}", output_path.display());

    let card_lists_content = generate_card_lists_string(&tabula_dir)?;
    let output_path = output.join("card_lists.rs");
    fs::write(&output_path, card_lists_content).context("Failed to write card_lists.rs")?;
    println!("Generated: {}", output_path.display());

    let parsed_abilities_content = generate_parsed_abilities_string(&tabula_dir)?;
    let output_path = tabula_dir.join("parsed_abilities.json");
    fs::write(&output_path, parsed_abilities_content)
        .context("Failed to write parsed_abilities.json")?;
    println!("Generated: {}", output_path.display());

    println!("Code generation complete. Output: {}", output.display());
    Ok(())
}

/// Returns the default output directory for generated code.
pub fn default_output_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("parent dir")
        .join("tabula_generated/src")
}

/// Returns the path to the Tabula source files.
pub fn tabula_source_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("parent dir")
        .parent()
        .expect("grandparent dir")
        .parent()
        .expect("great-grandparent dir")
        .join("client/Assets/StreamingAssets/Tabula")
}

/// Generates test_card.rs content from test-cards.toml and test-dreamwell.toml.
pub fn generate_test_card_string(tabula_dir: &Path) -> Result<String> {
    let test_cards_path = tabula_dir.join("test-cards.toml");
    let test_dreamwell_path = tabula_dir.join("test-dreamwell.toml");
    let test_cards: TestCardsFile = toml_loader::load_toml(&test_cards_path)
        .map_err(|e| anyhow::anyhow!("Failed to load test-cards.toml: {e:?}"))?;
    let test_dreamwell: TestDreamwellFile = toml_loader::load_toml(&test_dreamwell_path)
        .map_err(|e| anyhow::anyhow!("Failed to load test-dreamwell.toml: {e:?}"))?;
    let mut out = String::new();
    out.push_str("//! This file is generated by `tabula generate`. Do not edit manually.\n\n");
    out.push_str("use core_data::identifiers::{BaseCardId, DreamwellCardId};\n");
    out.push_str("use uuid::uuid;\n\n");
    let mut seen_names: HashSet<String> = HashSet::new();
    let mut base_const_names: Vec<String> = Vec::new();
    for raw in &test_cards.test_cards {
        let Some(id) = raw.id else { continue };
        let Some(name) = &raw.name else { continue };
        let const_name = cleaned_to_case(name, Case::UpperSnake);
        if seen_names.contains(&const_name) {
            continue;
        }
        seen_names.insert(const_name.clone());
        base_const_names.push(const_name.clone());
        if let Some(rules_text) = &raw.rules_text {
            let trimmed = rules_text.trim();
            if !trimmed.is_empty() {
                out.push_str(&format!("/// {}\n", trimmed.replace('\n', " ")));
            }
        }
        out.push_str(&format!(
            "pub const {const_name}: BaseCardId = BaseCardId(uuid!(\"{id}\"));\n"
        ));
    }
    let mut dreamwell_const_names: Vec<String> = Vec::new();
    for raw in &test_dreamwell.test_dreamwell {
        let Some(id) = raw.id else { continue };
        let Some(name) = &raw.name else { continue };
        let const_name = cleaned_to_case(name, Case::UpperSnake);
        if seen_names.contains(&const_name) {
            continue;
        }
        seen_names.insert(const_name.clone());
        dreamwell_const_names.push(const_name.clone());
        if let Some(rules_text) = &raw.rules_text {
            let trimmed = rules_text.trim();
            if !trimmed.is_empty() {
                out.push_str(&format!("/// {}\n", trimmed.replace('\n', " ")));
            }
        }
        out.push_str(&format!(
            "pub const {const_name}: DreamwellCardId = DreamwellCardId(uuid!(\"{id}\"));\n"
        ));
    }
    if !base_const_names.is_empty() {
        out.push_str("\npub const ALL_TEST_CARD_IDS: &[BaseCardId] = &[\n");
        for name in &base_const_names {
            out.push_str(&format!("    {name},\n"));
        }
        out.push_str("];\n");
    }
    if !dreamwell_const_names.is_empty() {
        out.push_str("\npub const ALL_TEST_DREAMWELL_CARD_IDS: &[DreamwellCardId] = &[\n");
        for name in &dreamwell_const_names {
            out.push_str(&format!("    {name},\n"));
        }
        out.push_str("];\n");
    }
    Ok(out)
}

/// Generates card_lists.rs content from card-lists.toml.
pub fn generate_card_lists_string(tabula_dir: &Path) -> Result<String> {
    let card_lists_path = tabula_dir.join("card-lists.toml");
    let card_lists: CardListsFile = toml_loader::load_toml(&card_lists_path)
        .map_err(|e| anyhow::anyhow!("Failed to load card-lists.toml: {e:?}"))?;

    // Group cards by type, then by list name
    // lists_by_type: { "BaseCardId" -> { "Core 11" -> [ids...] } }
    let mut lists_by_type: HashMap<String, HashMap<String, Vec<String>>> = HashMap::new();
    // Track insertion order per type
    let mut list_order_by_type: HashMap<String, Vec<String>> = HashMap::new();
    // Track type insertion order
    let mut type_order: Vec<String> = Vec::new();

    for row in &card_lists.card_lists {
        let list_type = row.list_type.clone();
        let list_name = row.list_name.clone();
        if !lists_by_type.contains_key(&list_type) {
            type_order.push(list_type.clone());
            lists_by_type.insert(list_type.clone(), HashMap::new());
            list_order_by_type.insert(list_type.clone(), Vec::new());
        }
        let lists = lists_by_type.get_mut(&list_type).expect("type exists");
        let order = list_order_by_type.get_mut(&list_type).expect("type exists");
        if !lists.contains_key(&list_name) {
            order.push(list_name.clone());
        }
        let entry = lists.entry(list_name).or_default();
        for _ in 0..row.copies {
            entry.push(row.card_id.clone());
        }
    }

    let mut out = String::new();
    out.push_str("//! This file is generated by `tabula generate`. Do not edit manually.\n\n");

    // Generate imports based on types found
    let type_names: Vec<&str> = type_order.iter().map(String::as_str).collect();
    if !type_names.is_empty() {
        out.push_str(&format!("use core_data::identifiers::{{{}}};\n", type_names.join(", ")));
    }
    out.push_str("use schemars::JsonSchema;\n");
    out.push_str("use serde::{Deserialize, Serialize};\n");
    out.push_str("use uuid::uuid;\n");

    // Build const names for each type
    let mut const_names_by_type: HashMap<String, Vec<String>> = HashMap::new();
    for list_type in &type_order {
        let order = &list_order_by_type[list_type];
        let const_names: Vec<String> =
            order.iter().map(|list_name| cleaned_to_case(list_name, Case::UpperSnake)).collect();
        const_names_by_type.insert(list_type.clone(), const_names);
    }

    // First pass: generate all const arrays
    for list_type in &type_order {
        let lists = &lists_by_type[list_type];
        let order = &list_order_by_type[list_type];
        for list_name in order {
            let const_name = cleaned_to_case(list_name, Case::UpperSnake);
            let ids = &lists[list_name];
            out.push_str(&format!("\npub const {const_name}: &[{list_type}] = &[\n"));
            for id in ids {
                out.push_str(&format!("    {list_type}(uuid!(\"{id}\")),\n"));
            }
            out.push_str("];\n");
        }
    }

    // Second pass: generate all enums
    for list_type in &type_order {
        let const_names = &const_names_by_type[list_type];
        let enum_name = format!("{list_type}List");
        let type_snake = cleaned_to_case(list_type, Case::Snake);
        out.push_str(&format!("\n/// Identifies a predefined list of {type_snake} cards.\n"));
        out.push_str("#[derive(Clone, Debug, Serialize, Deserialize, JsonSchema)]\n");
        out.push_str(&format!("pub enum {enum_name} {{\n"));
        for const_name in const_names {
            let variant_name = cleaned_to_case(const_name, Case::Pascal);
            out.push_str(&format!("    {variant_name},\n"));
        }
        out.push_str("}\n");
    }

    // Third pass: generate all functions
    for list_type in &type_order {
        let const_names = &const_names_by_type[list_type];
        let enum_name = format!("{list_type}List");
        let type_snake = cleaned_to_case(list_type, Case::Snake);
        let fn_name = format!("{type_snake}_list");
        out.push_str(&format!("\n/// Returns the card IDs for the given {type_snake} list.\n"));
        out.push_str(&format!(
            "pub fn {fn_name}(list: {enum_name}) -> &'static [{list_type}] {{\n"
        ));
        out.push_str("    match list {\n");
        for const_name in const_names {
            let variant_name = cleaned_to_case(const_name, Case::Pascal);
            out.push_str(&format!("        {enum_name}::{variant_name} => {const_name},\n"));
        }
        out.push_str("    }\n");
        out.push_str("}\n");
    }

    Ok(out)
}

/// Generates parsed_abilities.json content by parsing all card abilities.
pub fn generate_parsed_abilities_string(tabula_dir: &Path) -> Result<String> {
    let abilities = ability_directory_parser::parse_abilities_from_directory(tabula_dir)
        .map_err(|e| anyhow::anyhow!("Failed to parse abilities: {e}"))?;
    serde_json::to_string_pretty(&abilities).context("Failed to serialize abilities to JSON")
}

/// Converts a string to the specified case, replacing non-alphanumeric
/// characters with spaces first.
fn cleaned_to_case(input: &str, case: Case) -> String {
    input
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { ' ' })
        .collect::<String>()
        .to_case(case)
}
