// Russian locale stub — generated from bracket.rlf by stripping outer brackets.
// All phrase bodies currently contain English text as placeholders for translation.

energy_symbol = "<color=#00838F>●</color>";
points_symbol = "<color=#F57F17>⍏</color>";
fast_symbol = "↯";


energy($e) = "<color=#00838F>{$e}●</color>";
points($p) = "<color=#F57F17>{$p}⍏</color>";
maximum_energy($max) = "максимум {energy_symbol}";


trigger($t) = "▸ <b>{$t}:</b>";
materialized = "▸ <b>Воплощён:</b>";
judgment = "▸ <b>Суд:</b>";
dissolved = "▸ <b>Рассеян:</b>";
materialized_judgment = "▸ <b>Воплощён, Суд:</b>";
materialized_dissolved = "▸ <b>Воплощён, Рассеян:</b>";
judgment_phase_name = "<b>Суд</b>";
judgment_keyword_name = "Суд";
materialized_keyword_name = "Воплощён";
dissolved_keyword_name = "Рассеян";


keyword($k) = "<color=#AA00FF>{$k}</color>";
dissolve = "<color=#AA00FF>dissolve</color>";
banish = "<color=#AA00FF>banish</color>";
banished = "<color=#AA00FF>banished</color>";
discover = "<color=#AA00FF>Откройте</color>";
discovered = "<color=#AA00FF>discovered</color>";
reclaim = "<color=#AA00FF>возвысьте</color>";
reclaimed = "<color=#AA00FF>reclaimed</color>";
materialize = "<color=#AA00FF>воплотите</color>";
prevent = "<color=#AA00FF>prevent</color>";
prevented = "<color=#AA00FF>prevented</color>";
kindle($k) = "Разожгите {$k}";
kindled = "<color=#AA00FF>kindled</color>";
foresee($n) = "Прозрение {$n}";
fast = "↯Стремительность";
reclaim_for_cost($r) = "Возвышение {$r}●";


choose_one = "<b>Choose One:</b>";
bullet = "•";


card = :fem :inan { nom: "карта", *acc: "карту", gen: "карты", one: "карту", other: "карт" };
cards($n) = :match($n) {
    1: "карту",
    few: "{$n} карты",
    *other: "{$n} карт",
};
top_n_cards($n) = :match($n) {
    1: "верхнюю карту",
    few: "{$n} верхние карты",
    *other: "{$n} верхних карт",
};


spark_value($s) = "{$s}";
spark = "spark";
count($n) = "{$n}";


ally = :masc :anim { nom: "союзник", *acc: "союзника", gen: "союзника", one: "союзника", other: "союзников", inf: "союзника" };
count_allies($n) = :match($n) {
    1: "союзника",
    few: "{$n} союзников",
    *other: "{$n} союзников",
};
count_allied_subtype($n, $s) = :from($s) :match($n) {
    1: "союзного {subtype($s)}",
    *other: "{$n} союзных {subtype($s):other}",
};


celestial = :a{ one: "Celestial", other: "Celestial" };
halcyon = :a{ one: "Halcyon", other: "Halcyon" };
radiant = :a{ one: "Radiant", other: "Radiant" };
shadow = :a{ one: "Shadow", other: "Shadow" };


figment($f) = :from($f) {
    *one: "<color=#F57F17><b><u>{$f} Figment</u></color></b>",
    other: "<color=#F57F17><b><u>{$f} Figments</u></color></b>",
};
n_figments($n, $f) = :match($n) {
    1: "a {figment($f)}",
    *other: "{text_number($n)} {figment($f):other}",
};


agent = :an{ one: "Agent", other: "Agents" };
ancient = :an{ one: "Ancient", other: "Ancients" };
avatar = :an{ one: "Avatar", other: "Avatars" };
child = :a{ one: "Child", other: "Children" };
detective = :a{ one: "Detective", other: "Detectives" };
enigma = :an{ one: "Enigma", other: "Enigmas" };
explorer = :an{ one: "Explorer", other: "Explorers" };
guide = :a{ one: "Guide", other: "Guides" };
hacker = :a{ one: "Hacker", other: "Hackers" };
mage = :a{ one: "Mage", other: "Mages" };
monster = :a{ one: "Monster", other: "Monsters" };
musician = :a{ one: "Musician", other: "Musicians" };
outsider = :an{ one: "Outsider", other: "Outsiders" };
renegade = :a{ one: "Renegade", other: "Renegades" };
robot = :a{ one: "Robot", other: "Robots" };
spirit_animal = :masc :anim { nom: "Дух-Зверь", *acc: "Духа-Зверя", gen: "Духа-Зверя", nom_pl: "Духи-Звери", nom.few: "Духа-Зверя", gen.few: "Духов-Зверей", one: "Духа-Зверя", other: "Духов-Зверей" };
super_ = :a{ one: "Super", other: "Supers" };
survivor = :masc :anim { nom: "Выживший", *acc: "Выжившего", gen: "Выжившего", nom_pl: "Выжившие", nom.few: "Выживших", one: "Выжившего", other: "Выживших" };
synth = :a{ one: "Synth", other: "Synths" };
tinkerer = :a{ one: "Tinkerer", other: "Tinkerers" };
trooper = :a{ one: "Trooper", other: "Troopers" };
visionary = :a{ one: "Visionary", other: "Visionaries" };
visitor = :a{ one: "Visitor", other: "Visitors" };
warrior = :masc :anim { nom: "Воин", *acc: "Воина", gen: "Воина", nom_pl: "Воины", one: "Воина", other: "Воинов" };

subtype($s) = :from($s) {
    nom: "<color=#2E7D32><b>{$s:nom}</b></color>",
    *one: "<color=#2E7D32><b>{$s}</b></color>",
    nom_pl: "<color=#2E7D32><b>{$s:nom_pl}</b></color>",
    other: "<color=#2E7D32><b>{$s:other}</b></color>",
};


text_number($n) = :match($n) {
    1: "one",
    2: "two",
    3: "three",
    4: "four",
    5: "five",
    *other: "{$n}",
};


this_turn_times($n) = :match($n) {
    1: "this turn",
    2: "twice this turn",
    *other: "this turn {text_number($n)} times",
};

multiply_by($n) = :match($n) {
    2: "Double",
    3: "Triple",
    *other: "Multiply by {$n}",
};


copies($n) = :match($n) {
    1: "a copy",
    *other: "{text_number($n)} copies",
};


n_random_characters($n) = :match($n) {
    1: "a random character",
    *other: "{text_number($n)} random characters",
};


up_to_n_events($n) = :match($n) {
    1: "an event",
    *other: "up to {$n} events",
};


up_to_n_allies($n) = :match($n) {
    1: "{ally}",
    *other: "до {$n} {ally:other}",
};


pronoun = {
    nom.one: "он",
    nom.few: "они",
    nom.many: "они",
    nom: "он",
    acc.one: "его",
    acc.few: "их",
    acc.many: "их",
    acc: "его",
    gen.one: "его",
    gen.few: "их",
    gen.many: "их",
    gen: "его",
    one: "его",
    few: "их",
    many: "их",
    *other: "их"
};


bug_icon = "";
undo_icon = "ﶈ";
eye_icon = "粒";
eye_slash_icon = "笠";
asterisk_icon = "";


prompt_choose_character = "Choose a character";
prompt_select_stack_card = "Select a card";
prompt_select_from_void = "Select from your void";
prompt_select_from_hand = "Select from your hand";
prompt_select_option = "Select an option";
prompt_choose_energy_amount = "Choose energy amount";
prompt_select_card_order = "Select card position";
prompt_pick_mode = "Choose a mode";


dev_menu_button = "{bug_icon} Dev";
decline_prompt_button = "Decline";
pay_energy_prompt_button($e) = "Spend {energy($e)}";
pay_energy_additional_cost_button($e) = "Spend {energy($e)}";
primary_button_submit_void_card_targets = "Submit";
primary_button_submit_hand_card_targets = "Submit";
primary_button_submit_deck_card_order = "Submit";
primary_button_resolve_stack = "Resolve";
primary_button_end_turn = "End Turn";
primary_button_start_next_turn = "Next Turn";
increment_energy_prompt_button = "+1{energy_symbol}";
decrement_energy_prompt_button = "-1{energy_symbol}";
hide_stack_button = "{eye_icon}";
show_stack_button = "{eye_slash_icon}";
show_battlefield_button = "{eye_icon}";
hide_battlefield_button = "{eye_slash_icon}";


card_rules_text_energy_paid($e) = "({energy($e)} paid)";
card_rules_text_reclaimed = "(Reclaimed)";
card_rules_text_anchored = "(Anchored)";


modal_effect_choice_card_name($number) = "Choice {$number}";
character_ability_card_name($character_name) = "{$character_name} Ability";


hand_size_limit_exceeded_warning_message =
    "Note: Cards drawn in excess of 10 become {energy_symbol} instead.";
character_limit_exceeded_warning_message =
    "Character limit exceeded: A character will be abandoned, with its spark permanently added to your total.";
combined_limit_warning_message =
    "Character limit exceeded: A character will be abandoned. Cards drawn in excess of 10 become {energy_symbol} instead.";


error_message_panel_title = "Error";


card_type_character = "Character";
card_type_event = "Event";
card_type_dreamsign = "Dreamsign";
card_type_dreamcaller = "Dreamcaller";
card_type_dreamwell = "Dreamwell";


help_text_dissolve =
    "{@cap dissolve}: Send a character to the void";
help_text_prevent =
    "{@cap prevent}: Send a card to the void in response to it being played";
help_text_foresee_1 =
    "<color=#AA00FF>Foresee</color> 1: Look at the top card of your deck. You may put it into your void.";
help_text_foresee_n($n) =
    "<color=#AA00FF>Foresee</color> {$n}: Look at the top {$n} cards of your deck. You may put them into your void or put them back in any order.";
help_text_anchored =
    "<color=#AA00FF><b>Anchored</b></color>: Cannot be dissolved.";
help_text_reclaim_without_cost =
    "{@cap reclaim}: You may play a card from your void, then banish it when it leaves play.";
help_text_reclaim_with_cost($e) =
    "{@cap reclaim} {energy($e)}: You may play this card from your void for {energy($e)}, then banish it.";


token_type_activated_ability = "Activated Ability";
token_type_triggered_ability = "Triggered Ability";
token_type_reclaim_ability = "Reclaim Ability";


discard_your_hand_cost = "сбросьте руку";
pay_one_or_more_energy_cost = "заплатите не менее 1{energy_symbol}";
cost_or_connector = " или ";
cost_and_connector = " и ";
pay_prefix($cost) = "заплатить {$cost}";
abandon_any_number_of($target) = :from($target) "отрекитесь от любого количества {$target:other}";
abandon_target($target) = :from($target) "отрекитесь от {$target}";
return_target_to_hand($target) = :from($target) "return {$target} to hand";
return_count_to_hand($n, $target) = :from($target) "return {$n} {$target:other} to hand";
return_all_but_one_to_hand($target) = :from($target) "верните в руку всех {$target:other}, кроме одного";
return_all_to_hand($target) = :from($target) "return all {$target} to hand";
return_any_number_to_hand($target) = :from($target) "return any number of {$target} to hand";
return_up_to_to_hand($n, $target) = :from($target) "return up to {$n} {$target:other} to hand";
return_each_other_to_hand($target) = :from($target) "return each other {$target} to hand";
return_or_more_to_hand($n, $target) = :from($target) "return {$n} or more {$target:other} to hand";


abandon_count_allies($a) = "отрекитесь от {count_allies($a)}";
discard_cards_cost($d) = "сбросьте {cards($d)}";
energy_cost_value($e) = "{energy($e)}";
lose_max_energy_cost($m) = "уменьшите ваш {maximum_energy($m)} на {$m}";
banish_your_void_cost = "{banish} your void";
banish_another_in_void = "изгоните другую карту из вашей Пустоты";
banish_cards_from_void($c) = "{banish} {cards($c)} from your void";
banish_cards_from_enemy_void($c) = "изгоните {cards($c)} из Пустоты противника";
banish_void_min_count($n) = "{banish} your void with {count($n)} or more cards";
banish_from_hand_cost($target) = :from($target) "изгоните {$target} из руки";


at_end_of_your_turn_trigger = "at the end of your turn, ";
when_deck_empty_trigger = "when you have no cards in your deck, ";
when_you_gain_energy_trigger = "when you gain energy, ";
when_you_play_trigger($target) = :from($target) "когда вы играете {$target}, ";
when_opponent_plays_trigger($target) = :from($target) "when the opponent plays {$target}, ";
when_you_play_from_hand_trigger($target) = :from($target) "когда вы играете {$target} из руки, ";
when_you_play_in_turn_trigger($target) = :from($target) "when you play {$target} in a turn, ";
when_you_play_during_enemy_turn_trigger($target) = :from($target) "когда вы играете {$target} в ход противника, ";
when_you_discard_trigger($target) = :from($target) "когда вы сбрасываете {$target}, ";
when_leaves_play_trigger($target) = :from($target) "когда {$target:nom} покидает игру, ";
when_you_abandon_trigger($target) = :from($target) "когда вы отрекаетесь от {$target}, ";
when_put_into_void_trigger($target) = :from($target) "когда {$target:nom} попадает в вашу Пустоту, ";


when_you_materialize_trigger($target) = :from($target) "когда вы воплощаете {$target}, ";
when_dissolved_trigger($target) = :from($target) "когда {$target:nom} рассеивается, ";
when_banished_trigger($target) = :from($target) "когда {$target:nom} изгоняется, ";
when_you_play_cards_in_turn_trigger($c) = "когда вы играете {$c} {card:$c} за ход, ";
when_you_abandon_count_in_turn_trigger($a) = "когда вы отрекаетесь от {count_allies($a)} за ход, ";
when_you_draw_in_turn_trigger($c) = "когда вы берёте {$c} {card:$c} за ход, ";
when_you_materialize_nth_in_turn_trigger($n, $target) = :from($target) "when you {materialize} {text_number($n)} {$target:other} in a turn, ";


if_character_dissolved_this_turn = "if a character dissolved this turn";
if_card_in_your_void = "Если эта карта находится в вашей Пустоте,";
if_discarded_this_turn($target) = :from($target) "если вы сбрасывали {$target:acc} в этот ход";
with_predicate_condition($pred) = "with {$pred:other},";


with_allies_sharing_type($a) = "with {count_allies($a)} that share a character type,";
if_drawn_count_this_turn($n) = "if you have drawn {count($n)} or more cards this turn";
while_void_count($n) = "Пока в вашей Пустоте {count($n)} или больше карт,";
with_allied_subtype($t) = "with an allied {subtype($t)},";
with_count_allied_subtype($a, $t) = "Если у вас есть {count_allied_subtype($a, $t)},";
with_count_allies($a) = "{count_allies($a)}";


operator_or_less = " или меньше";
operator_or_more = " или больше";
operator_lower = " lower";
operator_higher = " higher";


draw_cards_effect($c) = "возьмите {cards($c)}";
discard_cards_effect($d) = "сбросьте {cards($d)}";
gain_energy_effect($e) = "получите {energy($e)}";
gain_points_effect($p) = "получите {points($p)}";
lose_points_effect($p) = "you lose {points($p)}";
opponent_gains_points_effect($p) = "противник получает {$p}⍏";
opponent_loses_points_effect($p) = "the opponent loses {points($p)}";
foresee_effect($f) = "{foresee($f)}";
kindle_effect($k) = "{kindle($k)}";
each_player_discards_effect($d) = "каждый игрок сбрасывает {cards($d)}";
prevent_that_card_effect = "{prevent} that card";
then_materialize_it_effect($target) = "затем воплотите его";
gain_twice_energy_instead_effect = "gain twice that much {energy_symbol} instead";
gain_energy_equal_to_that_cost_effect = "gain {energy_symbol} equal to that character's cost";
gain_energy_equal_to_this_cost_effect = "gain {energy_symbol} equal to this character's cost";
put_deck_into_void_effect($v) = "положите {top_n_cards($v)} вашей колоды в вашу Пустоту";
banish_cards_from_enemy_void_effect($c) = "{banish} {cards($c)} from the opponent's void";
banish_enemy_void_effect = "{banish} the opponent's void";
judgment_phase_at_end_of_turn_effect = "at the end of this turn, trigger an additional {judgment_phase_name} phase";
multiply_energy_effect($n) = "{multiply_by($n)} the amount of {energy_symbol} you have";
spend_all_energy_dissolve_effect = "spend all your {energy_symbol}. {dissolve} an enemy with cost less than or equal to the amount spent";
spend_all_energy_draw_discard_effect = "spend all your {energy_symbol}. Draw cards equal to the amount spent, then discard that many cards";
each_player_shuffles_and_draws_effect($c) = "each player shuffles their hand and void into their deck and then draws {cards($c)}";
return_up_to_events_from_void_effect($n) = "верните {up_to_n_events($n)} из вашей Пустоты в руку";
fast_prefix = "{fast} — ";


discard_chosen_from_enemy_hand($target) = :from($target) :match($target) {
    *anim: "сбросьте выбранного {$target} из руки противника",
    inan: "сбросьте выбранную {$target} из руки противника",
};
discard_chosen_from_enemy_hand_then_draw($target) = :from($target) :match($target) {
    *anim: "сбросьте выбранного {$target} из руки противника. Затем противник берёт {cards(1)}",
    inan: "сбросьте выбранную {$target} из руки противника. Затем противник берёт {cards(1)}",
};
put_from_void_on_top_of_deck($target) = :from($target) { *one: "положите {$target} из вашей Пустоты на верх вашей колоды", inf: "положить {$target} из вашей Пустоты на верх вашей колоды" };
put_up_to_from_void_on_top_of_deck($n, $target) = "put up to {cards($n)} {$target} from your void on top of your deck";
materialize_random_from_deck($n, $constraint) = "{materialize} {n_random_characters($n)} {$constraint} from your deck";
copy_next_played($target, $times) = "copy the next {$target} you play {this_turn_times($times)}";
create_trigger_until_end_of_turn_keyword($trig, $eff) = "До конца хода, {$trig} {@cap $eff}";
create_trigger_until_end_of_turn($trig, $eff) = "До конца хода, {$trig}{$eff}";
dissolve_target($target) = :from($target) "рассеяйте {$target}";
banish_target($target) = :from($target) "изгоните {$target}";
banish_until_leaves($target, $until) = "{banish} {$target} until {$until} leaves play";
banish_until_next_main($target) = "{banish} {$target} until your next main phase";
banish_when_leaves_play($target) = "{banish} {$target} when it leaves play";
gain_control_of($target) = "gain control of {$target}";
discover_target($target) = :from($target) { *one: "Откройте {$target}", inf: "открыть {$target}" };
discover_and_materialize($target) = :from($target) { *one: "Откройте {$target} и воплотите его", inf: "открыть {$target} и воплотить его" };
materialize_target($target) = "{materialize} {$target}";
materialize_at_end_of_turn($target) = :from($target) "воплотите {$target} в конце хода";
materialize_from_void($target) = "{materialize} {$target} from your void";
return_to_hand($target) = :from($target) { *one: "верните {$target} в руку", inf: "вернуть {$target} в руку" };
return_this_to_hand = { *one: "верните этого персонажа в руку", inf: "вернуть этого персонажа в руку" };
return_any_character_to_hand = { *one: "верните врага или союзника в руку", inf: "вернуть врага или союзника в руку" };
return_ally_to_hand = { *one: "верните союзника в руку", inf: "вернуть союзника в руку" };
return_from_void_to_hand($target) = :from($target) { *one: "верните {$target} из вашей Пустоты в руку", inf: "вернуть {$target} из вашей Пустоты в руку" };
reclaim_target($target) = :from($target) "{reclaim} {$target:acc}";
reclaim_random($target) = "{reclaim} a random {$target}";
put_on_top_of_enemy_deck($target) = :from($target) :match($target) {
    *fem: "положите её на верх колоды противника",
    masc: "положите его на верх колоды противника",
    neut: "положите его на верх колоды противника",
};
copy_target($target) = :from($target) "скопируйте {$target:acc}";
disable_activated_abilities($target) = "disable the activated abilities of {$target} while this character is in play";
draw_matching_from_deck($target) = "draw {$target} from your deck";
abandon_and_gain_energy_for_spark($target) = "abandon {$target} and gain {energy_symbol} for each point of spark that character had";
abandon_at_end_of_turn($target) = "abandon {$target} at end of turn";
each_player_abandons($target) = :from($target) "каждый игрок отрекается от {$target:gen}";
prevent_dissolve_this_turn($target) = "{$target} cannot be {dissolved} this turn";
prevent_played_target($target) = :from($target) "отмените розыгрыш {$target:gen}";
prevent_unless_pays($target, $cost) = :from($target) "отмените розыгрыш {$target:gen}, если только противник не заплатит {$cost}";
gain_energy_equal_to_cost($target) = "Получите {energy_symbol}, равное стоимости этого персонажа";
gains_spark($target, $s) = :from($target) "{$target:nom} получает +{$s} к искре";
opponent_pays_cost($cost) = "the opponent pays {$cost}";
pay_cost_effect($cost) = "pay {$cost}";


opponent_gains_points_equal_spark($target) = "the opponent gains points equal to its spark";
take_extra_turn_effect = "take an extra turn after this one";
you_win_the_game_effect = "you win the game";
no_effect = "";


you_may_prefix = "вы можете ";
cost_to_connector($cost) = "{$cost}, чтобы ";
until_end_of_turn_prefix = "До конца хода, ";
once_per_turn_prefix = "Один раз за ход, ";
once_per_turn_suffix = ", once per turn";
cost_effect_separator = ": ";
then_joiner = ", затем ";
and_joiner = " and ";
sentence_joiner = ". ";
sentence_separator = " ";
period_suffix = ".";


character = :masc :anim {
    nom: "персонаж",
    *acc: "персонажа",
    gen: "персонажа",
    nom_pl: "персонажи",
    one: "персонажа",
    other: "персонажей",
};
event = :neut :inan {
    nom.one: "событие",
    nom.few: "события",
    nom.many: "событий",
    nom: "событие",
    acc.one: "событие",
    acc.few: "события",
    acc.many: "событий",
    acc: "событие",
    gen.one: "события",
    gen.few: "событий",
    gen.many: "событий",
    gen: "события",
    nom_pl: "события",
    one: "событие",
    few: "события",
    many: "событий",
    other: "событий",
};
enemy = :masc :anim { nom: "враг", *acc: "врага", gen: "врага", one: "врага", other: "врагов" };

this_card = :a{ one: "this card", other: "these cards" };
this_character = :masc :anim { nom: "этот персонаж", *acc: "этого персонажа", gen: "этого персонажа", one: "этого персонажа", other: "этих персонажей" };
this_event = :an{ one: "this event", other: "these events" };
that_character = :a{ one: "that character", other: "those characters" };
pronoun_it = {
    nom.one: "он",
    nom.few: "они",
    nom.many: "они",
    nom: "он",
    acc.one: "его",
    acc.few: "их",
    acc.many: "их",
    acc: "его",
    gen.one: "его",
    gen.few: "их",
    gen.many: "их",
    gen: "его",
    *one: "его",
    few: "их",
    many: "их",
    other: "их"
};
pronoun_them = "их";
as_plural($p) = "{$p:other}";
with_plural($one, $other) = :from($one) { *one: "{$one}", other: "{$other}" };
your_generic_character = :masc :anim { nom: "союзник", *one: "персонажа", other: "союзников" };
your_generic_card = :fem :inan { *one: "карту", gen: "карты", other: "ваши карты" };
your_generic_event = :neut :inan { *one: "событие", other: "ваши события" };
your_generic_subtype($t) = :from($t) {
    *one: "{subtype($t)}",
    nom_pl: "союзные {subtype($t):nom_pl}",
    other: "союзных {subtype($t):other}",
};
predicate_with_indefinite_article($p) = :from($p);
another_pred($p) = :from($p) {
    *one: "another {$p}",
    other: "other {$p:other}",
};


your_card = :a{ one: "your card", other: "your cards" };
your_character = :a{ one: "your character", other: "your characters" };
your_event = :a{ one: "your event", other: "your events" };
enemy_card = :an{ one: "enemy card", other: "enemy cards" };
enemy_character = :an{ one: "enemy character", other: "enemy characters" };
enemy_event = :an{ one: "enemy event", other: "enemy events" };
allied_character = :an{ one: "allied character", other: "allied characters" };
allied_event = :an{ one: "allied event", other: "allied events" };
other_character = :an{ one: "other character", other: "other characters" };
allied_pred($base) = :from($base) {
    *one: "allied {$base}",
    other: "allied {$base:other}",
};
enemy_pred($base) = :from($base) {
    *one: "enemy {$base}",
    other: "enemy {$base:other}",
};
in_your_void($target) = :from($target) {
    *one: "{$target} в вашей Пустоте",
    other: "{$target:other} в вашей Пустоте",
};
in_opponent_void($target) = :from($target) {
    *one: "{$target} в Пустоте противника",
    other: "{$target:other} в Пустоте противника",
};
in_your_hand($target) = :from($target) "{$target} in your hand";

with_cost_constraint($op, $val) = "стоимостью {energy($val)}{$op}";
with_spark_constraint($op, $val) = "с искрой {$val}{$op}";
pred_with_constraint($base, $constraint) = :from($base) {
    *one: "{$base} {$constraint}",
    gen: "{$base:gen} {$constraint}",
    other: "{$base:other} {$constraint}",
};
non_subtype($s) = :from($s) {
    *one: "non-{$s}",
    other: "non-{$s:other}",
};
could_dissolve_target($target) = :from($target) {
    nom: "событие, которое может рассеять {$target}",
    *acc: "событие, которое может рассеять {$target}",
    gen: "события, которое может рассеять {$target}",
};
could_dissolve_target_plural($target) = "события, которые могут рассеять {$target}";
your_event_could_dissolve($target) = "ваше событие, которое может рассеять {$target}";
your_event_could_dissolve_plural($target) = "ваши события, которые могут рассеять {$target}";
fast_predicate($target) = :from($target) {
    nom: "{$target:nom} с ↯Стремительностью",
    *acc: "{$target:acc} с ↯Стремительностью",
    gen: "{$target:gen} с ↯Стремительностью",
};
fast_predicate_plural($target) = :from($target) "{$target} с ↯Стремительностью";
with_materialized_ability_constraint = "со способностью «▸ Воплощён:»";
with_materialized_abilities_constraint = "with {materialized} abilities";
with_activated_ability_constraint = "with an activated ability";
with_activated_abilities_constraint = "with activated abilities";
with_spark_less_than_energy_paid_constraint =
    "с искрой меньше числа уплаченных {energy_symbol}";
with_cost_less_than_allied_count($target) = :from($target)
    "стоимостью меньше количества союзных {$target:other}";
with_cost_less_than_abandoned_ally_constraint =
    "with cost less than the abandoned ally's cost";
with_spark_less_than_abandoned_ally_constraint =
    "with spark less than the abandoned ally's spark";
with_spark_less_than_abandoned_count_this_turn_constraint =
    "with spark less than the number of allies abandoned this turn";
with_cost_less_than_void_count_constraint =
    "стоимостью меньше количества карт в вашей Пустоте";
with_spark_less_than_that_ally_constraint =
    "with spark less than that ally's spark";


allied_subtype($t) = :from($t) { nom: "союзный {subtype($t):nom}", *acc: "союзного {subtype($t)}", gen: "союзного {subtype($t)}", nom_pl: "союзные {subtype($t):nom_pl}", other: "союзных {subtype($t):other}" };
allied_subtype_plural($t) = "союзных {subtype($t):other}";
enemy_subtype($t) = :an "enemy {subtype($t)}";
enemy_subtype_plural($t) = "enemy {subtype($t):other}";
your_subtype($t) = :from($t) "your {$t}";
other_subtype($t) = :from($t) "other {$t}";
subtype_in_your_void($t) = :from($t) "{$t} in your void";
character_not_subtype($s) = :a "character that is not {@a subtype($s)}";
character_not_subtype_plural($s) = "characters that are not {subtype($s):other}";
ally_not_subtype($s) = :an "ally that is not {@a subtype($s)}";
ally_not_subtype_plural($s) = "allies that are not {subtype($s):other}";
non_subtype_enemy($s) = :from($s) :match($s) {
    *masc: "врага, который не является {subtype($s):ins}",
    fem: "врага, который не является {subtype($s):ins}",
    neut: "врага, который не является {subtype($s):ins}",
};
non_subtype_enemy_plural($s) = :from($s) :match($s) {
    *masc: "врагов, которые не являются {subtype($s):ins}",
    fem: "врагов, которые не являются {subtype($s):ins}",
    neut: "врагов, которые не являются {subtype($s):ins}",
};


for_each_ally = :masc :anim { nom: "союзник", *gen: "союзника" };
for_each_allied_character = :masc :anim { nom: "союзный персонаж", *gen: "союзного персонажа" };
for_each_enemy = :masc :anim { nom: "враг", *gen: "врага" };
for_each_character = :masc :anim { nom: "персонаж", *gen: "персонажа" };
for_each_card = :fem :inan { nom: "карта", *gen: "карту" };
for_each_card_in_your_void = "card in your void";
for_each_this_character = "this character";
for_each_that_character = "that character";
for_each_other_character = "other character";
for_each_allied_event = "allied event";
for_each_event = "event";
for_each_character_in_your_void = "character in your void";
for_each_event_in_your_void = "event in your void";
for_each_card_in_enemy_void = "card in the opponent's void";
for_each_character_in_enemy_void = "character in the opponent's void";
for_each_event_in_enemy_void = "event in the opponent's void";
for_each_allied_subtype($t) = :from($t) { nom: "союзный {subtype($t):nom}", *gen: "союзного {subtype($t)}" };
for_each_enemy_subtype($t) = :from($t) "enemy {subtype($t)}";
for_each_subtype($t) = :from($t) "{subtype($t)}";
for_each_other_subtype($t) = :from($t) "other {subtype($t)}";
for_each_subtype_in_your_void($t) = :from($t) "{subtype($t)} in your void";
for_each_ally_with_spark($s, $op) = "ally with spark {$s}{$op}";
for_each_predicate($target) = :from($target) "each {$target}";


ally_abandoned_this_turn = :masc :anim { nom: "союзник, от которого вы отреклись в этот ход", *gen: "союзника, от которого вы отреклись в этот ход" };
allied_subtype_abandoned_this_turn($t) = :from($t) "allied {subtype($t)} abandoned this turn";
ally_abandoned = :masc :anim { gen: "союзника, от которого вы отреклись" };
allied_subtype_abandoned($t) = :from($t) "allied {subtype($t)} abandoned";
ally_returned = :masc :anim { gen: "возвращённого союзника" };
allied_subtype_returned($t) = :from($t) "allied {subtype($t)} returned";
card_predicate_returned($base) = :from($base) "{$base} returned";
energy_spent = :inan { gen: "потраченного {energy_symbol}" };
card_predicate_played_this_turn($base) = :from($base) { nom: "{$base:nom}, которую вы сыграли в этот ход", *gen: "{$base:gen}, которую вы сыграли в этот ход" };
card_predicate_drawn_this_turn($base) = :from($base) "{$base} you have drawn this turn";
card_predicate_discarded_this_turn($base) = :from($base) "{$base} you have discarded this turn";
card_predicate_dissolved_this_turn($base) = :from($base) "{$base} which dissolved this turn";
card_predicate_abandoned_this_turn($base) = :from($base) "{$base} abandoned this turn";
card_predicate_abandoned($base) = :from($base) "{$base} abandoned";


draw_cards_for_each($c, $target) = :from($target) :match($target) { *anim: "возьмите {cards($c)} за каждого {$target:gen}", inan: "возьмите {cards($c)} за каждую {$target:gen}" };
gain_energy_for_each($e, $target) = :from($target) :match($target) { *anim: "получите {energy($e)} за каждого {$target:gen}", inan: "получите {energy($e)} за каждую {$target:gen}" };
gain_points_for_each($p, $target) = :from($target) :match($target) { *anim: "получите {points($p)} за каждого {$target:gen}", inan: "получите {points($p)} за каждую {$target:gen}" };
gains_spark_for_each($target, $s, $quantity) = :from($target) "{$target:nom} получает +{$s} к искре за каждого {$quantity}";
gains_spark_until_next_main_for_each($target, $s, $for_each) = "{$target} gains +{$s} spark until your next main phase for each {$for_each}";
each_gains_spark_equal_to($each, $count_of) = :from($each) "каждый {$each:nom} получает искру, равную количеству {$count_of:other}";
have_each_gain_spark($each, $s) = "have each {$each} gain +{$s} spark";
spark_of_each_becomes($each, $s) = :from($each) "Искра каждого {$each:gen} становится равной {$s}";
dissolve_all_with_cost_lte_quantity($target, $quantity) = "{dissolve} all {$target:other} with cost less than or equal to the number of {$quantity}";


collection_all($target) = :from($target) :match($target) {
    anim: "всех {$target:other}",
    *inan: "все {$target:other}",
};
collection_exactly($n, $target) = "{$n} {$target:other}";
collection_up_to($n, $target) = :from($target) "до {$n} {$target:other}";
collection_any_number_of($target) = :from($target) "любое количество {$target:other}";

dissolve_collection($target) = :from($target) "рассеяйте {$target}";
banish_collection_target($target) = "{banish} {$target}";

materialize_them($target) = "воплотите их";
materialize_collection_target($target) = "{materialize} {$target}";

materialize_copy_of($target) = :from($target) "{materialize} копию {$target}";
materialize_n_copies_of($n, $target) = "{materialize} {$n} copies of {$target}";
materialize_copies_equal_to_matching($target, $matching) = "{materialize} a number of copies of {$target} equal to the number of {$matching:other}";
materialize_copies_equal_to_energy($target) = "{materialize} a number of copies of {$target} equal to the amount of {energy_symbol} spent";
materialize_copies_equal_to_quantity($target, $quantity) = "{materialize} a number of copies of {$target} equal to the number of {$quantity}";

trigger_judgment_of_collection($target) = "trigger the {Judgment} ability of {$target}";
trigger_judgment_of_each($target) = :from($target) "срабатывает способность «{judgment}» каждого {$target:gen}";


materialize_figments_for_each_quantity($fig, $quantity) = "{materialize} {$fig} for each {$quantity}";


banish_then_materialize_it($target) = :from($target) { *one: "изгоните {$target}, затем воплотите его", inf: "изгнать {$target}, затем воплотить его" };
banish_then_materialize_any_number($target) = :from($target) { *one: "изгоните любое количество {$target:other}, затем воплотите их", inf: "изгнать любое количество {$target:other}, затем воплотить их" };
banish_then_materialize_up_to($n, $target) = :from($target) { *one: "изгоните до {$n} {$target:other}, затем воплотите {pronoun:$n}", inf: "изгнать до {$n} {$target:other}, затем воплотить {pronoun:$n}" };
banish_then_materialize_them($target) = :from($target) { *one: "изгоните {$target}, затем воплотите их", inf: "изгнать {$target}, затем воплотить их" };


allied_card_with_subtype($t) = :from($t) {
    nom: "союзный {subtype($t):nom}",
    *one: "союзного {subtype($t)}",
    nom_pl: "союзные {subtype($t):nom_pl}",
    other: "союзных {subtype($t):other}",
};
allied_card_with_base($base) = :from($base) {
    *one: "allied {$base}",
    other: "allied {$base:other}",
};


it_gains_reclaim_for_cost($target, $r) = "it gains {reclaim_for_cost($r)}";
it_gains_reclaim_equal_cost($target) = "it gains {reclaim} equal to its cost";
this_card_gains_reclaim_for_cost($r) = "this card gains {reclaim_for_cost($r)}";
this_card_gains_reclaim_equal_cost = "this card gains {reclaim} equal to its cost";
target_gains_reclaim_for_cost($target, $r) = "{$target} gains {reclaim_for_cost($r)}";
target_gains_reclaim_equal_cost($target) = "{$target} gains {reclaim} equal to its cost";

it_gains_reclaim_for_cost_this_turn($target, $r) = :from($target) :match($target) {
    *fem: "она получает {reclaim_for_cost($r)} до конца хода",
    neut: "оно получает {reclaim_for_cost($r)} до конца хода",
    masc: "он получает {reclaim_for_cost($r)} до конца хода",
};
it_gains_reclaim_equal_cost_this_turn($target) = :from($target) :match($target) {
    *fem: "она получает Возвышение, равное её стоимости, до конца хода",
    neut: "оно получает Возвышение, равное его стоимости, до конца хода",
    masc: "он получает Возвышение, равное его стоимости, до конца хода",
};
this_card_gains_reclaim_for_cost_this_turn($r) = "эта карта получает {reclaim_for_cost($r)} до конца хода";
this_card_gains_reclaim_equal_cost_this_turn = "эта карта получает Возвышение, равное её стоимости, до конца хода";
target_gains_reclaim_for_cost_this_turn($target, $r) = "{$target} получает {reclaim_for_cost($r)} до конца хода";
target_gains_reclaim_equal_cost_this_turn($target) = :from($target) :match($target) {
    *fem: "{$target} получает Возвышение, равное её стоимости, до конца хода",
    neut: "{$target} получает Возвышение, равное его стоимости, до конца хода",
    masc: "{$target} получает Возвышение, равное его стоимости, до конца хода",
};


void_subject_single($pred) = "{@cap $pred:nom} в вашей Пустоте";
void_subject_exactly($n, $pred) = "{$n} {$pred:other} в вашей Пустоте";
void_subject_all = "все карты в вашей Пустоте";
void_subject_all_but_one($pred) = "все {$pred:other}, кроме одного, в вашей Пустоте";
void_subject_up_to($n, $pred) = "до {$n} {$pred:other} в вашей Пустоте";
void_subject_any_number($pred) = "любое количество {$pred:other} в вашей Пустоте";
void_subject_or_more($n, $pred) = "{$n} или больше {$pred:other} в вашей Пустоте";
void_subject_each_other = "каждая другая карта в вашей Пустоте";

void_gains_reclaim_for_cost_singular($subject, $r) = "{$subject} получает {reclaim_for_cost($r)}";
void_gains_reclaim_equal_cost_singular($subject) = "{$subject} получает Возвышение, равное его стоимости";
void_gains_reclaim_for_cost_plural($subject, $r) = "{$subject} получают {reclaim_for_cost($r)}";
void_gains_reclaim_equal_cost_plural($subject) = "{$subject} получают Возвышение, равное их стоимости";
void_gains_reclaim_for_cost_singular_this_turn($subject, $r) = "{$subject} получает {reclaim_for_cost($r)} до конца хода";
void_gains_reclaim_equal_cost_singular_this_turn($subject) = "{$subject} получает Возвышение, равное его стоимости, до конца хода";
void_gains_reclaim_for_cost_plural_this_turn($subject, $r) = "{$subject} получают {reclaim_for_cost($r)} до конца хода";
void_gains_reclaim_equal_cost_plural_this_turn($subject) = "{$subject} получают Возвышение, равное их стоимости, до конца хода";


your_cards_cost_increase($matching, $e) = "Ваши {$matching:nom_pl} стоят на {energy($e)} больше";
your_cards_cost_reduction($matching, $e) = "Ваши {$matching:nom_pl} стоят на {energy($e)} меньше";
enemy_cards_cost_increase($matching, $e) = "{$matching:nom_pl} противника стоят на {energy($e)} больше";
spark_bonus_other_characters($matching, $s) = :from($matching) "Союзные {$matching:nom_pl} получают +{$s} к искре";
additional_cost_to_play($cost) = "To play {this_card}, {$cost}";
play_for_alternate_cost_simple($card_type, $e) = "{$card_type:nom} стоит {energy($e)}";
play_for_alternate_cost_with_additional($cost, $card_type, $e) = :from($card_type) "{$cost}: Сыграйте {$card_type:acc} за {energy($e)}";
play_for_alternate_cost_abandon($cost, $card_type, $e) = "{$cost}: Play {$card_type} for {energy($e)}, then abandon it";
characters_in_hand_have_fast = "персонажи в вашей руке имеют {fast}";
disable_enemy_materialized_abilities = "disable the {Materialized} abilities of enemies";
has_all_character_types = "У этого персонажа есть все типы персонажей";
multiply_energy_gain($n) = "До конца хода удвойте количество {energy_symbol}, которое вы получаете от эффектов карт";
multiply_card_draw($n) = "До конца хода удвойте количество карт, которые вы берёте от эффектов карт";
once_per_turn_play_from_void($matching) = "once per turn, you may play {$matching} from your void";
reveal_top_card = "покажите верхнюю карту вашей колоды";
you_may_look_at_top_card = "you may look at the top card of your deck";
you_may_play_from_top_of_deck($matching) = :from($matching) "вы можете играть {$matching:other} с верха вашей колоды";
judgment_triggers_when_materialized($matching) = "the '{Judgment}' ability of {$matching:other} triggers when you {materialize} them";
spark_equal_to_predicate_count($matching) = "Искра {this_character:gen} равна количеству {$matching:other}";
play_only_from_void = "you may only play {this_character} from your void";
play_from_hand_or_void_for_cost($e) = "you may play {this_card} from your hand or void for {energy($e)}";
cards_in_void_have_reclaim = "they have {reclaim} equal to their cost";
cost_reduction_for_each($e, $quantity) = "{this_card} costs {energy($e)} less for each {$quantity}";
spark_bonus_your_characters($matching, $s) = :from($matching) "союзные {$matching:nom_pl} получают +{$s} к искре";
play_from_void_for_cost($e) = "play {this_card} from your void for {energy($e)}";
play_from_void_with_additional_cost($cost, $e) = "{$cost}: play {this_card} from your void for {energy($e)}";
play_from_void_with_effect($cost, $e, $effect) = "{$cost}: play {this_card} from your void for {energy($e)}, then {$effect}";
play_from_void_for_cost_with_effect($e, $effect) = "play {this_card} from your void for {energy($e)}, then {$effect}";


if_this_card_in_void_prefix($base) = "если эта карта находится в вашей Пустоте, {$base}";
condition_prepended($condition, $base) = "{$condition} {$base}";
condition_appended($base, $condition) = "{$base} {$condition}";


capitalized_sentence($s) = "{@cap $s}";
reclaim_with_cost($cost) = "{Reclaim} -- {$cost}";

triggered_ability($trig, $eff) = "{@cap $trig}{$eff}";
prefixed_triggered_ability($pfx, $trig, $eff) = "{$pfx}{$trig}{$eff}";
keyword_triggered_ability($trig, $eff) = "{$trig} {@cap $eff}";
prefixed_keyword_triggered_ability($pfx, $trig, $eff) = "{$pfx}{$trig} {@cap $eff}";
activated_ability($c, $eff) = "{$c}{cost_effect_separator}{@cap $eff}";
activated_ability_once_per_turn($c, $eff) = "{$c}{once_per_turn_suffix}{cost_effect_separator}{@cap $eff}";
fast_activated_ability($c, $eff) = "{fast_prefix}{$c}{cost_effect_separator}{@cap $eff}";
fast_activated_ability_once_per_turn($c, $eff) = "{fast_prefix}{$c}{once_per_turn_suffix}{cost_effect_separator}{@cap $eff}";
activated_cost_separator = ", ";

effect_with_period($e) = "{$e}{period_suffix}";
condition_with_effect($cond, $body) = "{$cond} {$body}";
optional_effect_body($body) = "{you_may_prefix}{$body:inf}";
optional_cost_effect_body($cost, $body) = "{you_may_prefix}{cost_to_connector($cost)}{$body:inf}";
cost_effect_body($cost, $body) = "{cost_to_connector($cost)}{$body}";
per_effect_optional($body) = "{you_may_prefix}{$body:inf}";
per_effect_cost($cost, $body) = "{cost_to_connector($cost)}{$body}";
per_effect_condition($cond, $body) = "{$cond} {$body}";
capitalized_sentence_with_period($s) = "{@cap $s}{period_suffix}";

modal_choice_line($energy_cost, $effect) = "{bullet} {$energy_cost}{cost_effect_separator}{@cap $effect}";
