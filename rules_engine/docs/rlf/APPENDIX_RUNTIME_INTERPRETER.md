# Appendix: RLF Runtime Interpreter

This appendix describes the design of a runtime interpreter for RLF, enabling
evaluation of template strings at runtime while referencing phrases defined via
the compile-time macros.

## Motivation

The RLF compile-time macros (`rlf_source!`, `rlf_lang!`) generate efficient Rust
code with full type safety and IDE support. However, some use cases require
evaluating template strings at runtime:

- **Data-driven content**: Evaluate templates from TOML, JSON, or other data files
- **User-generated content**: Load card text from external sources
- **Development workflow**: Test templates without recompiling
- **Dynamic text**: Evaluate templates constructed at runtime

The runtime interpreter evaluates arbitrary template strings while allowing them
to reference compiled phrases for shared vocabulary.

---

## Design Goals

1. **String-first**: Evaluate arbitrary template strings from any source
2. **Reference compiled phrases**: Runtime templates can call compiled phrases
3. **Extensible transforms**: Register custom transforms without modifying the interpreter
4. **Consistency**: Same semantics as compile-time evaluation
5. **Safety**: Rich error handling with actionable messages

---

## Architecture Overview

The interpreter consists of four core components:

**RlfInterpreter** is the main entry point, coordinating parsing and evaluation.
It holds references to the phrase registry and transform registry for each
language.

**Parser** converts template strings into an abstract syntax tree (AST). It
handles the full RLF grammar including literals, interpolations, transforms,
selections, and escape sequences.

**Evaluator** traverses the AST and produces output strings. It resolves
references, applies selections, executes transforms, and handles errors.

**PhraseRegistry** stores compiled phrases registered from `rlf_source!` and
`rlf_lang!` macros. Runtime templates can reference these phrases but cannot
add new phrases to the registry.

**TransformRegistry** maps transform names to implementations. Applications
register transform functions at startup, enabling full customization of
available transforms without modifying the interpreter.

---

## Phrase Registry

The registry provides access to compiled phrases from the interpreter.

### Compiled Phrases

Phrases originate from `rlf_source!` or `rlf_lang!` macros. The registry stores:

- A function pointer for parameterless phrases (returning a `Phrase` value)
- An evaluation function for parameterized phrases (taking `&[Value]` and
  returning `Result<String, RlfError>`)
- Parameter names for validation

### Registration

The `rlf_source!` and `rlf_lang!` macros generate a `RlfRegisterable` trait
implementation. This trait has a single method `register(&mut PhraseRegistry)`
that inserts all phrases into the registry with their function pointers and
parameter metadata.

```rust
// Generated by rlf_source!
impl RlfRegisterable for En {
    fn register(registry: &mut PhraseRegistry) {
        registry.register_phrase("card", Self::card, &[]);
        registry.register_phrase("draw", Self::draw, &["n"]);
        // ...
    }
}
```

### Lookup Algorithm

Phrase resolution:

1. **Check compiled phrases**: Look up by name in the registered phrases
2. **Fallback registry**: If not found and a fallback language is configured,
   recurse into the fallback registry

If no match is found, the registry returns an `UnknownPhrase` error containing
the requested name and a list of available phrases for suggestions.

---

## Parser

The parser converts template strings into an AST suitable for evaluation.

### Grammar

The grammar handles:

- **Literals**: Any text not containing special characters
- **Escape sequences**: `{{`, `}}`, `@@`, `::` for literal braces, at-signs, colons
- **Interpolations**: `{...}` blocks containing transforms, references, selectors

Within interpolations:
- **Transforms**: Zero or more `@name` or `@name:context` prefixes
- **References**: Parameter names, phrase names, or phrase calls with arguments
- **Selectors**: Zero or more `:key` suffixes for variant selection

### AST Structure

The AST consists of `Template` (a sequence of `Segment`s), where each segment is
either a `Literal` (verbatim text) or an `Interpolation`. Interpolations contain
a list of transforms (each with optional context), a reference (parameter, phrase,
or phrase call), and a list of selectors. All nodes carry span information for
error reporting.

### Parsing Algorithm

The parser uses a single-pass character-by-character approach:

1. **Main loop**: Scan for special sequences (`{{`, `}}`, `@@`, `::`, `{`)
2. **Escape handling**: Double characters emit single literals
3. **Interpolation parsing**: On `{`, enter interpolation mode
4. **Transform parsing**: Consume `@name(:context)?` sequences until non-`@`
5. **Reference parsing**: Parse identifier, check for `(` to detect phrase calls
6. **Selector parsing**: Consume `:key` sequences until `}`
7. **Span tracking**: Record start/end positions for all nodes

The parser maintains a context stack for nested error messages, pushing context
like "parsing interpolation" or "parsing transform" to help users locate errors.

### Error Recovery

Parse errors include the source text, the exact span where the error occurred,
and the context stack. The error message extracts the relevant line and displays
a caret pointing to the error position. For unknown identifiers, the parser
suggests similar names using Levenshtein distance.

---

## Evaluator

The evaluator traverses the AST and produces output strings.

### Evaluation Context

Evaluation requires:

- **Phrase registry**: For resolving phrase references
- **Transform registry**: For executing transforms
- **Parameters**: A map from parameter names to `Value`s
- **Language code**: For CLDR plural rules and language-specific transforms
- **Phrase stack**: For cycle detection (prevents infinite recursion)
- **Max depth**: Configurable recursion limit (default 64)

### Evaluation Algorithm

Template evaluation processes segments sequentially:

1. **Literals**: Copy directly to output
2. **Interpolations**: Resolve reference, apply selectors, apply transforms

For interpolations:

1. **Resolve reference**: Parameters return their value directly. Phrase
   references look up the phrase in the registry and either return the `Phrase`
   value (for parameterless phrases) or evaluate with provided arguments.

2. **Apply selectors**: Each selector extracts a variant from the current value.
   For numeric selectors on `Phrase` values, compute the CLDR plural category
   (one/two/few/many/other) and use it as the variant key. For phrase selectors,
   read the phrase's first tag. Literal selectors use the key directly.

3. **Apply transforms**: Transforms execute right-to-left (innermost first).
   Each transform receives the current value and optional context, returning a
   modified string.

### Selector Resolution

Variant selection follows the same fallback logic as compile-time:

1. Try exact key match (e.g., "nom.many")
2. Try progressively shorter keys by removing the last dot-segment (e.g., "nom")
3. If no match found, return `MissingVariant` error

For parameter-based selectors, the algorithm determines the key:

- **Numbers**: Map to CLDR plural category via `icu_plurals`
- **Phrases**: Use the phrase's first metadata tag
- **Strings**: Parse as number if possible, otherwise use literally

### Cycle Detection

Before resolving a phrase, the evaluator checks if the phrase name exists in the
current phrase stack. If found, it returns a `CyclicReference` error showing the
full stack. The stack is pushed before evaluation and popped after, ensuring
accurate tracking through nested phrase calls.

### Transform Execution

The transform registry looks up the transform by name and language:

1. Check for language-specific alias (e.g., `@an` → `@a` in English)
2. Look in language-specific transforms
3. Look in universal transforms
4. Return `UnknownTransform` error if not found

Transform functions receive the current `Value` and optional context `Value`.
They return either a transformed string or an error (typically `MissingRequiredTag`
when the value lacks expected metadata).

---

## Transform Registry

The transform registry is fully user-configurable. Applications register their
own transform implementations at startup.

### Registration API

```rust
impl TransformRegistry {
    /// Register a transform for a specific language.
    pub fn register(
        &mut self,
        language: LanguageCode,
        name: &str,
        transform: TransformFn,
    );

    /// Register an alias (e.g., "@an" → "@a").
    pub fn register_alias(
        &mut self,
        language: LanguageCode,
        alias: &str,
        target: &str,
    );

    /// Register a universal transform (available in all languages).
    pub fn register_universal(&mut self, name: &str, transform: TransformFn);
}

/// Transform function signature.
/// Receives the input value, optional context value, and returns transformed text.
pub type TransformFn = fn(value: Value, context: Option<Value>) -> Result<String, RlfError>;
```

### Example Registration

```rust
// Register universal transforms
registry.register_universal("cap", transforms::capitalize);
registry.register_universal("upper", transforms::uppercase);
registry.register_universal("lower", transforms::lowercase);

// Register English-specific transforms
registry.register("en", "a", transforms::en::indefinite_article);
registry.register_alias("en", "an", "a");

// Register Spanish-specific transforms
registry.register("es", "el", transforms::es::definite_article);
registry.register("es", "un", transforms::es::indefinite_article);
```

### Transform Implementation Contract

Transform functions receive:

1. **value**: The `Value` being transformed (may be a `Phrase` with tags/variants)
2. **context**: Optional context value (e.g., `:acc` in `@der:acc`)

Transforms should:

1. **Check required tags**: Return `MissingRequiredTag` if expected tags are absent
2. **Handle context**: Use context to modify behavior when provided
3. **Return transformed text**: Extract and transform the value's text

Transforms should never silently guess—if a required tag is missing, they error
rather than applying heuristics that might produce incorrect output.

---

## Optional: Loading Phrases from Files

The interpreter can optionally load phrase definitions from `.rlf` files. This
is useful for:

- Defining shared vocabulary in data files
- Community translations/mods
- Hot-reloading translations during development

### File Format

Runtime phrases use `.rlf` files with a simplified syntax:

```
# Comment
name = "template";
name = :tag "template";
name = :tag1 :tag2 { key1: "variant1", key2: "variant2" };
name(param1, param2) = "template with {param1} and {param2}";
```

The format mirrors the macro syntax without Rust-specific elements.

### Loading API

```rust
impl RlfInterpreter {
    /// Load runtime phrases from a file.
    pub fn load_file(&mut self, language: LanguageCode, path: &Path) -> Result<usize, LoadError>;

    /// Load runtime phrases from a string.
    pub fn load_string(&mut self, language: LanguageCode, content: &str) -> Result<usize, LoadError>;
}
```

Runtime phrases loaded this way are stored separately from compiled phrases and
can be looked up by name when evaluating templates.

---

## Public API

### RlfInterpreter

```rust
impl RlfInterpreter {
    /// Create with default configuration.
    pub fn new() -> Self;

    /// Create with custom configuration.
    pub fn with_config(config: InterpreterConfig) -> Self;

    /// Register compiled phrases for a language.
    /// Phrases from rlf_source!/rlf_lang! macros become available for reference.
    pub fn register_compiled<T: RlfRegisterable>(&mut self, language: LanguageCode);

    /// Register a transform function for a language.
    pub fn register_transform(
        &mut self,
        language: LanguageCode,
        name: &str,
        transform: TransformFn,
    );

    /// Register a universal transform (available in all languages).
    pub fn register_universal_transform(&mut self, name: &str, transform: TransformFn);

    /// Set fallback language for missing phrases.
    pub fn set_fallback(&mut self, language: LanguageCode, fallback: LanguageCode);

    /// Parse and evaluate a template string.
    /// This is the primary entry point for evaluating arbitrary templates.
    pub fn eval_str(
        &self,
        template: &str,
        language: &LanguageCode,
        params: HashMap<String, Value>,
    ) -> Result<String, RlfError>;

    /// Parse a template string to AST (for caching/reuse).
    pub fn parse(&self, template: &str) -> Result<Template, ParseError>;

    /// Evaluate a parsed template.
    pub fn eval(
        &self,
        template: &Template,
        language: &LanguageCode,
        params: HashMap<String, Value>,
    ) -> Result<String, EvalError>;

    /// Call a compiled phrase by name with arguments.
    pub fn call_phrase(
        &self,
        language: &LanguageCode,
        name: &str,
        args: &[Value],
    ) -> Result<String, RlfError>;

    /// Get a compiled phrase as a Value for use as parameter.
    pub fn get_phrase(&self, language: &LanguageCode, name: &str) -> Result<Phrase, RlfError>;
}
```

### Primary Use Case: Evaluating Data-Driven Templates

The main entry point is `eval_str`, which evaluates arbitrary template strings:

```rust
// Load rules text from a TOML file
let rules_text = "{Foresee}.";  // From data file
let variables = hashmap! { "foresee" => Value::Number(1) };

let result = interpreter.eval_str(rules_text, &lang, variables)?;
// → "Foresee 1." (after expanding {Foresee} via compiled phrase)
```

Templates can reference compiled phrases, use transforms, and receive parameters
from the calling code. The template source is irrelevant to the interpreter—it
just evaluates strings.

### Configuration

`InterpreterConfig` controls:

- `max_depth`: Maximum recursion depth (default 64)
- `debug_logging`: Enable detailed evaluation logging (default false)
- `fallback_language`: Default fallback for new registries (default "en")

### Value Type

The `Value` enum represents runtime values:

- `Value::Number(i64)`: Integer values, used for plural selection
- `Value::Float(f64)`: Floating point values
- `Value::String(String)`: Text values
- `Value::Phrase(Phrase)`: Phrase values with variants and tags

Values convert automatically via `Into<Value>` implementations for common types.

---

## Command Line Tool

The `rlf` binary provides three main commands:

### rlf check

Validates template syntax without full evaluation. Can validate:
- Individual template strings via `--template "..."`
- `.rlf` phrase files via file paths

Supports `--quiet` for CI integration (exit code only) and `--strict` to treat
warnings as errors. Output formats: human-readable (default) or JSON for tooling.

### rlf eval

Evaluates a template string. Requires `--lang` to specify language and accepts
`--param key=value` for parameters. Can optionally load `--phrases` files to
make additional phrases available. Useful for quick testing:

```bash
rlf eval --lang en --param n=3 --template "Draw {n} {card:n}."
# → "Draw 3 cards."
```

### rlf repl

Interactive evaluation mode. Maintains parameter state between evaluations.
Special commands:

- `:lang CODE` — Switch language
- `:load FILE` — Load phrases from file
- `:set K=V` — Set parameter
- `:clear` — Clear parameters
- `:phrases` — List available phrases
- `:quit` — Exit

---

## Error Handling

### Error Categories

**Parse errors** occur during template parsing: unexpected characters, unterminated
interpolations, invalid identifiers. They include source span and context stack.

**Evaluation errors** occur during template evaluation: unknown phrases/parameters,
missing variants, missing required tags, cyclic references, depth exceeded.

**Load errors** occur during file loading: I/O errors, parse errors with file
context.

### Error Message Quality

All errors aim to be actionable:

1. **Location**: Exact position in source with line/column and visual indicator
2. **Context**: What was being parsed/evaluated when the error occurred
3. **Suggestions**: For unknown names, suggest similar alternatives
4. **Hints**: For missing tags, show example of correct phrase definition

### Error Types

```rust
pub enum RlfError {
    Parse(ParseError),
    Eval(EvalError),
    Load(LoadError),
    UnknownLanguage(LanguageCode),
    InvalidPhraseCall(String),
    NotAPhrase(String),
}

pub enum EvalError {
    UnknownPhrase { name: String, available: Vec<String> },
    UnknownParameter { name: String, available: Vec<String> },
    UnknownTransform { name: String, language: LanguageCode },
    CyclicReference { phrase: String, stack: Vec<String> },
    MaxDepthExceeded { depth: usize, stack: Vec<String> },
    MissingVariant { phrase: String, requested: String, available: Vec<String> },
    MissingRequiredTag { operation: &'static str, expected_tags: &'static [&'static str], value: String },
    InvalidSelection { value: String, selector: String, reason: &'static str },
    // ... additional variants
}
```

---

## Logging

The interpreter uses `tracing` for structured logging at five levels:

- **error**: Evaluation failures, load errors
- **warn**: Missing phrases using fallback, deprecated features
- **info**: File loads, phrase registrations
- **debug**: Evaluation steps, transform applications, selector resolution
- **trace**: Parser state, AST details

Debug logging shows the complete evaluation trace: parameter resolution, phrase
lookups, selector applications, and transform executions. This aids debugging
complex template issues.

---

## Performance

### Caching Strategies

**Template caching**: Parse results can be cached by source string hash. Since
templates are immutable after parsing, the cache never needs invalidation.

**Plural rules**: CLDR plural rules are computed once per language using
`icu_plurals`. The `PluralRules` object is cached in the evaluation context.

**Transform lookup**: HashMap-based O(1) lookup by transform name and language.

### Memory Characteristics

**Compiled phrases** use static references (`&'static str`) for zero-copy access.
Phrase registries are reference-counted (`Arc`) for sharing between threads.

**Parsed templates** own their source text for error reporting. AST nodes use
owned strings for identifiers. Applications can cache parsed templates to avoid
re-parsing frequently-used templates.

---

## Integration with Compile-Time System

### One-Directional Interop

The interpreter can call compiled phrases, but compiled phrases cannot reference
runtime-evaluated templates. This is by design:

- **Interpreter → Compiled**: Runtime templates can reference any compiled phrase
- **Compiled → Interpreter**: Not supported; compiled code is self-contained

This keeps the compile-time system simple and predictable while giving the
interpreter full access to the compiled vocabulary.

### Generated Registration

The `rlf_source!` and `rlf_lang!` macros generate `RlfRegisterable` implementations
that register all phrases with the interpreter:

```rust
// Generated by the macro
impl RlfRegisterable for En {
    fn register(registry: &mut PhraseRegistry) {
        // Parameterless phrases register a getter
        registry.register_parameterless("card", || En.card());

        // Parameterized phrases register an evaluator
        registry.register_parameterized("draw", &["n"], |args| En.draw(args[0].clone()));
    }
}
```

### Typical Usage

```rust
// 1. Create interpreter
let mut interpreter = RlfInterpreter::new();

// 2. Register compiled phrases
interpreter.register_compiled::<En>("en");
interpreter.register_compiled::<Es>("es");

// 3. Register transforms
interpreter.register_universal_transform("cap", transforms::capitalize);
interpreter.register_transform("en", "a", transforms::en::indefinite_article);

// 4. Set up fallbacks
interpreter.set_fallback("es", "en");

// 5. Evaluate templates from data files
let template = load_rules_text_from_toml("cards.toml", card_id);
let result = interpreter.eval_str(&template, &lang, params)?;
```

---

## Summary

The runtime interpreter evaluates RLF template strings from any source while
providing access to compiled phrases and user-registered transforms.

### Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| String-first API | Evaluate templates from any source (TOML, JSON, etc.) |
| One-directional interop | Interpreter calls compiled; keeps compile-time simple |
| Extensible transforms | Applications register their own transform functions |
| Same evaluation semantics | Consistent behavior with compile-time evaluation |
| Rich error context | Development-friendly debugging |

### Trade-offs

| Compile-Time | Runtime Interpreter |
|--------------|---------------------|
| Zero runtime cost | Per-evaluation parsing/evaluation overhead |
| Full type safety | Errors detected at runtime |
| IDE autocomplete | No IDE support for data-driven templates |
| Requires recompilation | Evaluate templates from data files |

### Recommended Usage

- **Core vocabulary**: Define via macros for type safety and reuse
- **Data-driven text**: Evaluate via interpreter (card text, UI strings from data)
- **Transforms**: Register at application startup based on supported languages
- **Development**: Use REPL or CLI for quick template testing
